## Test early-out for unkeyed head
#run_mlr head -n 2 then put 'end{ print "Final NR is ".NR}' $indir/abixy-wide
#run_mlr head -n 2 -g a then put 'end{ print "Final NR is ".NR}' $indir/abixy-wide
#run_mlr cat then head -n 2 then put 'end{ print "Final NR is ".NR}' $indir/abixy-wide
#run_mlr tac then head -n 2 then put 'end{ print "Final NR is ".NR}' $indir/abixy-wide
#run_mlr head -n 2 then put 'end{ print "Final NR is ".NR}' $indir/abixy-wide $indir/abixy-wide $indir/abixy-wide

## ----------------------------------------------------------------
#announce NON-INTERPOLATED AND INTERPOLATED PERCENTILES
#
#for k in 1 2 3 4 5 6 7 8 9 10 11; do
#run_mlr --from $indir/x0to10.dat --oxtab head -n $k then stats1 -f x -a p00,p01,p02,p03,p04,p05,p06,p07,p08,p09,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20,p21,p22,p23,p24,p25,p26,p27,p28,p29,p30,p31,p32,p33,p34,p35,p36,p37,p38,p39,p40,p41,p42,p43,p44,p45,p46,p47,p48,p49,p50,p51,p52,p53,p54,p55,p56,p57,p58,p59,p60,p61,p62,p63,p64,p65,p66,p67,p68,p69,p70,p71,p72,p73,p74,p75,p76,p77,p78,p79,p80,p81,p82,p83,p84,p85,p86,p87,p88,p89,p90,p91,p92,p93,p94,p95,p96,p97,p98,p99,p100
#done
#
#for k in 1 2 3 4 5 6 7 8 9 10 11; do
#run_mlr --from $indir/x0to10.dat --oxtab head -n $k then stats1 -i -f x -a p00,p01,p02,p03,p04,p05,p06,p07,p08,p09,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20,p21,p22,p23,p24,p25,p26,p27,p28,p29,p30,p31,p32,p33,p34,p35,p36,p37,p38,p39,p40,p41,p42,p43,p44,p45,p46,p47,p48,p49,p50,p51,p52,p53,p54,p55,p56,p57,p58,p59,p60,p61,p62,p63,p64,p65,p66,p67,p68,p69,p70,p71,p72,p73,p74,p75,p76,p77,p78,p79,p80,p81,p82,p83,p84,p85,p86,p87,p88,p89,p90,p91,p92,p93,p94,p95,p96,p97,p98,p99,p100
#done

## ----------------------------------------------------------------
#announce DSL SCIENTIFIC NOTATION IN FIELD VALUES
#
#run_mlr --opprint put '$y=$x+1' $indir/scinot.dkvp

## ----------------------------------------------------------------
#announce DSL SCIENTIFIC NOTATION IN EXPRESSION LITERALS
#
#run_mlr --opprint put '$y = 123     + $i' $indir/scinot1.dkvp
#run_mlr --opprint put '$y = 123.    + $i' $indir/scinot1.dkvp
#run_mlr --opprint put '$y = 123.4   + $i' $indir/scinot1.dkvp
#run_mlr --opprint put '$y = .234    + $i' $indir/scinot1.dkvp
#run_mlr --opprint put '$y = 1e2     + $i' $indir/scinot1.dkvp
#run_mlr --opprint put '$y = 1e-2    + $i' $indir/scinot1.dkvp
#run_mlr --opprint put '$y = 1.2e3   + $i' $indir/scinot1.dkvp
#run_mlr --opprint put '$y = 1.e3    + $i' $indir/scinot1.dkvp
#run_mlr --opprint put '$y = 1.2e-3  + $i' $indir/scinot1.dkvp
#run_mlr --opprint put '$y = 1.e-3   + $i' $indir/scinot1.dkvp
#run_mlr --opprint put '$y = .2e3    + $i' $indir/scinot1.dkvp
#run_mlr --opprint put '$y = .2e-3   + $i' $indir/scinot1.dkvp
#run_mlr --opprint put '$y = 1.e-3   + $i' $indir/scinot1.dkvp
#run_mlr --opprint put '$y = -123    + $i' $indir/scinot1.dkvp
#run_mlr --opprint put '$y = -123.   + $i' $indir/scinot1.dkvp
#run_mlr --opprint put '$y = -123.4  + $i' $indir/scinot1.dkvp
#run_mlr --opprint put '$y = -.234   + $i' $indir/scinot1.dkvp
#run_mlr --opprint put '$y = -1e2    + $i' $indir/scinot1.dkvp
#run_mlr --opprint put '$y = -1e-2   + $i' $indir/scinot1.dkvp
#run_mlr --opprint put '$y = -1.2e3  + $i' $indir/scinot1.dkvp
#run_mlr --opprint put '$y = -1.e3   + $i' $indir/scinot1.dkvp
#run_mlr --opprint put '$y = -1.2e-3 + $i' $indir/scinot1.dkvp
#run_mlr --opprint put '$y = -1.e-3  + $i' $indir/scinot1.dkvp
#run_mlr --opprint put '$y = -.2e3   + $i' $indir/scinot1.dkvp
#run_mlr --opprint put '$y = -.2e-3  + $i' $indir/scinot1.dkvp
#run_mlr --opprint put '$y = -1.e-3  + $i' $indir/scinot1.dkvp

## ----------------------------------------------------------------
#announce UTF-8 STRLEN
#
#run_mlr --inidx --ifs comma --oxtab put '$s1=strlen($1);$s2=strlen($2);$s3=strlen($3);$s4=strlen($4)' $indir/utf8-align.dkvp

## ----------------------------------------------------------------
#announce STATS1/STEP INT/FLOAT
#
#run_mlr --opprint step      -a rsum,delta,counter  -f x,y,z $indir/int-float.dkvp
#run_mlr --opprint step   -F -a rsum,delta,counter  -f x,y,z $indir/int-float.dkvp
#run_mlr --oxtab   stats1    -a min,max,sum,count   -f x,y,z $indir/int-float.dkvp
#run_mlr --oxtab   stats1 -F -a min,max,sum,count   -f x,y,z $indir/int-float.dkvp

## ----------------------------------------------------------------
#announce DSL TYPED OVERLAY
#
#run_mlr put '$y = string($x); $z=$y.$y' $indir/int-float.dkvp
#run_mlr put '$z=string($x).string($x)' $indir/int-float.dkvp
#run_mlr put '$y = string($x)' then put '$z=$y.$y' $indir/int-float.dkvp
#run_mlr put '$a="hello"' then put '$b=$a." world";$z=$x+$y;$c=$b;$a=sub($b,"hello","farewell")' $indir/int-float.dkvp


## ----------------------------------------------------------------
#announce DSL SUBSTR
#
#run_mlr put -q '
#  int n = strlen($x);
#  print "input= <<".$x.">>";
#  for (i = -n-2; i <= n+2; i += 1) {
#    for (j = -n-2; j <= n+2; j += 1) {
#      print "i: ".fmtnum(i,"%3lld")
#        ."   j:".fmtnum(j,"%3lld")
#        ."   substr(".$x.",".fmtnum(i,"%3lld").",".fmtnum(j,"%3lld")."): <<"
#        .substr($x, i, j) .">>";
#    }
#    print;
#}
#' << EOF
#x=
#x=o
#x=o1
#x=o123456789
#EOF

## ----------------------------------------------------------------
#announce OOSVAR-FROM-SREC ASSIGNMENT
#
#run_mlr put -v '@v     = $*' /dev/null
#run_mlr put -v '@v[1]  = $*' /dev/null
#run_mlr put -v '@v[$2] = $*' /dev/null
#run_mlr put -v 'NR == 3 {@v     = $*}' /dev/null
#run_mlr put -v 'NR == 3 {@v[1]  = $*}' /dev/null
#run_mlr put -v 'NR == 3 {@v[$2] = $*}' /dev/null
#
#run_mlr --oxtab put -q '@v = $*; end {emitp @v }' $indir/abixy-het
#
#run_mlr --oxtab put -q '@v[$a] = $*; end {emitp @v      }' $indir/abixy-het
#run_mlr --oxtab put -q '@v[$a] = $*; end {emitp @v, "a" }' $indir/abixy-het
#
#run_mlr --oxtab put -q '@v[$a][$b] = $*; end {emitp @v          }' $indir/abixy-het
#run_mlr --oxtab put -q '@v[$a][$b] = $*; end {emitp @v, "a"     }' $indir/abixy-het
#run_mlr --oxtab put -q '@v[$a][$b] = $*; end {emitp @v, "a", "b"}' $indir/abixy-het

## ----------------------------------------------------------------
#announce SREC-FROM-OOSVAR ASSIGNMENT
#
#run_mlr put -v '$* = @v    ' /dev/null
#run_mlr put -v '$* = @v[1] ' /dev/null
#run_mlr put -v '$* = @v[$2]' /dev/null
#run_mlr put -v 'NR == 3 {$* = @v    }' /dev/null
#run_mlr put -v 'NR == 3 {$* = @v[1] }' /dev/null
#run_mlr put -v 'NR == 3 {$* = @v[$2]}' /dev/null
#
#run_mlr put '@v[NR] = $a; NR == 7 { @v = $*} ; $* = @v' $indir/abixy-het

## ----------------------------------------------------------------
#announce OOSVAR-FROM-OOSVAR ASSIGNMENT
#
#run_mlr put -v '@u    = @v'    /dev/null
#run_mlr put -v '@u    = @v[1]' /dev/null
#run_mlr put -v '@u[2] = @v'    /dev/null
#run_mlr put -v '@u[2] = @v[1]' /dev/null
#
#run_mlr put -v 'begin { @u    = @v }'    /dev/null
#run_mlr put -v 'begin { @u    = @v[1] }' /dev/null
#run_mlr put -v 'begin { @u[2] = @v }'    /dev/null
#run_mlr put -v 'begin { @u[2] = @v[1] }' /dev/null
#
#run_mlr put -v 'NR == 3 { @u    = @v }'    /dev/null
#run_mlr put -v 'NR == 3 { @u    = @v[1] }' /dev/null
#run_mlr put -v 'NR == 3 { @u[2] = @v }'    /dev/null
#run_mlr put -v 'NR == 3 { @u[2] = @v[1] }' /dev/null
#
#run_mlr put -v 'end { @u    = @v }'    /dev/null
#run_mlr put -v 'end { @u    = @v[1] }' /dev/null
#run_mlr put -v 'end { @u[2] = @v }'    /dev/null
#run_mlr put -v 'end { @u[2] = @v[1] }' /dev/null
#
#
#run_mlr put -q '@s    += $i; @t=@s;             end{dump; emitp@s; emitp @t}' $indir/abixy
#
#run_mlr put -q '@s[1] += $i; @t=@s;             end{dump; emitp@s; emitp @t}' $indir/abixy
#run_mlr put -q '@s[1] += $i; @t=@s[1];          end{dump; emitp@s; emitp @t}' $indir/abixy
#
#run_mlr put -q '@s[1] += $i; @t[3]=@s;          end{dump; emitp@s; emitp @t}' $indir/abixy
#run_mlr put -q '@s[1] += $i; @t[3]=@s[1];       end{dump; emitp@s; emitp @t}' $indir/abixy
#
#run_mlr put -q '@s[1][2] += $i; @t=@s;             end{dump; emitp@s; emitp @t}' $indir/abixy
#run_mlr put -q '@s[1][2] += $i; @t=@s[1];          end{dump; emitp@s; emitp @t}' $indir/abixy
#run_mlr put -q '@s[1][2] += $i; @t=@s[1][2];       end{dump; emitp@s; emitp @t}' $indir/abixy
#
#run_mlr put -q '@s[1][2] += $i; @t[3]=@s;          end{dump; emitp@s; emitp @t}' $indir/abixy
#run_mlr put -q '@s[1][2] += $i; @t[3]=@s[1];       end{dump; emitp@s; emitp @t}' $indir/abixy
#run_mlr put -q '@s[1][2] += $i; @t[3]=@s[1][2];    end{dump; emitp@s; emitp @t}' $indir/abixy
#
#run_mlr put -q '@s[1][2] += $i; @t[3][4]=@s;       end{dump; emitp@s; emitp @t}' $indir/abixy
#run_mlr put -q '@s[1][2] += $i; @t[3][4]=@s[1];    end{dump; emitp@s; emitp @t}' $indir/abixy
#run_mlr put -q '@s[1][2] += $i; @t[3][4]=@s[1][2]; end{dump; emitp@s; emitp @t}' $indir/abixy
#
#run_mlr --opprint put -q '@s[NR][NR] = $i/100; @t[NR*10]=@s; end{emitp@s,"A","B"; emitp @t,"C","D","E"}' $indir/abixy

## ----------------------------------------------------------------
#announce MAP-VARIANT DUMPS
#
#run_mlr --from $indir/abixy-het put -q 'dump {"a"."b":$a.$b}'
#run_mlr --from $indir/abixy-het put -q 'func f(a, b) { return {"a"."b":a.b} } dump f($a, $b)'

## ----------------------------------------------------------------
#announce PREFIXED/UNPREFIXED EMIT
#
#run_mlr --oxtab put -q '@sum     += $x; end{dump;emitp  @sum     }'  $indir/abixy-wide
#run_mlr --oxtab put -q '@sum     += $x; end{dump;emit @sum     }'  $indir/abixy-wide
#
#
#run_mlr --oxtab put -q '@sum[$a] += $x; end{dump;emitp  @sum     }'  $indir/abixy-wide
#run_mlr --oxtab put -q '@sum[$a] += $x; end{dump;emit @sum     }'  $indir/abixy-wide
#
#run_mlr --oxtab put -q '@sum[$a] += $x; end{dump;emitp  @sum, "a"}'  $indir/abixy-wide
#run_mlr --oxtab put -q '@sum[$a] += $x; end{dump;emit @sum, "a"}'  $indir/abixy-wide
#
#
#run_mlr --oxtab put -q '@sum[$a][$b] += $x; end{dump;emitp  @sum     }'  $indir/abixy-wide
#run_mlr --oxtab put -q '@sum[$a][$b] += $x; end{dump;emit @sum     }'  $indir/abixy-wide
#
#run_mlr --oxtab put -q '@sum[$a][$b] += $x; end{dump;emitp  @sum, "a"}'  $indir/abixy-wide
#run_mlr --oxtab put -q '@sum[$a][$b] += $x; end{dump;emit @sum, "a"}'  $indir/abixy-wide
#
#run_mlr --opprint put -q '@sum[$a][$b] += $x; end{dump;emitp  @sum, "a", "b"}'  $indir/abixy-wide
#run_mlr --opprint put -q '@sum[$a][$b] += $x; end{dump;emit @sum, "a", "b"}'  $indir/abixy-wide
#
#
#run_mlr --oxtab put -q '@sum[$a][$b][$a.$b] += $x; end{dump;emitp  @sum     }'  $indir/abixy-wide
#run_mlr --oxtab put -q '@sum[$a][$b][$a.$b] += $x; end{dump;emit @sum     }'  $indir/abixy-wide
#
#run_mlr --oxtab put -q '@sum[$a][$b][$a.$b] += $x; end{dump;emitp  @sum, "a"}'  $indir/abixy-wide
#run_mlr --oxtab put -q '@sum[$a][$b][$a.$b] += $x; end{dump;emit @sum, "a"}'  $indir/abixy-wide
#
#run_mlr --opprint put -q '@sum[$a][$b][$a.$b] += $x; end{dump;emitp  @sum, "a", "b"}'  $indir/abixy-wide
#run_mlr --opprint put -q '@sum[$a][$b][$a.$b] += $x; end{dump;emit @sum, "a", "b"}'  $indir/abixy-wide
#
#run_mlr --opprint put -q '@sum[$a][$b][$a.$b] += $x; end{dump;emitp  @sum, "a", "b", "ab"}'  $indir/abixy-wide
#run_mlr --opprint put -q '@sum[$a][$b][$a.$b] += $x; end{dump;emit @sum, "a", "b", "ab"}'  $indir/abixy-wide
#
#
#
#run_mlr --oxtab head -n 2  then put -q '@v       =  $*; end{dump;emitp  @v}'         $indir/abixy
#run_mlr --oxtab head -n 2  then put -q '@v       =  $*; end{dump;emit @v}'         $indir/abixy
#
#
#run_mlr --oxtab head -n 2  then put -q '@v[NR]   =  $*; end{dump;emitp  @v        }' $indir/abixy
#run_mlr --oxtab head -n 2  then put -q '@v[NR]   =  $*; end{dump;emit @v        }' $indir/abixy
#
#run_mlr --opprint head -n 2  then put -q '@v[NR]   =  $*; end{dump;emitp  @v,   "I"}' $indir/abixy
#run_mlr --opprint head -n 2  then put -q '@v[NR]   =  $*; end{dump;emit @v,   "I"}' $indir/abixy
#
#
#run_mlr --oxtab head -n 2  then put -q '@v[NR][NR]   =  $*; end{dump;emitp  @v        }' $indir/abixy
#run_mlr --oxtab head -n 2  then put -q '@v[NR][NR]   =  $*; end{dump;emit @v        }' $indir/abixy
#
#run_mlr --opprint head -n 2  then put -q '@v[NR][NR]   =  $*; end{dump;emitp  @v,   "I"}' $indir/abixy
#run_mlr --opprint head -n 2  then put -q '@v[NR][NR]   =  $*; end{dump;emit @v,   "I"}' $indir/abixy
#
#run_mlr --opprint head -n 2  then put -q '@v[NR][NR]   =  $*; end{dump;emitp  @v,   "I", "J"}' $indir/abixy
#run_mlr --opprint head -n 2  then put -q '@v[NR][NR]   =  $*; end{dump;emit @v,   "I", "J"}' $indir/abixy
#
#
#run_mlr --oxtab head -n 2  then put -q '@v[NR][NR][NR]   =  $*; end{dump;emitp  @v        }' $indir/abixy
#run_mlr --oxtab head -n 2  then put -q '@v[NR][NR][NR]   =  $*; end{dump;emit @v        }' $indir/abixy
#
#run_mlr --opprint head -n 2  then put -q '@v[NR][NR][NR]   =  $*; end{dump;emitp  @v,   "I"}' $indir/abixy
#run_mlr --opprint head -n 2  then put -q '@v[NR][NR][NR]   =  $*; end{dump;emit @v,   "I"}' $indir/abixy
#
#run_mlr --opprint head -n 2  then put -q '@v[NR][NR][NR]   =  $*; end{dump;emitp  @v,   "I", "J"}' $indir/abixy
#run_mlr --opprint head -n 2  then put -q '@v[NR][NR][NR]   =  $*; end{dump;emit @v,   "I", "J"}' $indir/abixy
#
#run_mlr --opprint head -n 2  then put -q '@v[NR][NR][NR]   =  $*; end{dump;emitp  @v,   "I", "J", "K"}' $indir/abixy
#run_mlr --opprint head -n 2  then put -q '@v[NR][NR][NR]   =  $*; end{dump;emit @v,   "I", "J", "K"}' $indir/abixy

## ----------------------------------------------------------------
#announce MAPPER TEE REDIRECTS
#
#tee1=$reloutdir/tee1
#mkdir -p $tee1
#
#run_mlr --from $indir/abixy tee $tee1/out then nothing
#run_cat $tee1/out
#
#run_mlr --from $indir/abixy tee --no-fflush $tee1/out then nothing
#run_cat $tee1/out
#
#run_mlr --from $indir/abixy tee -a $tee1/out then nothing
#run_cat $tee1/out
#
#run_mlr --from $indir/abixy tee -o json $tee1/out then nothing
#run_cat $tee1/out
#
## ----------------------------------------------------------------
#announce DSL TEE REDIRECTS
#
#tee2=$reloutdir/tee2
#mkdir -p $tee2
#
#run_mlr put -q 'tee > "'$tee2'/out.".$a, $*' $indir/abixy
#run_cat $tee2/out.eks
#run_cat $tee2/out.hat
#run_cat $tee2/out.pan
#run_cat $tee2/out.wye
#run_cat $tee2/out.zee
#
#run_mlr put -q --no-fflush 'tee > "'$tee2'/out.".$a, $*' $indir/abixy
#run_cat $tee2/out.eks
#run_cat $tee2/out.hat
#run_cat $tee2/out.pan
#run_cat $tee2/out.wye
#run_cat $tee2/out.zee
#
#run_mlr put -q 'tee >> "'$tee2'/out.".$a, $*' $indir/abixy
#run_cat $tee2/out.eks
#run_cat $tee2/out.hat
#run_cat $tee2/out.pan
#run_cat $tee2/out.wye
#run_cat $tee2/out.zee
#
#run_mlr put -q -o json 'tee > "'$tee2'/out.".$a, $*' $indir/abixy
#run_cat $tee2/out.eks
#run_cat $tee2/out.hat
#run_cat $tee2/out.pan
#run_cat $tee2/out.wye
#run_cat $tee2/out.zee
#
#run_mlr put -q 'tee | "tr \[a-z\] \[A-Z\]", $*' $indir/abixy
#
#run_mlr put -q -o json 'tee | "tr \[a-z\] \[A-Z\]", $*' $indir/abixy
#
#touch $tee2/err1
#run_mlr put -q 'tee > stdout, $*' $indir/abixy 2> $tee2/err1
#run_cat $tee2/err1
#
#touch $tee2/err2
#run_mlr put -q 'tee > stderr, $*' $indir/abixy 2> $tee2/err2
#run_cat $tee2/err2
#
## ----------------------------------------------------------------
#announce DSL PRINT REDIRECTS
#
#print1=$reloutdir/print1
#mkdir -p $print1
#
#run_mlr put -q 'print > "'$print1'/out.".$a, "abi:".$a.$b.$i' $indir/abixy
#run_cat $print1/out.eks
#run_cat $print1/out.hat
#run_cat $print1/out.pan
#run_cat $print1/out.wye
#run_cat $print1/out.zee
#
#run_mlr put -q 'print > "'$print1'/out.".$a, "abi:".$a.$b.$i' $indir/abixy
#run_cat $print1/out.eks
#run_cat $print1/out.hat
#run_cat $print1/out.pan
#run_cat $print1/out.wye
#run_cat $print1/out.zee
#
#run_mlr put -q 'print >> "'$print1'/out.".$a, "abi:".$a.$b.$i' $indir/abixy
#run_cat $print1/out.eks
#run_cat $print1/out.hat
#run_cat $print1/out.pan
#run_cat $print1/out.wye
#run_cat $print1/out.zee
#
#run_mlr put -q 'print | "tr \[a-z\] \[A-Z\]",  "abi:".$a.$b.$i' $indir/abixy
#
#touch $print1/err1
#run_mlr put -q 'print > stdout, "abi:".$a.$b.$i' $indir/abixy 2> $print1/err1
#run_cat $print1/err1
#
#touch $print1/err2
#run_mlr put -q 'print > stderr, "abi:".$a.$b.$i' $indir/abixy 2> $print1/err2
#run_cat $print1/err2
#
## ----------------------------------------------------------------
#announce DSL PRINTN REDIRECTS
#
#printn1=$reloutdir/printn1
#mkdir -p $printn1
#
#run_mlr put -q 'printn > "'$printn1'/out.".$a, "abi:".$a.$b.$i' $indir/abixy
#run_cat $printn1/out.eks
#run_cat $printn1/out.hat
#run_cat $printn1/out.pan
#run_cat $printn1/out.wye
#run_cat $printn1/out.zee
#
#run_mlr put -q 'printn > "'$printn1'/out.".$a, "abi:".$a.$b.$i' $indir/abixy
#run_cat $printn1/out.eks
#run_cat $printn1/out.hat
#run_cat $printn1/out.pan
#run_cat $printn1/out.wye
#run_cat $printn1/out.zee
#
#run_mlr put -q 'printn >> "'$printn1'/out.".$a, "abi:".$a.$b.$i' $indir/abixy
#run_cat $printn1/out.eks
#run_cat $printn1/out.hat
#run_cat $printn1/out.pan
#run_cat $printn1/out.wye
#run_cat $printn1/out.zee
#
#run_mlr put -q 'printn | "tr \[a-z\] \[A-Z\]",  "abi:".$a.$b.$i' $indir/abixy
#
#touch $printn1/err1
#run_mlr put -q 'printn > stdout, "abi:".$a.$b.$i' $indir/abixy 2> $printn1/err1
#run_cat $printn1/err1
#
#touch $printn1/err2
#run_mlr put -q 'printn > stderr, "abi:".$a.$b.$i' $indir/abixy 2> $printn1/err2
#run_cat $printn1/err2
#
## ----------------------------------------------------------------
#announce DSL DUMP REDIRECTS
#
#dump1=$reloutdir/dump1
#mkdir -p $dump1
#
#run_mlr put -q '@v=$*; dump > "'$dump1'/out.".$a' $indir/abixy
#run_cat $dump1/out.eks
#run_cat $dump1/out.hat
#run_cat $dump1/out.pan
#run_cat $dump1/out.wye
#run_cat $dump1/out.zee
#
#run_mlr put -q '@v=$*; dump > "'$dump1'/out.".$a' $indir/abixy
#run_cat $dump1/out.eks
#run_cat $dump1/out.hat
#run_cat $dump1/out.pan
#run_cat $dump1/out.wye
#run_cat $dump1/out.zee
#
#run_mlr put -q '@v=$*; dump >> "'$dump1'/out.".$a' $indir/abixy
#run_cat $dump1/out.eks
#run_cat $dump1/out.hat
#run_cat $dump1/out.pan
#run_cat $dump1/out.wye
#run_cat $dump1/out.zee
#
#run_mlr put -q '@v=$*; dump | "tr \[a-z\] \[A-Z\]"' $indir/abixy
#
#touch $dump1/err1
#run_mlr put -q '@v[NR] = $*; NR == 2 { dump > stdout }' $indir/abixy 2> $dump1/err1
#run_cat $dump1/err1
#
#touch $dump1/err2
#run_mlr put -q '@v[NR] = $*; NR == 2 { dump > stderr }' $indir/abixy 2> $dump1/err2
#run_cat $dump1/err2
#
## ----------------------------------------------------------------
#announce DSL EMITF REDIRECTS
#
#emitf1=$reloutdir/emitf1
#mkdir -p $emitf1
#
#run_mlr put -q '@a=$a; @b=$b; emitf > "'$emitf1'/out.".$a.$b, @a, @b' $indir/abixy
#run_cat $emitf1/out.ekspan
#run_cat $emitf1/out.ekswye
#run_cat $emitf1/out.ekszee
#run_cat $emitf1/out.hatwye
#run_cat $emitf1/out.panpan
#run_cat $emitf1/out.panwye
#run_cat $emitf1/out.wyepan
#run_cat $emitf1/out.wyewye
#run_cat $emitf1/out.zeepan
#run_cat $emitf1/out.zeewye
#
#run_mlr put -q '@a=$a; @b=$b; emitf > "'$emitf1'/out.".$a.$b, @a, @b' $indir/abixy
#run_cat $emitf1/out.ekspan
#run_cat $emitf1/out.ekswye
#run_cat $emitf1/out.ekszee
#run_cat $emitf1/out.hatwye
#run_cat $emitf1/out.panpan
#run_cat $emitf1/out.panwye
#run_cat $emitf1/out.wyepan
#run_cat $emitf1/out.wyewye
#run_cat $emitf1/out.zeepan
#run_cat $emitf1/out.zeewye
#
#run_mlr put -q '@a=$a; @b=$b; emitf >> "'$emitf1'/out.".$a.$b, @a, @b' $indir/abixy
#run_cat $emitf1/out.ekspan
#run_cat $emitf1/out.ekswye
#run_cat $emitf1/out.ekszee
#run_cat $emitf1/out.hatwye
#run_cat $emitf1/out.panpan
#run_cat $emitf1/out.panwye
#run_cat $emitf1/out.wyepan
#run_cat $emitf1/out.wyewye
#run_cat $emitf1/out.zeepan
#run_cat $emitf1/out.zeewye
#
#run_mlr put -q -o json '@a=$a; @b=$b; emitf > "'$emitf1'/out.".$a.$b, @a, @b' $indir/abixy
#run_cat $emitf1/out.ekspan
#run_cat $emitf1/out.ekswye
#run_cat $emitf1/out.ekszee
#run_cat $emitf1/out.hatwye
#run_cat $emitf1/out.panpan
#run_cat $emitf1/out.panwye
#run_cat $emitf1/out.wyepan
#run_cat $emitf1/out.wyewye
#run_cat $emitf1/out.zeepan
#run_cat $emitf1/out.zeewye
#
#run_mlr put -q '@a=$a; @b=$b; emitf | "tr \[a-z\] \[A-Z\]", @a, @b' $indir/abixy
#
#touch $emitf1/err1
#run_mlr put -q '@a=$a; @b=$b; emitf > stdout, @a, @b' $indir/abixy 2> $emitf1/err1
#run_cat $emitf1/err1
#
#touch $emitf1/err2
#run_mlr put -q '@a=$a; @b=$b; emitf > stderr, @a, @b' $indir/abixy 2> $emitf1/err2
#run_cat $emitf1/err2
#
## ----------------------------------------------------------------
#announce DSL EMITP REDIRECTS
#
#emitp1=$reloutdir/emitp1
#mkdir -p $emitp1
#
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > "'$emitp1'/out.".$a.$b, @a' $indir/abixy
#run_cat $emitp1/out.ekspan
#run_cat $emitp1/out.ekswye
#run_cat $emitp1/out.panpan
#run_cat $emitp1/out.wyewye
#
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > "'$emitp1'/out.".$a.$b, @a' $indir/abixy
#run_cat $emitp1/out.ekspan
#run_cat $emitp1/out.ekswye
#run_cat $emitp1/out.panpan
#run_cat $emitp1/out.wyewye
#
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp >> "'$emitp1'/out.".$a.$b, @a' $indir/abixy
#run_cat $emitp1/out.ekspan
#run_cat $emitp1/out.ekswye
#run_cat $emitp1/out.panpan
#run_cat $emitp1/out.wyewye
#
#run_mlr head -n 4 then put -q -o json '@a[NR]=$a; @b[NR]=$b; emitp > "'$emitp1'/out.".$a.$b, @a' $indir/abixy
#run_cat $emitp1/out.ekspan
#run_cat $emitp1/out.ekswye
#run_cat $emitp1/out.panpan
#run_cat $emitp1/out.wyewye
#
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp | "tr \[a-z\] \[A-Z\]", @a' $indir/abixy
#
#touch $emitp1/err1
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > stdout, @a' $indir/abixy 2> $emitp1/err1
#run_cat $emitp1/err1
#
#touch $emitp1/err2
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > stderr, @a' $indir/abixy 2> $emitp1/err2
#run_cat $emitp1/err2
#
#
#emitp2=$reloutdir/emitp2
#mkdir -p $emitp2
#
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > "'$emitp2'/out.".$a.$b, @a, "NR"' $indir/abixy
#run_cat $emitp2/out.ekspan
#run_cat $emitp2/out.ekswye
#run_cat $emitp2/out.panpan
#run_cat $emitp2/out.wyewye
#
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > "'$emitp2'/out.".$a.$b, @a, "NR"' $indir/abixy
#run_cat $emitp2/out.ekspan
#run_cat $emitp2/out.ekswye
#run_cat $emitp2/out.panpan
#run_cat $emitp2/out.wyewye
#
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp >> "'$emitp2'/out.".$a.$b, @a, "NR"' $indir/abixy
#run_cat $emitp2/out.ekspan
#run_cat $emitp2/out.ekswye
#run_cat $emitp2/out.panpan
#run_cat $emitp2/out.wyewye
#
#run_mlr head -n 4 then put -q -o json '@a[NR]=$a; @b[NR]=$b; emitp > "'$emitp2'/out.".$a.$b, @a, "NR"' $indir/abixy
#run_cat $emitp2/out.ekspan
#run_cat $emitp2/out.ekswye
#run_cat $emitp2/out.panpan
#run_cat $emitp2/out.wyewye
#
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp | "tr \[a-z\] \[A-Z\]", @a, "NR"' $indir/abixy
#
#touch $emitp2/err1
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > stdout, @a, "NR"' $indir/abixy 2> $emitp2/err1
#run_cat $emitp2/err1
#
#touch $emitp2/err2
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > stderr, @a, "NR"' $indir/abixy 2> $emitp2/err2
#run_cat $emitp2/err2
#
#
#emitp3=$reloutdir/emitp3
#mkdir -p $emitp3
#
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > "'$emitp3'/out.".$a.$b, (@a, @b)' $indir/abixy
#run_cat $emitp3/out.ekspan
#run_cat $emitp3/out.ekswye
#run_cat $emitp3/out.panpan
#run_cat $emitp3/out.wyewye
#
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > "'$emitp3'/out.".$a.$b, (@a, @b)' $indir/abixy
#run_cat $emitp3/out.ekspan
#run_cat $emitp3/out.ekswye
#run_cat $emitp3/out.panpan
#run_cat $emitp3/out.wyewye
#
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp >> "'$emitp3'/out.".$a.$b, (@a, @b)' $indir/abixy
#run_cat $emitp3/out.ekspan
#run_cat $emitp3/out.ekswye
#run_cat $emitp3/out.panpan
#run_cat $emitp3/out.wyewye
#
#run_mlr head -n 4 then put -q -o json '@a[NR]=$a; @b[NR]=$b; emitp > "'$emitp3'/out.".$a.$b, (@a, @b)' $indir/abixy
#run_cat $emitp3/out.ekspan
#run_cat $emitp3/out.ekswye
#run_cat $emitp3/out.panpan
#run_cat $emitp3/out.wyewye
#
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp | "tr \[a-z\] \[A-Z\]", (@a, @b)' $indir/abixy
#
#touch $emitp3/err1
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > stdout, (@a, @b)' $indir/abixy 2> $emitp3/err1
#run_cat $emitp3/err1
#
#touch $emitp3/err2
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > stderr, (@a, @b)' $indir/abixy 2> $emitp3/err2
#run_cat $emitp3/err2
#
#
#emitp4=$reloutdir/emitp4
#mkdir -p $emitp4
#
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > "'$emitp4'/out.".$a.$b, (@a, @b), "NR"' $indir/abixy
#run_cat $emitp4/out.ekspan
#run_cat $emitp4/out.ekswye
#run_cat $emitp4/out.panpan
#run_cat $emitp4/out.wyewye
#
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > "'$emitp4'/out.".$a.$b, (@a, @b), "NR"' $indir/abixy
#run_cat $emitp4/out.ekspan
#run_cat $emitp4/out.ekswye
#run_cat $emitp4/out.panpan
#run_cat $emitp4/out.wyewye
#
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp >> "'$emitp4'/out.".$a.$b, (@a, @b), "NR"' $indir/abixy
#run_cat $emitp4/out.ekspan
#run_cat $emitp4/out.ekswye
#run_cat $emitp4/out.panpan
#run_cat $emitp4/out.wyewye
#
#run_mlr head -n 4 then put -q -o json '@a[NR]=$a; @b[NR]=$b; emitp > "'$emitp4'/out.".$a.$b, (@a, @b), "NR"' $indir/abixy
#run_cat $emitp4/out.ekspan
#run_cat $emitp4/out.ekswye
#run_cat $emitp4/out.panpan
#run_cat $emitp4/out.wyewye
#
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp | "tr \[a-z\] \[A-Z\]", (@a, @b), "NR"' $indir/abixy
#
#touch $emitp4/err1
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > stdout, (@a, @b), "NR"' $indir/abixy 2> $emitp4/err1
#run_cat $emitp4/err1
#
#touch $emitp4/err2
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > stderr, (@a, @b), "NR"' $indir/abixy 2> $emitp4/err2
#run_cat $emitp4/err2
#
#
#emitp5=$reloutdir/emitp5
#mkdir -p $emitp5
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > "'$emitp5'/out.".$a.$b, @*' $indir/abixy
#run_cat $emitp5/out.ekspan
#run_cat $emitp5/out.ekswye
#run_cat $emitp5/out.panpan
#run_cat $emitp5/out.wyewye
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp | "tr \[a-z\] \[A-Z\]", @*' $indir/abixy
#
#touch $emitp5/err1
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > stdout, @*' $indir/abixy 2> $emitp5/err1
#run_cat $emitp5/err1
#
#touch $emitp5/err2
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > stderr, @*' $indir/abixy 2> $emitp5/err2
#run_cat $emitp5/err2
#
#
#emitp6=$reloutdir/emitp6
#mkdir -p $emitp6
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > "'$emitp6'/out.".$a.$b, all' $indir/abixy
#run_cat $emitp6/out.ekspan
#run_cat $emitp6/out.ekswye
#run_cat $emitp6/out.panpan
#run_cat $emitp6/out.wyewye
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp | "tr \[a-z\] \[A-Z\]", all' $indir/abixy
#
#touch $emitp6/err1
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > stdout, all' $indir/abixy 2> $emitp6/err1
#run_cat $emitp6/err1
#
#touch $emitp6/err2
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > stderr, all' $indir/abixy 2> $emitp6/err2
#run_cat $emitp6/err2
#
#
#emitp7=$reloutdir/emitp7
#mkdir -p $emitp7
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > "'$emitp7'/out.".$a.$b, @*, "NR"' $indir/abixy
#run_cat $emitp7/out.ekspan
#run_cat $emitp7/out.ekswye
#run_cat $emitp7/out.panpan
#run_cat $emitp7/out.wyewye
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp | "tr \[a-z\] \[A-Z\]", @*, "NR"' $indir/abixy
#
#touch $emitp7/err1
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > stdout, @*, "NR"' $indir/abixy 2> $emitp7/err1
#run_cat $emitp7/err1
#
#touch $emitp7/err2
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > stderr, @*, "NR"' $indir/abixy 2> $emitp7/err2
#run_cat $emitp7/err2
#
#
#emitp8=$reloutdir/emitp8
#mkdir -p $emitp8
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > "'$emitp8'/out.".$a.$b, all, "NR"' $indir/abixy
#run_cat $emitp8/out.ekspan
#run_cat $emitp8/out.ekswye
#run_cat $emitp8/out.panpan
#run_cat $emitp8/out.wyewye
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp | "tr \[a-z\] \[A-Z\]", all, "NR"' $indir/abixy
#
#touch $emitp8/err1
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > stdout, all, "NR"' $indir/abixy 2> $emitp8/err1
#run_cat $emitp8/err1
#
#touch $emitp8/err2
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > stderr, all, "NR"' $indir/abixy 2> $emitp8/err2
#run_cat $emitp8/err2
#
#
## ----------------------------------------------------------------
#announce DSL EMIT REDIRECTS
#
#emit1=$reloutdir/emit1
#mkdir -p $emit1
#
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > "'$emit1'/out.".$a.$b, @a' $indir/abixy
#run_cat $emit1/out.ekspan
#run_cat $emit1/out.ekswye
#run_cat $emit1/out.panpan
#run_cat $emit1/out.wyewye
#
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > "'$emit1'/out.".$a.$b, @a' $indir/abixy
#run_cat $emit1/out.ekspan
#run_cat $emit1/out.ekswye
#run_cat $emit1/out.panpan
#run_cat $emit1/out.wyewye
#
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit >> "'$emit1'/out.".$a.$b, @a' $indir/abixy
#run_cat $emit1/out.ekspan
#run_cat $emit1/out.ekswye
#run_cat $emit1/out.panpan
#run_cat $emit1/out.wyewye
#
#run_mlr head -n 4 then put -q -o json '@a[NR]=$a; @b[NR]=$b; emit > "'$emit1'/out.".$a.$b, @a' $indir/abixy
#run_cat $emit1/out.ekspan
#run_cat $emit1/out.ekswye
#run_cat $emit1/out.panpan
#run_cat $emit1/out.wyewye
#
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit | "tr \[a-z\] \[A-Z\]", @a' $indir/abixy
#
#touch $emit1/err1
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stdout, @a' $indir/abixy 2> $emit1/err1
#run_cat $emit1/err1
#
#touch $emit1/err2
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stderr, @a' $indir/abixy 2> $emit1/err2
#run_cat $emit1/err2
#
#
#emit2=$reloutdir/emit2
#mkdir -p $emit2
#
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > "'$emit2'/out.".$a.$b, @a, "NR"' $indir/abixy
#run_cat $emit2/out.ekspan
#run_cat $emit2/out.ekswye
#run_cat $emit2/out.panpan
#run_cat $emit2/out.wyewye
#
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > "'$emit2'/out.".$a.$b, @a, "NR"' $indir/abixy
#run_cat $emit2/out.ekspan
#run_cat $emit2/out.ekswye
#run_cat $emit2/out.panpan
#run_cat $emit2/out.wyewye
#
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit >> "'$emit2'/out.".$a.$b, @a, "NR"' $indir/abixy
#run_cat $emit2/out.ekspan
#run_cat $emit2/out.ekswye
#run_cat $emit2/out.panpan
#run_cat $emit2/out.wyewye
#
#run_mlr head -n 4 then put -q -o pprint '@a[NR]=$a; @b[NR]=$b; emit > "'$emit2'/out.".$a.$b, @a, "NR"' $indir/abixy
#run_cat $emit2/out.ekspan
#run_cat $emit2/out.ekswye
#run_cat $emit2/out.panpan
#run_cat $emit2/out.wyewye
#
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit | "tr \[a-z\] \[A-Z\]", @a, "NR"' $indir/abixy
#
#touch $emit2/err1
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stdout, @a, "NR"' $indir/abixy 2> $emit2/err1
#run_cat $emit2/err1
#
#touch $emit2/err2
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stderr, @a, "NR"' $indir/abixy 2> $emit2/err2
#run_cat $emit2/err2
#
#
#emit3=$reloutdir/emit3
#mkdir -p $emit3
#
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > "'$emit3'/out.".$a.$b, (@a, @b)' $indir/abixy
#run_cat $emit3/out.ekspan
#run_cat $emit3/out.ekswye
#run_cat $emit3/out.panpan
#run_cat $emit3/out.wyewye
#
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > "'$emit3'/out.".$a.$b, (@a, @b)' $indir/abixy
#run_cat $emit3/out.ekspan
#run_cat $emit3/out.ekswye
#run_cat $emit3/out.panpan
#run_cat $emit3/out.wyewye
#
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit >> "'$emit3'/out.".$a.$b, (@a, @b)' $indir/abixy
#run_cat $emit3/out.ekspan
#run_cat $emit3/out.ekswye
#run_cat $emit3/out.panpan
#run_cat $emit3/out.wyewye
#
#run_mlr head -n 4 then put -q --oxtab '@a[NR]=$a; @b[NR]=$b; emit > "'$emit3'/out.".$a.$b, (@a, @b)' $indir/abixy
#run_cat $emit3/out.ekspan
#run_cat $emit3/out.ekswye
#run_cat $emit3/out.panpan
#run_cat $emit3/out.wyewye
#
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit | "tr \[a-z\] \[A-Z\]", (@a, @b)' $indir/abixy
#
#touch $emit3/err1
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stdout, (@a, @b)' $indir/abixy 2> $emit3/err1
#run_cat $emit3/err1
#
#touch $emit3/err2
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stderr, (@a, @b)' $indir/abixy 2> $emit3/err2
#run_cat $emit3/err2
#
#
#emit4=$reloutdir/emit4
#mkdir -p $emit4
#
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > "'$emit4'/out.".$a.$b, (@a, @b), "NR"' $indir/abixy
#run_cat $emit4/out.ekspan
#run_cat $emit4/out.ekswye
#run_cat $emit4/out.panpan
#run_cat $emit4/out.wyewye
#
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > "'$emit4'/out.".$a.$b, (@a, @b), "NR"' $indir/abixy
#run_cat $emit4/out.ekspan
#run_cat $emit4/out.ekswye
#run_cat $emit4/out.panpan
#run_cat $emit4/out.wyewye
#
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit >> "'$emit4'/out.".$a.$b, (@a, @b), "NR"' $indir/abixy
#run_cat $emit4/out.ekspan
#run_cat $emit4/out.ekswye
#run_cat $emit4/out.panpan
#run_cat $emit4/out.wyewye
#
#run_mlr head -n 4 then put -q --ojson '@a[NR]=$a; @b[NR]=$b; emit > "'$emit4'/out.".$a.$b, (@a, @b), "NR"' $indir/abixy
#run_cat $emit4/out.ekspan
#run_cat $emit4/out.ekswye
#run_cat $emit4/out.panpan
#run_cat $emit4/out.wyewye
#
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit | "tr \[a-z\] \[A-Z\]", (@a, @b), "NR"' $indir/abixy
#
#touch $emit4/err1
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stdout, (@a, @b), "NR"' $indir/abixy 2> $emit4/err1
#run_cat $emit4/err1
#
#touch $emit4/err2
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stderr, (@a, @b), "NR"' $indir/abixy 2> $emit4/err2
#run_cat $emit4/err2
#
#
#emit5=$reloutdir/emit5
#mkdir -p $emit5
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > "'$emit5'/out.".$a.$b, @*' $indir/abixy
#run_cat $emit5/out.ekspan
#run_cat $emit5/out.ekswye
#run_cat $emit5/out.panpan
#run_cat $emit5/out.wyewye
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit | "tr \[a-z\] \[A-Z\]", @*' $indir/abixy
#
#touch $emit5/err1
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stdout, @*' $indir/abixy 2> $emit5/err1
#run_cat $emit5/err1
#
#touch $emit5/err2
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stderr, @*' $indir/abixy 2> $emit5/err2
#run_cat $emit5/err2
#
#
#emit6=$reloutdir/emit6
#mkdir -p $emit6
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > "'$emit6'/out.".$a.$b, all' $indir/abixy
#run_cat $emit6/out.ekspan
#run_cat $emit6/out.ekswye
#run_cat $emit6/out.panpan
#run_cat $emit6/out.wyewye
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit | "tr \[a-z\] \[A-Z\]", all' $indir/abixy
#
#touch $emit6/err1
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stdout, all' $indir/abixy 2> $emit6/err1
#run_cat $emit6/err1
#
#touch $emit6/err2
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stderr, all' $indir/abixy 2> $emit6/err2
#run_cat $emit6/err2
#
#
#emit7=$reloutdir/emit7
#mkdir -p $emit7
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > "'$emit7'/out.".$a.$b, @*, "NR"' $indir/abixy
#run_cat $emit7/out.ekspan
#run_cat $emit7/out.ekswye
#run_cat $emit7/out.panpan
#run_cat $emit7/out.wyewye
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit | "tr \[a-z\] \[A-Z\]", @*, "NR"' $indir/abixy
#
#touch $emit7/err1
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stdout, @*, "NR"' $indir/abixy 2> $emit7/err1
#run_cat $emit7/err1
#
#touch $emit7/err2
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stderr, @*, "NR"' $indir/abixy 2> $emit7/err2
#run_cat $emit7/err2
#
#
#emit8=$reloutdir/emit8
#mkdir -p $emit8
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > "'$emit8'/out.".$a.$b, all, "NR"' $indir/abixy
#run_cat $emit8/out.ekspan
#run_cat $emit8/out.ekswye
#run_cat $emit8/out.panpan
#run_cat $emit8/out.wyewye
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit | "tr \[a-z\] \[A-Z\]", all, "NR"' $indir/abixy
#
#touch $emit8/err1
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stdout, all, "NR"' $indir/abixy 2> $emit8/err1
#run_cat $emit8/err1
#
#touch $emit8/err2
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stderr, all, "NR"' $indir/abixy 2> $emit8/err2
#run_cat $emit8/err2
#
#
#emit9=$reloutdir/emit9
#mkdir -p $emit9
#run_mlr head -n 4 then put -q 'emit > "'$emit9'/out.".$a.$b, $*' $indir/abixy
#run_cat $emit9/out.ekspan
#run_cat $emit9/out.ekswye
#run_cat $emit9/out.panpan
#run_cat $emit9/out.wyewye
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit | "tr \[a-z\] \[A-Z\]", $*, "NR"' $indir/abixy
#
#touch $emit9/err1
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stdout, $*, "NR"' $indir/abixy 2> $emit9/err1
#run_cat $emit9/err1
#
#touch $emit9/err2
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stderr, $*, "NR"' $indir/abixy 2> $emit9/err2
#run_cat $emit9/err2
#
#
#emit10=$reloutdir/emit10
#mkdir -p $emit10
#run_mlr head -n 4 then put -q 'emit > "'$emit10'/out.".$a.$b, mapexcept($*, "a", "b")' $indir/abixy
#run_cat $emit10/out.ekspan
#run_cat $emit10/out.ekswye
#run_cat $emit10/out.panpan
#run_cat $emit10/out.wyewye
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit | "tr \[a-z\] \[A-Z\]", mapexcept($*, "a", "b"), "NR"' $indir/abixy
#
#touch $emit10/err1
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stdout, mapexcept($*, "a", "b"), "NR"' $indir/abixy 2> $emit10/err1
#run_cat $emit10/err1
#
#touch $emit10/err2
#run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stderr, mapexcept($*, "a", "b"), "NR"' $indir/abixy 2> $emit10/err2
#run_cat $emit10/err2

## ----------------------------------------------------------------
#announce USER-DEFINED FUNCTIONS AND SUBROUTINES
#
#run_mlr --opprint --from $indir/abixy put 'func f(u,v){return u+v} $o=f(NR*1000,$x)'
#
#mlr_expect_fail --opprint --from $indir/abixy put 'func f(x,y,z){$nnn=999; int n=10; return $y} $o=f($i,$x,$y)'
#
#run_mlr --opprint --from $indir/abixy put 'subr s(a,b) { $[a] = b } call s("W", 999)'
#
#run_mlr --opprint --from $indir/abixy put '
#  func f(x,y,z) {
#    return x + y + z
#  }
#  subr s(a,b) {
#      $[a] = b;
#      $DID = "YES";
#  }
#  $o = f($x, $y, $i);
#  call s("W", NR);
#'
#
#run_mlr --opprint --from $indir/abixy put '
#  func f(x,y,z) {
#    return x + y + z
#  }
#  subr s(a,b) {
#      $[a] = b;
#      return;
#      $DID = "YES";
#  }
#  $o = f($x, $y, $i);
#  call s("W", NR);
#'
#
#mlr_expect_fail --from $indir/abixy put '
#  func f(x,y,z) {
#    return x + y + z
#  }
#  subr s(a,b) {
#      $[a] = b;
#      return 1 # subr must not return value
#  }
#  $o = f($x, $y, $i);
#  call s("W", NR);
#'
#
#mlr_expect_fail --from $indir/abixy put '
#  func f(x,y,z) {
#    return # func must return value
#  }
#  subr s(a,b) {
#      $[a] = b;
#  }
#  $o = f($x, $y, $i);
#  call s("W", NR);
#'
#
## Test fencing: function f should not have access to boundvar k from the callsite.
#run_mlr --from $indir/abixy --opprint put 'func f(x) {return k} for (k,v in $*) {$o=f($x)}'
#run_mlr --from $indir/abixy --opprint put 'subr foo() {print "k is [".k."]"} for (k,v in $*) {call foo()}'
#
## Test overriding built-ins
#mlr_expect_fail --opprint --from $indir/abixy put 'func log(x) { return 0 } $o = log($x)'
#
#run_mlr --from $indir/abixy put 'subr log() { print "hello record  ". NR } call log()'
#
## Test variable-clear at scope exit; test read of unset locals.
#run_mlr --opprint --from $indir/abixy put '$o1 = a; int a=1000+NR; $o2 = a; a=2000+NR; $o3 = a'
#
## Test recursion
#run_mlr --opprint --from $indir/abixy put '
#    func f(n) {
#        if (is_numeric(n)) {
#            if (n > 0) {
#                return n * f(n-1)
#            } else {
#                return 1
#            }
#        }
#        # implicitly return absent
#    }
#    $o = f(NR)
#'
#
#run_mlr --opprint --from $indir/abixy head -n 5 then put '
#    subr s(n) {
#        print "n = " . n;
#        if (is_numeric(n)) {
#            if (n > 0) {
#                call s(n-1)
#            }
#        }
#    }
#    print "";
#    call s(NR)
#'
#
#run_mlr --from $indir/abixy --opprint put '
#  func f(n) {
#    return n+1;
#  }
#  $o1 = f(NR);
#  $o2 = f(f(NR));
#  $o3 = f(f(f(NR)));
#  $o4 = f(f(f(f(NR))));
#  $o5 = f(f(f(f(f(NR)))));
#  $o6 = f(f(f(f(f(f(NR))))));
#'
#
#run_mlr --from $indir/abixy --opprint put '
#  func f(n) {
#      if (n < 2) {
#          return 1
#      } else {
#          return f(n-1) + f(n-2)
#      }
#  }
#  $o = f(NR)
#'
#
#run_mlr --from $indir/abixy --opprint put '
#  func f(n) {
#    if (is_present(@fcache[n])) {
#      return @fcache[n]
#    } else {
#      num rv = 1;
#      if (n >= 2) {
#        rv = f(n-1) + f(n-2)
#      }
#      @fcache[n] = rv;
#      return rv
#    }
#  }
#  $o = f(NR)
#'
#
## No nesting of top-levels
#mlr_expect_fail --from $indir/abixy --opprint put 'func f(x) { begin {} }'
#mlr_expect_fail --from $indir/abixy --opprint put 'func f(x) { end {} }'
#mlr_expect_fail --from $indir/abixy --opprint put 'subr s(x) { begin {} }'
#mlr_expect_fail --from $indir/abixy --opprint put 'subr s(x) { end {} }'
#
#mlr_expect_fail --from $indir/abixy --opprint put 'func f(x) { func g(y) {} }'
#mlr_expect_fail --from $indir/abixy --opprint put 'func f(x) { subr t(y) {} }'
#mlr_expect_fail --from $indir/abixy --opprint put 'subr s(x) { func g(y) {} }'
#mlr_expect_fail --from $indir/abixy --opprint put 'subr s(x) { subr t(y) {} }'
#
#mlr_expect_fail --from $indir/abixy --opprint filter 'func f(x) { begin {} }; true'
#mlr_expect_fail --from $indir/abixy --opprint filter 'func f(x) { end {} }; true'
#mlr_expect_fail --from $indir/abixy --opprint filter 'subr s(x) { begin {} }; true'
#mlr_expect_fail --from $indir/abixy --opprint filter 'subr s(x) { end {} }; true'
#
#mlr_expect_fail --from $indir/abixy --opprint filter 'func f(x) { func g(y) {} }; true'
#mlr_expect_fail --from $indir/abixy --opprint filter 'func f(x) { subr t(y) {} }; true'
#mlr_expect_fail --from $indir/abixy --opprint filter 'subr s(x) { func g(y) {} }; true'
#mlr_expect_fail --from $indir/abixy --opprint filter 'subr s(x) { subr t(y) {} }; true'
#
## Disallow redefines
#mlr_expect_fail --from $indir/abixy --opprint put 'func log(x) { return $x + 1 }'
#mlr_expect_fail --from $indir/abixy --opprint put 'func f(x) { return $x + 1 } func f(x) { return $x + 1}'
#mlr_expect_fail --from $indir/abixy --opprint put 'subr s() { } subr s() { }'
#mlr_expect_fail --from $indir/abixy --opprint put 'subr s() { } subr s(x) { }'
#run_mlr --from $indir/abixy --opprint put 'subr log(text) { print "TEXT IS ".text } call log("NR is ".NR)'
#
## print/dump from subr/func;  no tee/emit from func
#run_mlr --from $indir/abixy --opprint put 'subr log(text) { print "TEXT IS ".text } call log("NR is ".NR)'
#run_mlr --from $indir/abixy --opprint put 'func f(text) { print "TEXT IS ".text; return text.text } $o = f($a)'
#run_mlr --from $indir/abixy put 'begin{@x=1} func f(x) { dump; print "hello"                 } $o=f($i)'
#mlr_expect_fail --from $indir/abixy put 'begin{@x=1} func f(x) { dump; print "hello"; tee  > "x", $* } $o=f($i)'
#mlr_expect_fail --from $indir/abixy put 'begin{@x=1} func f(x) { dump; print "hello"; emit > "x", @* } $o=f($i)' 
#
## not use all args (for valgrind)
#run_mlr --from $indir/abixy put 'func f(x,y) { return 2*y } $o = f($x,$y) '
#
## general programming-language stuff
#run_mlr -n put -q -f $indir/sieve.mlr
#run_mlr -n put -q -f $indir/mand.mlr -e 'begin {@verbose = true}'
#
## scoping within distinct begin/end blocks
#run_mlr --from $indir/abixy put -v '
#    func f(x) {
#        return x**2
#    }
#    func g(y) {
#        return y+1
#    }
#    subr s(a,b,c) {
#        print a.b.c
#    }
#    begin {
#        @a = 0;
#        var ell = 1;
#        print "local1 = ".ell;
#    }
#    end {
#        emit @a;
#        var emm = 2;
#        print "local2 = ".emm;
#    }
#    @a += 1;
#    begin {
#        @b = 0;
#        @c = 0;
#        print "local3 = ".ell;
#    }
#    @b += 2;
#    @c += 3;
#    end {
#        emit @b;
#        emit @c;
#        print "local4 = ".emm;
#    }
#'

## ----------------------------------------------------------------
#announce MAPVARS IN SCALAR FUNCTION-CALL CONTEXTS
#
#mlr_expect_fail --from $indir/abixy put '$z=strlen($*)'
#mlr_expect_fail --from $indir/abixy put '$z=strlen({})'
#run_mlr --from $indir/abixy put 'a={}; $z=strlen(a)'

## ----------------------------------------------------------------
#announce MAPVAR EMIT
#
#run_mlr -n put 'end {
#  @a[2][3] = 4;
#  b[2][3] = 8;
#  emit  (@a, b, {2:{3:12}});
#  emitp (@a, b, {2:{3:12}});
#  emit {};
#  emit  (@a, b, {2:{3:12}}), "t";
#  emitp (@a, b, {2:{3:12}}), "t";
#  emit {};
#  emit  (@a, b, {2:{3:12}}), "t", "u";
#  emitp (@a, b, {2:{3:12}}), "t", "u";
#}'
#
#run_mlr -n put 'end {
#  @a[2][3] = 4;
#  b[2][3] = 8;
#  emitp (@a, b, {2:{3:12}});
#  emit  (@a, b, {2:{3:12}});
#  emit {};
#  emitp (@a, b, {2:{3:12}}), "t";
#  emit  (@a, b, {2:{3:12}}), "t";
#  emit {};
#  emitp (@a, b, {2:{3:12}}), "t", "u";
#  emit  (@a, b, {2:{3:12}}), "t", "u";
#}'

## ----------------------------------------------------------------
#announce MAPVARS/UDFs/SUBROUTINES
#
#run_mlr --from $indir/abixy put '
#  func f(m) {
#    dump m;
#    sum = 0;
#    for (k, v in m) {
#      sum += k
#    }
#    return sum
#  }
#  @v[$i] = $a;
#  $y = f(@v)
#'
#
#run_mlr --from $indir/abixy put '
#  subr s(m) {
#    dump m;
#    sum = 0;
#    for (k, v in m) {
#      sum += k
#    }
#    @sum = sum;
#  }
#  @v[$i] = $a;
#  call s(@v);
#  $y = @sum;
#'
#
#run_mlr --from $indir/abixy-het put    'func f(x) {return {"a":x,"b":x**2}}; map o = f($x); $* = o'
#run_mlr --from $indir/abixy-het put -q 'func f(x) {return x**2}; var z = f($x); dump z'
#run_mlr --from $indir/abixy-het put -q 'func f(x) {map m = {NR:x};return m}; z = f($y); dump z'
#
#mlr_expect_fail --from $indir/abixy put '
#  func f(int x): map {
#    if (NR==2) {
#      return 2
#    } else {
#      return {}
#    }
#  }
#  $y=f($x)
#'
#
#run_mlr --from $indir/abixy put '
#  func f(int x): map {
#    if (NR==200) {
#      return 2
#    } else {
#      return {}
#    }
#  }
#  $y=f($i)
#'
#
#mlr_expect_fail --from $indir/abixy put '
#  func f(int x): map {
#    if (NR==200) {
#      return 2
#    } else {
#      return {}
#    }
#  }
#  $y=f($x)
#'
#
#run_mlr --from $indir/abixy put '
#  func f(int x): var {
#    if (NR==2) {
#      return 2
#    } else {
#      return {}
#    }
#  }
#  $y=f($i)
#'
#
#mlr_expect_fail --from $indir/abixy put '
#  func f(int x): var {
#    if (NR==2) {
#      return 2
#    } else {
#      return {}
#    }
#  }
#  $y=f($x)
#'
#
#mlr_expect_fail --from $indir/abixy put '
#  func f(x): int {
#    # fall-through return value is absent-null
#  }
#  $y=f($x)
#'
#
#mlr_expect_fail --from $indir/abixy put '
#  int a = 1;
#  var b = a[2]; # cannot index localvar declared non-map
#'
#
## This one is intended to particularly look at freeing, e.g.  with './reg_test/run --valgrind'.
#run_mlr --oxtab --from $indir/abixy-het put '
# $* = mapdiff(
#   mapsum($*, {"a": "newval"}),
#   {"b": "nonesuch"},
# )
#'

## ----------------------------------------------------------------
#announce SPACE-PADDING
#
#run_mlr --idkvp    --odkvp --ifs space --repifs cat $indir/space-pad.dkvp
#run_mlr --inidx    --odkvp --ifs space --repifs cat $indir/space-pad.nidx
#run_mlr --icsvlite --odkvp --ifs space --repifs cat $indir/space-pad.pprint

## ----------------------------------------------------------------
#announce DOUBLE PS
#
#run_mlr --opprint cat $indir/double-ps.dkvp

## ----------------------------------------------------------------
#announce MISSING FINAL LF
#
#run_mlr --csvlite cat $indir/truncated.csv
#run_mlr --dkvp    cat $indir/truncated.dkvp
#run_mlr --nidx    cat $indir/truncated.nidx
#run_mlr --pprint  cat $indir/truncated.pprint
#run_mlr --xtab    cat $indir/truncated.xtab-crlf

## ----------------------------------------------------------------
#announce UTF-8 alignment
#
#run_mlr --icsvlite --opprint cat $indir/utf8-1.csv
#run_mlr --icsvlite --opprint cat $indir/utf8-2.csv
#run_mlr --icsvlite --oxtab   cat $indir/utf8-1.csv
#run_mlr --icsvlite --oxtab   cat $indir/utf8-2.csv
#
#run_mlr --inidx --ifs space --opprint         cat $indir/utf8-align.nidx
#run_mlr --inidx --ifs space --opprint --right cat $indir/utf8-align.nidx
#run_mlr --oxtab cat $indir/utf8-align.dkvp
#
#run_mlr --inidx --ifs space --oxtab --xvright cat $indir/utf8-align.nidx

## ----------------------------------------------------------------
#announce UTF-8 BOM
#
#run_mlr --icsv --opprint cat   $indir/bom.csv
#run_mlr --icsv --opprint cat < $indir/bom.csv
#run_mlr --icsv --opprint cat   $indir/bom-dquote-header.csv
#run_mlr --icsv --opprint cat < $indir/bom-dquote-header.csv

## ----------------------------------------------------------------
#announce UTF-8 UPPERCASE/LOWERCASE
#
#run_mlr --icsvlite --opprint put '$langue = toupper($langue)' $indir/utf8-1.csv
#run_mlr --icsvlite --opprint put '$nom    = toupper($nom)'    $indir/utf8-1.csv
#run_mlr --icsvlite --opprint put '$jour   = toupper($jour)'   $indir/utf8-1.csv
#
#run_mlr --icsvlite --opprint put '$langue = capitalize($langue)' $indir/utf8-1.csv
#run_mlr --icsvlite --opprint put '$nom    = capitalize($nom)'    $indir/utf8-1.csv
#run_mlr --icsvlite --opprint put '$jour   = capitalize($jour)'   $indir/utf8-1.csv

## ----------------------------------------------------------------
#announce RAGGED NON-RFC CSV
#
#run_mlr --icsv     --oxtab --ragged cat $indir/ragged.csv
#run_mlr --icsvlite --oxtab --ragged cat $indir/ragged.csv

## ----------------------------------------------------------------
#announce CSV/RS ENVIRONMENT DEFAULTS
#
#run_mlr --csv cut -f a $indir/rfc-csv/simple.csv-crlf
#run_mlr --csv --rs crlf cut -f a $indir/rfc-csv/simple.csv-crlf
#mlr_expect_fail --csv --rs lf cut -f a $indir/rfc-csv/simple.csv-crlf

## ----------------------------------------------------------------
#announce MULTI-CHARACTER IRS/IFS/IPS FOR DKVP
#
#run_mlr --oxtab --idkvp --irs lf   --ifs ,  --ips =  cut -o -f x,a,i $indir/multi-sep.dkvp-crlf
#run_mlr --oxtab --idkvp --irs lf   --ifs /, --ips =: cut -o -f x,a,i $indir/multi-sep.dkvp-crlf
#run_mlr --oxtab --idkvp --irs crlf --ifs ,  --ips =  cut -o -f x,a,i $indir/multi-sep.dkvp-crlf
#run_mlr --oxtab --idkvp --irs crlf --ifs /, --ips =: cut -o -f x,a,i $indir/multi-sep.dkvp-crlf

## ----------------------------------------------------------------
#announce MULTI-CHARACTER IRS/IFS FOR NIDX
#
#run_mlr --oxtab --inidx --irs lf   --ifs ,  cut -o -f 4,1,3 $indir/multi-sep.dkvp-crlf
#run_mlr --oxtab --inidx --irs lf   --ifs /, cut -o -f 4,1,3 $indir/multi-sep.dkvp-crlf
#run_mlr --oxtab --inidx --irs crlf --ifs ,  cut -o -f 4,1,3 $indir/multi-sep.dkvp-crlf
#run_mlr --oxtab --inidx --irs crlf --ifs /, cut -o -f 4,1,3 $indir/multi-sep.dkvp-crlf
#
## ----------------------------------------------------------------
#announce MULTI-CHARACTER IRS/IFS FOR CSVLITE
#
#run_mlr --oxtab --icsvlite --irs lf   --ifs ,  cut -o -f x/,a/,i/ $indir/multi-sep.csv-crlf
#run_mlr --oxtab --icsvlite --irs lf   --ifs /, cut -o -f x,a,i    $indir/multi-sep.csv-crlf
#run_mlr --oxtab --icsvlite --irs crlf --ifs ,  cut -o -f x/,a/,i/ $indir/multi-sep.csv-crlf
#run_mlr --oxtab --icsvlite --irs crlf --ifs /, cut -o -f x,a,i    $indir/multi-sep.csv-crlf
#
## ----------------------------------------------------------------
#announce MULTI-CHARACTER SEPARATORS FOR XTAB
#
#run_mlr --xtab --ifs crlf --ofs Z cut -x -f b $indir/truncated.xtab-crlf
#run_mlr --xtab --ips . --ops @ cut -x -f b $indir/dots.xtab
#run_mlr --xtab --ips ": " --ops '@@@@' put '$sum=int($a+$b)' $indir/multi-ips.dkvp
#
## ----------------------------------------------------------------
#announce EMBEDDED IPS FOR XTAB
#
#run_mlr --xtab cat $indir/embedded-ips.xtab
#
## ----------------------------------------------------------------
#announce MULTI-CHARACTER IRS FOR PPRINT
#
#run_mlr --pprint --irs crlf --ifs / --ofs @ cut -x -f b $indir/dots.pprint-crlf

