
## ----------------------------------------------------------------
#announce USER-DEFINED FUNCTIONS AND SUBROUTINES
#
#run_mlr --opprint --from $indir/abixy put 'func f(u,v){return u+v} $o=f(NR*1000,$x)'
#
#mlr_expect_fail --opprint --from $indir/abixy put 'func f(x,y,z){$nnn=999; int n=10; return $y} $o=f($i,$x,$y)'
#
#run_mlr --opprint --from $indir/abixy put 'subr s(a,b) { $[a] = b } call s("W", 999)'
#
#run_mlr --opprint --from $indir/abixy put '
#  func f(x,y,z) {
#    return x + y + z
#  }
#  subr s(a,b) {
#      $[a] = b;
#      $DID = "YES";
#  }
#  $o = f($x, $y, $i);
#  call s("W", NR);
#'
#
#run_mlr --opprint --from $indir/abixy put '
#  func f(x,y,z) {
#    return x + y + z
#  }
#  subr s(a,b) {
#      $[a] = b;
#      return;
#      $DID = "YES";
#  }
#  $o = f($x, $y, $i);
#  call s("W", NR);
#'
#
#mlr_expect_fail --from $indir/abixy put '
#  func f(x,y,z) {
#    return x + y + z
#  }
#  subr s(a,b) {
#      $[a] = b;
#      return 1 # subr must not return value
#  }
#  $o = f($x, $y, $i);
#  call s("W", NR);
#'
#
#mlr_expect_fail --from $indir/abixy put '
#  func f(x,y,z) {
#    return # func must return value
#  }
#  subr s(a,b) {
#      $[a] = b;
#  }
#  $o = f($x, $y, $i);
#  call s("W", NR);
#'
#
## Test fencing: function f should not have access to boundvar k from the callsite.
#run_mlr --from $indir/abixy --opprint put 'func f(x) {return k} for (k,v in $*) {$o=f($x)}'
#run_mlr --from $indir/abixy --opprint put 'subr foo() {print "k is [".k."]"} for (k,v in $*) {call foo()}'
#
## Test overriding built-ins
#mlr_expect_fail --opprint --from $indir/abixy put 'func log(x) { return 0 } $o = log($x)'
#
#run_mlr --from $indir/abixy put 'subr log() { print "hello record  ". NR } call log()'
#
## Test variable-clear at scope exit; test read of unset locals.
#run_mlr --opprint --from $indir/abixy put '$o1 = a; int a=1000+NR; $o2 = a; a=2000+NR; $o3 = a'
#
## Test recursion
#run_mlr --opprint --from $indir/abixy put '
#    func f(n) {
#        if (is_numeric(n)) {
#            if (n > 0) {
#                return n * f(n-1)
#            } else {
#                return 1
#            }
#        }
#        # implicitly return absent
#    }
#    $o = f(NR)
#'
#
#run_mlr --opprint --from $indir/abixy head -n 5 then put '
#    subr s(n) {
#        print "n = " . n;
#        if (is_numeric(n)) {
#            if (n > 0) {
#                call s(n-1)
#            }
#        }
#    }
#    print "";
#    call s(NR)
#'
#
#run_mlr --from $indir/abixy --opprint put '
#  func f(n) {
#    return n+1;
#  }
#  $o1 = f(NR);
#  $o2 = f(f(NR));
#  $o3 = f(f(f(NR)));
#  $o4 = f(f(f(f(NR))));
#  $o5 = f(f(f(f(f(NR)))));
#  $o6 = f(f(f(f(f(f(NR))))));
#'
#
#run_mlr --from $indir/abixy --opprint put '
#  func f(n) {
#      if (n < 2) {
#          return 1
#      } else {
#          return f(n-1) + f(n-2)
#      }
#  }
#  $o = f(NR)
#'
#
#run_mlr --from $indir/abixy --opprint put '
#  func f(n) {
#    if (is_present(@fcache[n])) {
#      return @fcache[n]
#    } else {
#      num rv = 1;
#      if (n >= 2) {
#        rv = f(n-1) + f(n-2)
#      }
#      @fcache[n] = rv;
#      return rv
#    }
#  }
#  $o = f(NR)
#'
#
## No nesting of top-levels
#mlr_expect_fail --from $indir/abixy --opprint put 'func f(x) { begin {} }'
#mlr_expect_fail --from $indir/abixy --opprint put 'func f(x) { end {} }'
#mlr_expect_fail --from $indir/abixy --opprint put 'subr s(x) { begin {} }'
#mlr_expect_fail --from $indir/abixy --opprint put 'subr s(x) { end {} }'
#
#mlr_expect_fail --from $indir/abixy --opprint put 'func f(x) { func g(y) {} }'
#mlr_expect_fail --from $indir/abixy --opprint put 'func f(x) { subr t(y) {} }'
#mlr_expect_fail --from $indir/abixy --opprint put 'subr s(x) { func g(y) {} }'
#mlr_expect_fail --from $indir/abixy --opprint put 'subr s(x) { subr t(y) {} }'
#
#mlr_expect_fail --from $indir/abixy --opprint filter 'func f(x) { begin {} }; true'
#mlr_expect_fail --from $indir/abixy --opprint filter 'func f(x) { end {} }; true'
#mlr_expect_fail --from $indir/abixy --opprint filter 'subr s(x) { begin {} }; true'
#mlr_expect_fail --from $indir/abixy --opprint filter 'subr s(x) { end {} }; true'
#
#mlr_expect_fail --from $indir/abixy --opprint filter 'func f(x) { func g(y) {} }; true'
#mlr_expect_fail --from $indir/abixy --opprint filter 'func f(x) { subr t(y) {} }; true'
#mlr_expect_fail --from $indir/abixy --opprint filter 'subr s(x) { func g(y) {} }; true'
#mlr_expect_fail --from $indir/abixy --opprint filter 'subr s(x) { subr t(y) {} }; true'
#
## Disallow redefines
#mlr_expect_fail --from $indir/abixy --opprint put 'func log(x) { return $x + 1 }'
#mlr_expect_fail --from $indir/abixy --opprint put 'func f(x) { return $x + 1 } func f(x) { return $x + 1}'
#mlr_expect_fail --from $indir/abixy --opprint put 'subr s() { } subr s() { }'
#mlr_expect_fail --from $indir/abixy --opprint put 'subr s() { } subr s(x) { }'
#run_mlr --from $indir/abixy --opprint put 'subr log(text) { print "TEXT IS ".text } call log("NR is ".NR)'
#
## print/dump from subr/func;  no tee/emit from func
#run_mlr --from $indir/abixy --opprint put 'subr log(text) { print "TEXT IS ".text } call log("NR is ".NR)'
#run_mlr --from $indir/abixy --opprint put 'func f(text) { print "TEXT IS ".text; return text.text } $o = f($a)'
#run_mlr --from $indir/abixy put 'begin{@x=1} func f(x) { dump; print "hello"                 } $o=f($i)'
#mlr_expect_fail --from $indir/abixy put 'begin{@x=1} func f(x) { dump; print "hello"; tee  > "x", $* } $o=f($i)'
#mlr_expect_fail --from $indir/abixy put 'begin{@x=1} func f(x) { dump; print "hello"; emit > "x", @* } $o=f($i)' 
#
## not use all args (for valgrind)
#run_mlr --from $indir/abixy put 'func f(x,y) { return 2*y } $o = f($x,$y) '
#
## general programming-language stuff
#run_mlr -n put -q -f $indir/sieve.mlr
#run_mlr -n put -q -f $indir/mand.mlr -e 'begin {@verbose = true}'
#
## scoping within distinct begin/end blocks
#run_mlr --from $indir/abixy put -v '
#    func f(x) {
#        return x**2
#    }
#    func g(y) {
#        return y+1
#    }
#    subr s(a,b,c) {
#        print a.b.c
#    }
#    begin {
#        @a = 0;
#        var ell = 1;
#        print "local1 = ".ell;
#    }
#    end {
#        emit @a;
#        var emm = 2;
#        print "local2 = ".emm;
#    }
#    @a += 1;
#    begin {
#        @b = 0;
#        @c = 0;
#        print "local3 = ".ell;
#    }
#    @b += 2;
#    @c += 3;
#    end {
#        emit @b;
#        emit @c;
#        print "local4 = ".emm;
#    }
#'


## ----------------------------------------------------------------
#announce MULTI-CHARACTER IRS/IFS FOR NIDX
#
#run_mlr --oxtab --inidx --irs lf   --ifs ,  cut -o -f 4,1,3 $indir/multi-sep.dkvp-crlf
#run_mlr --oxtab --inidx --irs lf   --ifs /, cut -o -f 4,1,3 $indir/multi-sep.dkvp-crlf
#run_mlr --oxtab --inidx --irs crlf --ifs ,  cut -o -f 4,1,3 $indir/multi-sep.dkvp-crlf
#run_mlr --oxtab --inidx --irs crlf --ifs /, cut -o -f 4,1,3 $indir/multi-sep.dkvp-crlf
#
## ----------------------------------------------------------------
#announce MULTI-CHARACTER IRS/IFS FOR CSVLITE
#
#run_mlr --oxtab --icsvlite --irs lf   --ifs ,  cut -o -f x/,a/,i/ $indir/multi-sep.csv-crlf
#run_mlr --oxtab --icsvlite --irs lf   --ifs /, cut -o -f x,a,i    $indir/multi-sep.csv-crlf
#run_mlr --oxtab --icsvlite --irs crlf --ifs ,  cut -o -f x/,a/,i/ $indir/multi-sep.csv-crlf
#run_mlr --oxtab --icsvlite --irs crlf --ifs /, cut -o -f x,a,i    $indir/multi-sep.csv-crlf
#
## ----------------------------------------------------------------
#announce MULTI-CHARACTER SEPARATORS FOR XTAB
#
#run_mlr --xtab --ifs crlf --ofs Z cut -x -f b $indir/truncated.xtab-crlf
#run_mlr --xtab --ips . --ops @ cut -x -f b $indir/dots.xtab
#run_mlr --xtab --ips ": " --ops '@@@@' put '$sum=int($a+$b)' $indir/multi-ips.dkvp
#
## ----------------------------------------------------------------
#announce EMBEDDED IPS FOR XTAB
#
#run_mlr --xtab cat $indir/embedded-ips.xtab
#
## ----------------------------------------------------------------
#announce MULTI-CHARACTER IRS FOR PPRINT
#
#run_mlr --pprint --irs crlf --ifs / --ofs @ cut -x -f b $indir/dots.pprint-crlf


## ----------------------------------------------------------------
#announce NON-INTERPOLATED AND INTERPOLATED PERCENTILES
#
#for k in 1 2 3 4 5 6 7 8 9 10 11; do
#run_mlr --from $indir/x0to10.dat --oxtab head -n $k then stats1 -f x -a p00,p01,p02,p03,p04,p05,p06,p07,p08,p09,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20,p21,p22,p23,p24,p25,p26,p27,p28,p29,p30,p31,p32,p33,p34,p35,p36,p37,p38,p39,p40,p41,p42,p43,p44,p45,p46,p47,p48,p49,p50,p51,p52,p53,p54,p55,p56,p57,p58,p59,p60,p61,p62,p63,p64,p65,p66,p67,p68,p69,p70,p71,p72,p73,p74,p75,p76,p77,p78,p79,p80,p81,p82,p83,p84,p85,p86,p87,p88,p89,p90,p91,p92,p93,p94,p95,p96,p97,p98,p99,p100
#done
#
#for k in 1 2 3 4 5 6 7 8 9 10 11; do
#run_mlr --from $indir/x0to10.dat --oxtab head -n $k then stats1 -i -f x -a p00,p01,p02,p03,p04,p05,p06,p07,p08,p09,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20,p21,p22,p23,p24,p25,p26,p27,p28,p29,p30,p31,p32,p33,p34,p35,p36,p37,p38,p39,p40,p41,p42,p43,p44,p45,p46,p47,p48,p49,p50,p51,p52,p53,p54,p55,p56,p57,p58,p59,p60,p61,p62,p63,p64,p65,p66,p67,p68,p69,p70,p71,p72,p73,p74,p75,p76,p77,p78,p79,p80,p81,p82,p83,p84,p85,p86,p87,p88,p89,p90,p91,p92,p93,p94,p95,p96,p97,p98,p99,p100
#done


## ----------------------------------------------------------------
#announce MAPVAR EMIT
#
#run_mlr -n put 'end {
#  @a[2][3] = 4;
#  b[2][3] = 8;
#  emit  (@a, b, {2:{3:12}});
#  emitp (@a, b, {2:{3:12}});
#  emit {};
#  emit  (@a, b, {2:{3:12}}), "t";
#  emitp (@a, b, {2:{3:12}}), "t";
#  emit {};
#  emit  (@a, b, {2:{3:12}}), "t", "u";
#  emitp (@a, b, {2:{3:12}}), "t", "u";
#}'
#
#run_mlr -n put 'end {
#  @a[2][3] = 4;
#  b[2][3] = 8;
#  emitp (@a, b, {2:{3:12}});
#  emit  (@a, b, {2:{3:12}});
#  emit {};
#  emitp (@a, b, {2:{3:12}}), "t";
#  emit  (@a, b, {2:{3:12}}), "t";
#  emit {};
#  emitp (@a, b, {2:{3:12}}), "t", "u";
#  emit  (@a, b, {2:{3:12}}), "t", "u";
#}'


## ----------------------------------------------------------------
#announce UTF-8 alignment
#
#run_mlr --icsvlite --opprint cat $indir/utf8-1.csv
#run_mlr --icsvlite --opprint cat $indir/utf8-2.csv
#run_mlr --icsvlite --oxtab   cat $indir/utf8-1.csv
#run_mlr --icsvlite --oxtab   cat $indir/utf8-2.csv
#
#run_mlr --inidx --ifs space --opprint         cat $indir/utf8-align.nidx
#run_mlr --inidx --ifs space --opprint --right cat $indir/utf8-align.nidx
#run_mlr --oxtab cat $indir/utf8-align.dkvp
#
#run_mlr --inidx --ifs space --oxtab --xvright cat $indir/utf8-align.nidx


## ----------------------------------------------------------------
#announce MULTI-CHARACTER IRS/IFS/IPS FOR DKVP
#
#run_mlr --oxtab --idkvp --irs lf   --ifs ,  --ips =  cut -o -f x,a,i $indir/multi-sep.dkvp-crlf
#run_mlr --oxtab --idkvp --irs lf   --ifs /, --ips =: cut -o -f x,a,i $indir/multi-sep.dkvp-crlf
#run_mlr --oxtab --idkvp --irs crlf --ifs ,  --ips =  cut -o -f x,a,i $indir/multi-sep.dkvp-crlf
#run_mlr --oxtab --idkvp --irs crlf --ifs /, --ips =: cut -o -f x,a,i $indir/multi-sep.dkvp-crlf


## Test early-out for unkeyed head
#run_mlr head -n 2 then put 'end{ print "Final NR is ".NR}' $indir/abixy-wide
#run_mlr head -n 2 -g a then put 'end{ print "Final NR is ".NR}' $indir/abixy-wide
#run_mlr cat then head -n 2 then put 'end{ print "Final NR is ".NR}' $indir/abixy-wide
#run_mlr tac then head -n 2 then put 'end{ print "Final NR is ".NR}' $indir/abixy-wide
#run_mlr head -n 2 then put 'end{ print "Final NR is ".NR}' $indir/abixy-wide $indir/abixy-wide $indir/abixy-wide


## ----------------------------------------------------------------
#announce STATS1/STEP INT/FLOAT
#
#run_mlr --opprint step      -a rsum,delta,counter  -f x,y,z $indir/int-float.dkvp
#run_mlr --opprint step   -F -a rsum,delta,counter  -f x,y,z $indir/int-float.dkvp
#run_mlr --oxtab   stats1    -a min,max,sum,count   -f x,y,z $indir/int-float.dkvp
#run_mlr --oxtab   stats1 -F -a min,max,sum,count   -f x,y,z $indir/int-float.dkvp


## ----------------------------------------------------------------
#announce DSL TYPED OVERLAY
#
#run_mlr put '$y = string($x); $z=$y.$y' $indir/int-float.dkvp
#run_mlr put '$z=string($x).string($x)' $indir/int-float.dkvp
#run_mlr put '$y = string($x)' then put '$z=$y.$y' $indir/int-float.dkvp
#run_mlr put '$a="hello"' then put '$b=$a." world";$z=$x+$y;$c=$b;$a=sub($b,"hello","farewell")' $indir/int-float.dkvp


## ----------------------------------------------------------------
#announce MISSING FINAL LF
#
#run_mlr --csvlite cat $indir/truncated.csv
#run_mlr --dkvp    cat $indir/truncated.dkvp
#run_mlr --nidx    cat $indir/truncated.nidx
#run_mlr --pprint  cat $indir/truncated.pprint
#run_mlr --xtab    cat $indir/truncated.xtab-crlf


## ----------------------------------------------------------------
#announce SPACE-PADDING
#
#run_mlr --idkvp    --odkvp --ifs space --repifs cat $indir/space-pad.dkvp
#run_mlr --inidx    --odkvp --ifs space --repifs cat $indir/space-pad.nidx
#run_mlr --icsvlite --odkvp --ifs space --repifs cat $indir/space-pad.pprint


## ----------------------------------------------------------------
#announce CSV/RS ENVIRONMENT DEFAULTS
#
#run_mlr --csv cut -f a $indir/rfc-csv/simple.csv-crlf
#run_mlr --csv --rs crlf cut -f a $indir/rfc-csv/simple.csv-crlf
#mlr_expect_fail --csv --rs lf cut -f a $indir/rfc-csv/simple.csv-crlf


## ----------------------------------------------------------------
#announce MAPVARS IN SCALAR FUNCTION-CALL CONTEXTS
#
#mlr_expect_fail --from $indir/abixy put '$z=strlen($*)'
#mlr_expect_fail --from $indir/abixy put '$z=strlen({})'
#run_mlr --from $indir/abixy put 'a={}; $z=strlen(a)'


## ----------------------------------------------------------------
#announce MAP-VARIANT DUMPS
#
#run_mlr --from $indir/abixy-het put -q 'dump {"a"."b":$a.$b}'
#run_mlr --from $indir/abixy-het put -q 'func f(a, b) { return {"a"."b":a.b} } dump f($a, $b)'


## ----------------------------------------------------------------
#announce UTF-8 STRLEN
#
#run_mlr --inidx --ifs comma --oxtab put '$s1=strlen($1);$s2=strlen($2);$s3=strlen($3);$s4=strlen($4)' $indir/utf8-align.dkvp


## ----------------------------------------------------------------
#announce RAGGED NON-RFC CSV
#
#run_mlr --icsv     --oxtab --ragged cat $indir/ragged.csv
#run_mlr --icsvlite --oxtab --ragged cat $indir/ragged.csv


## ----------------------------------------------------------------
#announce DOUBLE PS
#
#run_mlr --opprint cat $indir/double-ps.dkvp

