// ================================================================
// Constructors
// ================================================================

package mlrval

import (
	//"errors"

	"github.com/johnkerl/miller/internal/pkg/lib"
)

// TODO: comment JIT context. Some things we already know are typed -- DSL
// things, or JSON contents.  Others are deferred, e.g. items from any file
// format except JSON.
// TODO: comment re inferBool.
func FromDeferredType(input string) *Mlrval {
	return &Mlrval{
		mvtype:        MT_PENDING,
		printrep:      input,
		printrepValid: true,
	}
}

// TODO: comment non-JIT context like mlr put -s.
// TODO: comment re inferBool.
func FromInferredType(input string) *Mlrval {
	mv := &Mlrval{
		mvtype:        MT_PENDING,
		printrep:      input,
		printrepValid: true,
	}
	// TODO: comment re inferBool arg
    packageLevelInferrer(mv, mv.printrep, true)
	return mv
}

func FromString(input string) *Mlrval {
	if input == "" {
		return MLRVAL_VOID
	}
	return &Mlrval{
		mvtype:        MT_STRING,
		printrep:      input,
		printrepValid: true,
	}
}

func (mv *Mlrval) SetFromString(input string) *Mlrval {
	mv.printrep = input
	mv.printrepValid = true
	if input == "" {
		mv.mvtype = MT_VOID
	} else {
		mv.mvtype = MT_STRING
	}
	return mv
}

func (mv *Mlrval) SetFromVoid() *Mlrval {
	mv.printrep = ""
	mv.printrepValid = true
	mv.mvtype = MT_VOID
	return mv
}

func FromInt(input int) *Mlrval {
	return &Mlrval{
		mvtype:        MT_INT,
		printrepValid: false,
		intval:        input,
	}
}

// TODO: comment
func (mv *Mlrval) SetFromPrevalidatedIntString(input string, intval int) *Mlrval {
	mv.printrep = input
	mv.printrepValid = true
	mv.intval = intval
	mv.mvtype = MT_INT
	return mv
}

func FromFloat(input float64) *Mlrval {
	return &Mlrval{
		mvtype:        MT_FLOAT,
		printrepValid: false,
		floatval:      input,
	}
}

// TODO: comment
func (mv *Mlrval) SetFromPrevalidatedFloatString(input string, floatval float64) *Mlrval {
	mv.printrep = input
	mv.printrepValid = true
	mv.floatval = floatval
	mv.mvtype = MT_FLOAT
	return mv
}

func FromBool(input bool) *Mlrval {
	if input == true {
		return MLRVAL_TRUE
	} else {
		return MLRVAL_FALSE
	}
}

func FromBoolString(input string) *Mlrval {
	if input == "true" {
		return MLRVAL_TRUE
	} else if input == "false" {
		return MLRVAL_FALSE
	} else {
		lib.InternalCodingErrorIf(true)
		return nil // not reached
	}
}

// TODO: comment
func (mv *Mlrval) SetFromPrevalidatedBoolString(input string, boolval bool) *Mlrval {
	mv.printrep = input
	mv.printrepValid = true
	mv.boolval = boolval
	mv.mvtype = MT_BOOL
	return mv
}

// The user-defined function is of type 'interface{}' here to avoid what would
// otherwise be a package-dependency cycle between this package and
// github.com/johnkerl/miller/internal/pkg/dsl/cst.
//
// Nominally the name argument is the user-specified name if `func f(a, b) {
// ... }`, or some autogenerated UUID like `fl0052` if `func (a, b) { ... }`.

func FromFunction(funcval interface{}, name string) *Mlrval {
	return &Mlrval{
		mvtype:        MT_FUNC,
		printrep:      name,
		printrepValid: true,
		funcval:       funcval,
	}
}

func FromArray(arrayval interface{}) *Mlrval {
	return &Mlrval{
		mvtype:        MT_ARRAY,
		printrep:      INVALID_PRINTREP,
		printrepValid: true,
		arrayval:      arrayval,
	}
}

func FromMap(mapval interface{}) *Mlrval {
	return &Mlrval{
		mvtype:        MT_MAP,
		printrep:      INVALID_PRINTREP,
		printrepValid: true,
		mapval:        mapval,
	}
}
