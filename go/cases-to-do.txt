
================================================================
BUG:

rrv ./reg-test/cases/case-c-dsl-for-srec-loops.sh
* mlr --from ./reg-test/input/abixy put -S -v 'for(k,v in $*) {$[v]=k}'
  Miller: record/map indices must be string or positional-int; got float

rrv ./reg-test/cases/case-c-dsl-forbind-typedecl.sh
rrv ./reg-test/cases/case-c-dsl-localvar-typedecl.sh
rrv ./reg-test/cases/case-c-dsl-local-map-variable-typedecl.sh
* str s = "a"; s = 3 doesn't trigger -- needs gate-retention ...

rrv ./reg-test/cases/case-c-dsl-null-empty-handling.sh
* "conditional expression did not evaluate to boolean" -- versus @nonesuch {} P/A in C ...

rrv ./reg-test/cases/case-c-dsl-triple-for-loops.sh
* Needs to do this:
  "Continuation statements are split into the final boolean, and the statements before (if any)."

================================================================
MULTIPLE ISSUES:

rrv ./reg-test/cases/case-c-dsl-functional-tests.sh
* bug mlr filter $nosuchfield>.3 ./reg-test/input/abixy
* ofmt
-> split up this big case-file

* typeof prints different things -- regularize ...

================================================================
LF/CRLF ETC.

rrv ./reg-test/cases/case-c-multi-character-ixs.sh
rrv ./reg-test/cases/case-c-implicit-header-csv-input.sh
rrv ./reg-test/cases/case-c-missing-final-lf.sh

================================================================
PUT -S / -F / -A

rrv -C1 ./reg-test/cases/case-c-dsl-type-inference.sh

rrv -C20 ./reg-test/cases/case-c-dsl-local-map-variable-write-read.sh
rrv -C20 ./reg-test/cases/case-c-dsl-local-map-variable-write-read.sh
* put -a

================================================================
ARRAY/MAP

rrv ./reg-test/cases/case-c-localvar-unsets.sh

rrv -C5 ./reg-test/cases/case-c-dsl-for-oosvar-loops.sh
rrv ./reg-test/cases/case-c-dsl-mapvar-assignments.sh

rrv ./reg-test/cases/case-c-dsl-split-join.sh
rrv -C5 ./reg-test/cases/case-c-dsl-asserting.sh
rrv -C1 ./reg-test/cases/case-c-dsl-length-depth-leafcount.sh
* int map keys

rrv -C1 ./reg-test/cases/case-c-dsl-mapvar-for-loops.sh
* int map keys

rrv ./reg-test/cases/case-c-dsl-haskey.sh
* haskey({3:4}, 3)

rrv ./reg-test/cases/case-c-dsl-extended-typeof.sh

rrv ./reg-test/cases/case-c-dsl-is-predicates.sh
* {1:2} is empty-map in Go; should step up (populate) or step down (error)

  func (this *Mlrval) MapPut(key *Mlrval, value *Mlrval) {
      if this.mvtype != MT_MAP {
          // TODO: need to be careful about semantics here.
          // Silent no-ops are not good UX ...
          return
      }
      if key.mvtype != MT_STRING {
          // TODO: need to be careful about semantics here.
          // Silent no-ops are not good UX ...
          return
      }
      this.mapval.PutCopy(&key.printrep, value)
  }

================================================================
SUBR

rrv -C1 ./reg-test/cases/case-c-dsl-context-specific-validation.sh
* subr and more ... also needs check for filter statement within filter commands

rrv ./reg-test/cases/case-c-dsl-user-defined-functions-and-subroutines.sh
rrv ./reg-test/cases/case-c-dsl-user-defined-subroutines.sh
rrv ./reg-test/cases/case-c-dsl-trailing-commas.sh
rrv ./reg-test/cases/case-c-dsl-argpass-typedecl.sh
rrv ./reg-test/cases/case-c-dsl-multipart-scripts.sh

================================================================
PARTIALLY IMPLEMENTED:

rrv ./reg-test/cases/case-c-clean-whitespace.sh
rrv ./reg-test/cases/case-c-cut.sh
rrv ./reg-test/cases/case-c-dsl-indirect-oosvar-assignments.sh
rrv ./reg-test/cases/case-c-dsl-scientific-notation.sh
rrv ./reg-test/cases/case-c-format-values.sh
rrv ./reg-test/cases/case-c-implicit-header-csv-input.sh
rrv ./reg-test/cases/case-c-localvar-unsets.sh
rrv ./reg-test/cases/case-c-rfc-csv.sh
rrv ./reg-test/cases/case-c-space-padding.sh
rrv ./reg-test/cases/case-c-utf8-alignment.sh

================================================================
PPRINT --BARRED --RIGHT

rrv ./reg-test/cases/case-c-barred-pprint.sh

================================================================
BACKWARD INCOMPATIBILITIES:

rrv ./reg-test/cases/case-c-dsl-context-specific-validation.sh
* mlr: filter expressions must end in a final boolean statement.
-> abandon this requirement? doc if so.

rrv ./reg-test/cases/case-c-label.sh
* handles old/new clashes differently from C impl :^/

rrv ./reg-test/cases/case-c-dsl-print.sh
rrv ./reg-test/cases/case-c-dsl-substr.sh

rrv -C20 ./reg-test/cases/case-c-dsl-user-defined-functions.sh
* array 1-up

================================================================
NEED EMITP/MULTI-EMIT

rrv ./reg-test/cases/case-c-dsl-absent-empty.sh
rrv ./reg-test/cases/case-c-dsl-break-continue.sh
rrv ./reg-test/cases/case-c-dsl-lashed-emitp-singles.sh
rrv ./reg-test/cases/case-c-dsl-mapvar-emit.sh
rrv ./reg-test/cases/case-c-dsl-oosvar-assignments.sh

rrv -C20 ./reg-test/cases/case-c-dsl-type-predicates.sh
* multi-emit

rrv ./reg-test/cases/case-c-dsl-functional-tests.sh
* print-with-redirect

================================================================
NOT IMPLEMENTED YET:

rrv ./reg-test/cases/case-c-format-conversion-keystroke-savers.sh
* needs --ipprint

rrv ./reg-test/cases/case-c-dsl-filter-pattern-action.sh
* regex

rrv -C1 ./reg-test/cases/case-c-dsl-filter-pattern-action.sh
* regexi

rrv ./reg-test/cases/case-c-het-pprint-input.sh
* new pprint reader not done yet

rrv ./reg-test/cases/case-c-dsl-oosvars.sh
* uses mlr step

rrv ./reg-test/cases/case-c-auxents.sh
rrv ./reg-test/cases/case-c-bar.sh
rrv ./reg-test/cases/case-c-compressed-input.sh
rrv ./reg-test/cases/case-c-count-distinct.sh
rrv ./reg-test/cases/case-c-csv-rs-environment-defaults.sh
rrv ./reg-test/cases/case-c-dsl-gmt-date-time-functions.sh
rrv ./reg-test/cases/case-c-dsl-local-date-time-functions.sh
rrv ./reg-test/cases/case-c-dsl-mapvars-udfs-subroutines.sh
rrv ./reg-test/cases/case-c-dsl-parameterized-emit.sh
rrv ./reg-test/cases/case-c-dsl-positional-indexing.sh
rrv ./reg-test/cases/case-c-dsl-prefixed-unprefixed-emit.sh
rrv ./reg-test/cases/case-c-dsl-redirects.sh
rrv ./reg-test/cases/case-c-dsl-regex-captures.sh
rrv ./reg-test/cases/case-c-dsl-regex-matching.sh
rrv ./reg-test/cases/case-c-dsl-stack-allocation.sh
rrv ./reg-test/cases/case-c-format-values.sh
rrv ./reg-test/cases/case-c-fraction.sh
rrv ./reg-test/cases/case-c-having-fields.sh
rrv ./reg-test/cases/case-c-head-early-out.sh
rrv ./reg-test/cases/case-c-histogram.sh
rrv ./reg-test/cases/case-c-in-place-processing.sh
rrv ./reg-test/cases/case-c-int-float-stats1-step1.sh
rrv ./reg-test/cases/case-c-join-mixed-format.sh
rrv ./reg-test/cases/case-c-join-prepipe.sh
rrv ./reg-test/cases/case-c-join.sh
rrv ./reg-test/cases/case-c-json-io.sh
rrv ./reg-test/cases/case-c-lf-crlf-and-autodetect.sh
rrv ./reg-test/cases/case-c-markdown-output.sh
rrv ./reg-test/cases/case-c-merge-fields.sh
rrv ./reg-test/cases/case-c-most-least-frequent.sh
rrv ./reg-test/cases/case-c-nest.sh
rrv ./reg-test/cases/case-c-null-field-input.sh
rrv ./reg-test/cases/case-c-number-formatting.sh
rrv ./reg-test/cases/case-c-rename-regex.sh
rrv ./reg-test/cases/case-c-repeat.sh
rrv ./reg-test/cases/case-c-reshape.sh
rrv ./reg-test/cases/case-c-seqgen.sh
rrv ./reg-test/cases/case-c-skip-pass-comments.sh
rrv ./reg-test/cases/case-c-stats1-percentile-interpolation.sh
rrv ./reg-test/cases/case-c-stats1-regexed-field-names.sh
rrv ./reg-test/cases/case-c-stats1.sh
rrv ./reg-test/cases/case-c-stats2.sh
rrv ./reg-test/cases/case-c-step.sh
rrv ./reg-test/cases/case-c-top.sh
rrv ./reg-test/cases/case-c-uniq.sh
rrv ./reg-test/cases/case-c-utf8-bom.sh

================================================================
Using mlr executable ./reg-test/../../go/mlr

----------------------------------------------------------------
BEGIN ./reg-test/cases/case-c-dsl-context-specific-validation.sh

mlr put -v begin{begin{@x=1}}
mlr put -v true{begin{@x=1}}
mlr put -v end{end{@x=1}}
mlr put -v true{end{@x=1}}
mlr put -v begin{$x=1}
mlr put -v begin{@x=$y}
mlr put -v end{$x=1}
mlr put -v end{@x=$y}
mlr put -v begin{@v=$*}
mlr put -v end{$*=@v}
mlr put -v begin{unset $x}
mlr put -v end{unset $x}
mlr put -v begin{unset $*}
mlr put -v end{unset $*}
mlr put -v break
mlr put -v continue
mlr filter -v break
mlr filter -v continue
mlr --from ./reg-test/input/abixy filter 
  begin {
    @avoid = 3
  }
  NR != @avoid

mlr --from ./reg-test/input/abixy filter -x 
  begin {
    @avoid = 3
  }
  NR != @avoid

mlr --from ./reg-test/input/abixy filter 
  func f(n) {
    return n - 1
  }
  f(NR) == 5

mlr --from ./reg-test/input/abixy filter 
  subr s(n) {
    print "NR is ".n
  }
  call s(NR);
  false

Exit status was 1; expected 0.
mlr --from ./reg-test/input/abixy filter 
  int a = 5;
  int b = 7;
  a <= NR && NR <= b

mlr --from ./reg-test/input/abixy filter filter false
mlr --from ./reg-test/input/abixy filter filter false; true
Case failed due to num_invocations_failed > 0

num_invocations_attempted  25
num_invocations_passed     24
num_invocations_failed     1

diff -a -I ^mlr -I ^Miller: -I ^cat ./reg-test/expected/case-c-dsl-context-specific-validation.sh.out /Users/kerl/pub_http_internet/miller-releases/miller-head/go/output-reg-test/case-c-dsl-context-specific-validation.sh.out
4a5,6
> DSL EXPRESSION:
> begin{begin{@x=1}}
5a8,15
> * statement block
>     * begin block
>         * statement block
>             * begin block
>                 * statement block
>                     * assignment "="
>                         * direct oosvar value "x"
>                         * int literal "1"
7,29d16
< AST ROOT:
< text="block", type=STATEMENT_BLOCK:
<     text="begin", type=BEGIN:
<         text="begin_block", type=STATEMENT_BLOCK:
<             text="begin", type=BEGIN:
<                 text="begin_block", type=STATEMENT_BLOCK:
<                     text="=", type=OOSVAR_ASSIGNMENT:
<                         text="oosvar_keylist", type=OOSVAR_KEYLIST:
<                             text="x", type=STRING_LITERAL.
<                         text="1", type=NUMERIC_LITERAL.
< 
< BLOCKED AST:
< 
< BEGIN-BLOCK:
< text="begin", type=BEGIN: subframe_var_count=1 max_subframe_depth=2 max_var_depth=1
<     text="begin_block", type=STATEMENT_BLOCK:
<         text="begin", type=BEGIN:
<             text="begin_block", type=STATEMENT_BLOCK: subframe_var_count=0
<                 text="=", type=OOSVAR_ASSIGNMENT:
<                     text="oosvar_keylist", type=OOSVAR_KEYLIST:
<                         text="x", type=STRING_LITERAL.
<                     text="1", type=NUMERIC_LITERAL.
< mlr: begin statements are only valid at top level.
31a19,20
> DSL EXPRESSION:
> true{begin{@x=1}}
32a22,30
> * statement block
>     * cond block
>         * bool literal "true"
>         * statement block
>             * begin block
>                 * statement block
>                     * assignment "="
>                         * direct oosvar value "x"
>                         * int literal "1"
34,59d31
< AST ROOT:
< text="block", type=STATEMENT_BLOCK:
<     text="cond", type=CONDITIONAL_BLOCK:
<         text="true", type=BOOLEAN_LITERAL.
<         text="cond_block", type=STATEMENT_BLOCK:
<             text="begin", type=BEGIN:
<                 text="begin_block", type=STATEMENT_BLOCK:
<                     text="=", type=OOSVAR_ASSIGNMENT:
<                         text="oosvar_keylist", type=OOSVAR_KEYLIST:
<                             text="x", type=STRING_LITERAL.
<                         text="1", type=NUMERIC_LITERAL.
< 
< BLOCKED AST:
< 
< MAIN BLOCK:
< text="main_block", type=STATEMENT_BLOCK: subframe_var_count=1 max_subframe_depth=3 max_var_depth=1
<     text="cond", type=CONDITIONAL_BLOCK:
<         text="true", type=BOOLEAN_LITERAL.
<         text="cond_block", type=STATEMENT_BLOCK: subframe_var_count=0
<             text="begin", type=BEGIN:
<                 text="begin_block", type=STATEMENT_BLOCK: subframe_var_count=0
<                     text="=", type=OOSVAR_ASSIGNMENT:
<                         text="oosvar_keylist", type=OOSVAR_KEYLIST:
<                             text="x", type=STRING_LITERAL.
<                         text="1", type=NUMERIC_LITERAL.
< mlr: begin statements are only valid at top level.
61a34,35
> DSL EXPRESSION:
> end{end{@x=1}}
62a37,44
> * statement block
>     * end block
>         * statement block
>             * end block
>                 * statement block
>                     * assignment "="
>                         * direct oosvar value "x"
>                         * int literal "1"
64,86d45
< AST ROOT:
< text="block", type=STATEMENT_BLOCK:
<     text="end", type=END:
<         text="end_block", type=STATEMENT_BLOCK:
<             text="end", type=END:
<                 text="end_block", type=STATEMENT_BLOCK:
<                     text="=", type=OOSVAR_ASSIGNMENT:
<                         text="oosvar_keylist", type=OOSVAR_KEYLIST:
<                             text="x", type=STRING_LITERAL.
<                         text="1", type=NUMERIC_LITERAL.
< 
< BLOCKED AST:
< 
< END-BLOCK:
< text="end", type=END: subframe_var_count=1 max_subframe_depth=2 max_var_depth=1
<     text="end_block", type=STATEMENT_BLOCK:
<         text="end", type=END:
<             text="end_block", type=STATEMENT_BLOCK: subframe_var_count=0
<                 text="=", type=OOSVAR_ASSIGNMENT:
<                     text="oosvar_keylist", type=OOSVAR_KEYLIST:
<                         text="x", type=STRING_LITERAL.
<                     text="1", type=NUMERIC_LITERAL.
< mlr: end statements are only valid at top level.
88a48,49
> DSL EXPRESSION:
> true{end{@x=1}}
89a51,59
> * statement block
>     * cond block
>         * bool literal "true"
>         * statement block
>             * end block
>                 * statement block
>                     * assignment "="
>                         * direct oosvar value "x"
>                         * int literal "1"
91,116d60
< AST ROOT:
< text="block", type=STATEMENT_BLOCK:
<     text="cond", type=CONDITIONAL_BLOCK:
<         text="true", type=BOOLEAN_LITERAL.
<         text="cond_block", type=STATEMENT_BLOCK:
<             text="end", type=END:
<                 text="end_block", type=STATEMENT_BLOCK:
<                     text="=", type=OOSVAR_ASSIGNMENT:
<                         text="oosvar_keylist", type=OOSVAR_KEYLIST:
<                             text="x", type=STRING_LITERAL.
<                         text="1", type=NUMERIC_LITERAL.
< 
< BLOCKED AST:
< 
< MAIN BLOCK:
< text="main_block", type=STATEMENT_BLOCK: subframe_var_count=1 max_subframe_depth=3 max_var_depth=1
<     text="cond", type=CONDITIONAL_BLOCK:
<         text="true", type=BOOLEAN_LITERAL.
<         text="cond_block", type=STATEMENT_BLOCK: subframe_var_count=0
<             text="end", type=END:
<                 text="end_block", type=STATEMENT_BLOCK: subframe_var_count=0
<                     text="=", type=OOSVAR_ASSIGNMENT:
<                         text="oosvar_keylist", type=OOSVAR_KEYLIST:
<                             text="x", type=STRING_LITERAL.
<                         text="1", type=NUMERIC_LITERAL.
< mlr: end statements are only valid at top level.
120a65,66
> DSL EXPRESSION:
> begin{$x=1}
121a68,73
> * statement block
>     * begin block
>         * statement block
>             * assignment "="
>                 * direct field value "x"
>                 * int literal "1"
123,139d74
< AST ROOT:
< text="block", type=STATEMENT_BLOCK:
<     text="begin", type=BEGIN:
<         text="begin_block", type=STATEMENT_BLOCK:
<             text="=", type=SREC_ASSIGNMENT:
<                 text="x", type=FIELD_NAME.
<                 text="1", type=NUMERIC_LITERAL.
< 
< BLOCKED AST:
< 
< BEGIN-BLOCK:
< text="begin", type=BEGIN: subframe_var_count=1 max_subframe_depth=1 max_var_depth=1
<     text="begin_block", type=STATEMENT_BLOCK:
<         text="=", type=SREC_ASSIGNMENT:
<             text="x", type=FIELD_NAME.
<             text="1", type=NUMERIC_LITERAL.
< mlr: assignments to $-variables are not valid within begin or end blocks.
141a77,78
> DSL EXPRESSION:
> begin{@x=$y}
142a80,85
> * statement block
>     * begin block
>         * statement block
>             * assignment "="
>                 * direct oosvar value "x"
>                 * direct field value "y"
144,162d86
< AST ROOT:
< text="block", type=STATEMENT_BLOCK:
<     text="begin", type=BEGIN:
<         text="begin_block", type=STATEMENT_BLOCK:
<             text="=", type=OOSVAR_ASSIGNMENT:
<                 text="oosvar_keylist", type=OOSVAR_KEYLIST:
<                     text="x", type=STRING_LITERAL.
<                 text="y", type=FIELD_NAME.
< 
< BLOCKED AST:
< 
< BEGIN-BLOCK:
< text="begin", type=BEGIN: subframe_var_count=1 max_subframe_depth=1 max_var_depth=1
<     text="begin_block", type=STATEMENT_BLOCK:
<         text="=", type=OOSVAR_ASSIGNMENT:
<             text="oosvar_keylist", type=OOSVAR_KEYLIST:
<                 text="x", type=STRING_LITERAL.
<             text="y", type=FIELD_NAME.
< mlr: statements involving $-variables are not valid within begin or end blocks.
164a89,90
> DSL EXPRESSION:
> end{$x=1}
165a92,97
> * statement block
>     * end block
>         * statement block
>             * assignment "="
>                 * direct field value "x"
>                 * int literal "1"
167,183d98
< AST ROOT:
< text="block", type=STATEMENT_BLOCK:
<     text="end", type=END:
<         text="end_block", type=STATEMENT_BLOCK:
<             text="=", type=SREC_ASSIGNMENT:
<                 text="x", type=FIELD_NAME.
<                 text="1", type=NUMERIC_LITERAL.
< 
< BLOCKED AST:
< 
< END-BLOCK:
< text="end", type=END: subframe_var_count=1 max_subframe_depth=1 max_var_depth=1
<     text="end_block", type=STATEMENT_BLOCK:
<         text="=", type=SREC_ASSIGNMENT:
<             text="x", type=FIELD_NAME.
<             text="1", type=NUMERIC_LITERAL.
< mlr: assignments to $-variables are not valid within begin or end blocks.
185a101,102
> DSL EXPRESSION:
> end{@x=$y}
186a104,109
> * statement block
>     * end block
>         * statement block
>             * assignment "="
>                 * direct oosvar value "x"
>                 * direct field value "y"
188,206d110
< AST ROOT:
< text="block", type=STATEMENT_BLOCK:
<     text="end", type=END:
<         text="end_block", type=STATEMENT_BLOCK:
<             text="=", type=OOSVAR_ASSIGNMENT:
<                 text="oosvar_keylist", type=OOSVAR_KEYLIST:
<                     text="x", type=STRING_LITERAL.
<                 text="y", type=FIELD_NAME.
< 
< BLOCKED AST:
< 
< END-BLOCK:
< text="end", type=END: subframe_var_count=1 max_subframe_depth=1 max_var_depth=1
<     text="end_block", type=STATEMENT_BLOCK:
<         text="=", type=OOSVAR_ASSIGNMENT:
<             text="oosvar_keylist", type=OOSVAR_KEYLIST:
<                 text="x", type=STRING_LITERAL.
<             text="y", type=FIELD_NAME.
< mlr: statements involving $-variables are not valid within begin or end blocks.
208a113,114
> DSL EXPRESSION:
> begin{@v=$*}
209a116,121
> * statement block
>     * begin block
>         * statement block
>             * assignment "="
>                 * direct oosvar value "v"
>                 * full record "$*"
211,229d122
< AST ROOT:
< text="block", type=STATEMENT_BLOCK:
<     text="begin", type=BEGIN:
<         text="begin_block", type=STATEMENT_BLOCK:
<             text="=", type=OOSVAR_FROM_FULL_SREC_ASSIGNMENT:
<                 text="oosvar_keylist", type=OOSVAR_KEYLIST:
<                     text="v", type=STRING_LITERAL.
<                 text="$*", type=FULL_SREC.
< 
< BLOCKED AST:
< 
< BEGIN-BLOCK:
< text="begin", type=BEGIN: subframe_var_count=1 max_subframe_depth=1 max_var_depth=1
<     text="begin_block", type=STATEMENT_BLOCK:
<         text="=", type=OOSVAR_FROM_FULL_SREC_ASSIGNMENT:
<             text="oosvar_keylist", type=OOSVAR_KEYLIST:
<                 text="v", type=STRING_LITERAL.
<             text="$*", type=FULL_SREC.
< mlr: assignments from $-variables are not valid within begin or end blocks.
231a125,126
> DSL EXPRESSION:
> end{$*=@v}
232a128,133
> * statement block
>     * end block
>         * statement block
>             * assignment "="
>                 * full record "$*"
>                 * direct oosvar value "v"
234,252d134
< AST ROOT:
< text="block", type=STATEMENT_BLOCK:
<     text="end", type=END:
<         text="end_block", type=STATEMENT_BLOCK:
<             text="=", type=FULL_SREC_ASSIGNMENT:
<                 text="$*", type=FULL_SREC.
<                 text="oosvar_keylist", type=OOSVAR_KEYLIST:
<                     text="v", type=STRING_LITERAL.
< 
< BLOCKED AST:
< 
< END-BLOCK:
< text="end", type=END: subframe_var_count=1 max_subframe_depth=1 max_var_depth=1
<     text="end_block", type=STATEMENT_BLOCK:
<         text="=", type=FULL_SREC_ASSIGNMENT:
<             text="$*", type=FULL_SREC.
<             text="oosvar_keylist", type=OOSVAR_KEYLIST:
<                 text="v", type=STRING_LITERAL.
< mlr: assignments to $-variables are not valid within begin or end blocks.
254a137,138
> DSL EXPRESSION:
> begin{unset $x}
255a140,144
> * statement block
>     * begin block
>         * statement block
>             * unset "unset"
>                 * direct field value "x"
257,271d145
< AST ROOT:
< text="block", type=STATEMENT_BLOCK:
<     text="begin", type=BEGIN:
<         text="begin_block", type=STATEMENT_BLOCK:
<             text="unset", type=UNSET:
<                 text="x", type=FIELD_NAME.
< 
< BLOCKED AST:
< 
< BEGIN-BLOCK:
< text="begin", type=BEGIN: subframe_var_count=1 max_subframe_depth=1 max_var_depth=1
<     text="begin_block", type=STATEMENT_BLOCK:
<         text="unset", type=UNSET:
<             text="x", type=FIELD_NAME.
< mlr: unset of $-variables is not valid within begin or end blocks.
273a148,149
> DSL EXPRESSION:
> end{unset $x}
274a151,155
> * statement block
>     * end block
>         * statement block
>             * unset "unset"
>                 * direct field value "x"
276,290d156
< AST ROOT:
< text="block", type=STATEMENT_BLOCK:
<     text="end", type=END:
<         text="end_block", type=STATEMENT_BLOCK:
<             text="unset", type=UNSET:
<                 text="x", type=FIELD_NAME.
< 
< BLOCKED AST:
< 
< END-BLOCK:
< text="end", type=END: subframe_var_count=1 max_subframe_depth=1 max_var_depth=1
<     text="end_block", type=STATEMENT_BLOCK:
<         text="unset", type=UNSET:
<             text="x", type=FIELD_NAME.
< mlr: unset of $-variables is not valid within begin or end blocks.
292a159,160
> DSL EXPRESSION:
> begin{unset $*}
293a162,166
> * statement block
>     * begin block
>         * statement block
>             * unset "unset"
>                 * full record "$*"
295,309d167
< AST ROOT:
< text="block", type=STATEMENT_BLOCK:
<     text="begin", type=BEGIN:
<         text="begin_block", type=STATEMENT_BLOCK:
<             text="unset", type=UNSET:
<                 text="$*", type=FULL_SREC.
< 
< BLOCKED AST:
< 
< BEGIN-BLOCK:
< text="begin", type=BEGIN: subframe_var_count=1 max_subframe_depth=1 max_var_depth=1
<     text="begin_block", type=STATEMENT_BLOCK:
<         text="unset", type=UNSET:
<             text="$*", type=FULL_SREC.
< mlr: unset of $-variables is not valid within begin or end blocks.
311a170,171
> DSL EXPRESSION:
> end{unset $*}
312a173,177
> * statement block
>     * end block
>         * statement block
>             * unset "unset"
>                 * full record "$*"
314,328d178
< AST ROOT:
< text="block", type=STATEMENT_BLOCK:
<     text="end", type=END:
<         text="end_block", type=STATEMENT_BLOCK:
<             text="unset", type=UNSET:
<                 text="$*", type=FULL_SREC.
< 
< BLOCKED AST:
< 
< END-BLOCK:
< text="end", type=END: subframe_var_count=1 max_subframe_depth=1 max_var_depth=1
<     text="end_block", type=STATEMENT_BLOCK:
<         text="unset", type=UNSET:
<             text="$*", type=FULL_SREC.
< mlr: unset of $-variables is not valid within begin or end blocks.
332a183,184
> DSL EXPRESSION:
> break
333a186,187
> * statement block
>     * break "break"
335,344d188
< AST ROOT:
< text="block", type=STATEMENT_BLOCK:
<     text="break", type=BREAK.
< 
< BLOCKED AST:
< 
< MAIN BLOCK:
< text="main_block", type=STATEMENT_BLOCK: subframe_var_count=1 max_subframe_depth=1 max_var_depth=1
<     text="break", type=BREAK.
< mlr: break statements are only valid within for, while, or do-while.
346a191,192
> DSL EXPRESSION:
> continue
347a194,195
> * statement block
>     * continue "continue"
349,358d196
< AST ROOT:
< text="block", type=STATEMENT_BLOCK:
<     text="continue", type=CONTINUE.
< 
< BLOCKED AST:
< 
< MAIN BLOCK:
< text="main_block", type=STATEMENT_BLOCK: subframe_var_count=1 max_subframe_depth=1 max_var_depth=1
<     text="continue", type=CONTINUE.
< mlr: break statements are only valid within for, while, or do-while.
362a201,202
> DSL EXPRESSION:
> break
363a204,205
> * statement block
>     * break "break"
365,374d206
< AST ROOT:
< text="block", type=STATEMENT_BLOCK:
<     text="break", type=BREAK.
< 
< BLOCKED AST:
< 
< MAIN BLOCK:
< text="main_block", type=STATEMENT_BLOCK: subframe_var_count=1 max_subframe_depth=1 max_var_depth=1
<     text="break", type=BREAK.
< mlr: filter expressions must end in a final boolean statement.
376a209,210
> DSL EXPRESSION:
> continue
377a212,213
> * statement block
>     * continue "continue"
379,388d214
< AST ROOT:
< text="block", type=STATEMENT_BLOCK:
<     text="continue", type=CONTINUE.
< 
< BLOCKED AST:
< 
< MAIN BLOCK:
< text="main_block", type=STATEMENT_BLOCK: subframe_var_count=1 max_subframe_depth=1 max_var_depth=1
<     text="continue", type=CONTINUE.
< mlr: filter expressions must end in a final boolean statement.
431,440c257
< NR is 1
< NR is 2
< NR is 3
< NR is 4
< NR is 5
< NR is 6
< NR is 7
< NR is 8
< NR is 9
< NR is 10
---
> Exit status was 1; expected 0.
Case failed due to expected output != actual output

FAIL  ./reg-test/cases/case-c-dsl-context-specific-validation.sh
----------------------------------------------------------------

NUMBER OF MILLER RUNS 25
NUMBER OF CASES PASSED 0
NUMBER OF CASES FAILED 1

FAIL

================================================================
