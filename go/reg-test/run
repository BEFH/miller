#!/bin/sh

# TODO: NEEDS A FULL RE-COMMENT PASS

# ================================================================
# MILLER REGRESSION SCRIPT
#
# Miller has some source-code-level unit-test routines -- but the
# vast majority of tests (thousands) are invoked here at the
# command-line level.
#
# Output from various mlr command-line invocations, with prepared
# inputs, is generated and then compared against stored expected
# output.
# ================================================================

# ================================================================
# Functions
#
# xxx note:
# * side-global input $verbose
# * side-global input $outfile
# ... and why structured this way (so run_mlr lines can be compact)
# * side-global in/out $num_invocations_tried
# * side-global in/out $num_invocations_passed
# * side-global in/out $num_invocations_failed

announce() {
  echo >> $outfile
  echo "================================================================" >> $outfile
  echo "$@" >> $outfile
  echo >> $outfile
}

mention() {
  echo >> $outfile
  echo ---------------------------------------------------------------- "$@" >> $outfile
}

# A key feature of this regression script is that it can be invoked from any
# directory. Depending on the directory it's invoked from, the path to the mlr
# executable may vary.  Nonetheless for debugging it's crucial that we echo out
# each command being executed. See also diff -I below.
run_mlr() {
  # Use just "mlr" for info messages, not full path to mlr
  if [ "$verbose" = "true" ]; then
    echo mlr "$@"
  fi
  echo mlr "$@" >> $outfile
  num_invocations_attempted=`expr $num_invocations_attempted + 1`
  # Use path to mlr for invoking the command
  $path_to_mlr "$@" >> $outfile 2> $errfile.$$
  cat $errfile.$$ >> $errfile
  rm $errfile.$$ # TODO comment this
  num_invocations_attempted=`expr $num_invocations_attempted + 1`
  status=$?
  if [ $status -eq 0 ]; then
    num_invocations_passed=`expr $num_invocations_passed + 1`
  else
    num_invocations_failed=`expr $num_invocations_failed + 1`
  fi
  echo >> $outfile
}

mlr_expect_fail() {
  # Use just "mlr" for info messages
  if [ "$verbose" = "true" ]; then
    echo mlr "$@"
  fi
  echo mlr "$@" >> $outfile 2> $errfile.$$
  cat $errfile.$$ >> $errfile
  rm $errfile.$$ # TODO comment this
  num_invocations_attempted=`expr $num_invocations_attempted + 1`
  # Use path to mlr for invoking the command
  stderr_capture=$( $path_to_mlr "$@" 3>&1 1>&2 2>&3 >>$outfile )
  status=$?
  echo "${stderr_capture}" >> $outfile
  if [ $status -ne 1 ]; then
    if [ "$verbose" = "true" ]; then
      echo "Exit status was $status; expected 1."
    fi
    echo "Exit status was $status; expected 1." >> $outfile
  fi
  if [ $status -ne 0 ]; then
    num_invocations_passed=`expr $num_invocations_passed + 1`
  else
    num_invocations_failed=`expr $num_invocations_failed + 1`
  fi
  echo >> $outfile
}

run_mlr_no_output() {
  # Use just "mlr" for info messages
  echo mlr "$@" >> $outfile
  num_invocations_attempted=`expr $num_invocations_attempted + 1`
  # Use path to mlr for invoking the command
  $path_to_mlr "$@" 2> $errfile.$$
  cat $errfile.$$ >> $errfile
  rm $errfile.$$ # TODO comment this
  status=$?
  if [ $status -eq 0 ]; then
    num_invocations_passed=`expr $num_invocations_passed + 1`
  else
    num_invocations_failed=`expr $num_invocations_failed + 1`
  fi
  echo >> $outfile
}

# Just cats a file while also announcing that fact.
run_cat() {
  if [ "$verbose" = "true" ]; then
    echo cat "$@"
  fi
  echo cat "$@" >> $outfile # for diff at end
  cat "$@" >> $outfile      # for diff at end
  echo >> $outfile
}

# ----------------------------------------------------------------
usage() {
	echo "Usage: $(basename $0) [case*sh filenames]" 1>&2
    echo "Options:" 1>&2
    echo "-h   Print this message" 1>&2
    echo "-v   More verbose output including each mlr-invocation line, and diff outputs" 1>&2
    echo "-m {path/to/mlr} Use a specified mlr executable" 1>&2
    echo "-c   Use ../c/mlr executable" 1>&2
    echo "-g   Use ../go/mlr executable" 1>&2
    echo "-o   Run only old case-c-* cases" 1>&2
    echo "-n   Run only new case-c-* cases" 1>&2
	exit 1
}

# ================================================================
# Start of script

pwd=$(pwd)
ourdir=`dirname $0`
srcdir=$ourdir/../..
path_to_mlr=$srcdir/go/mlr
if [ ! -x "$path_to_mlr" ]; then
  echo "$0: Could not find path to mlr executable $path_to_mlr." 1>&2
fi

# Input/output locations
indir=$ourdir/input
expdir=$ourdir/expected
outdir=$pwd/output-reg-test
reloutdir=./output-reg-test

verbose="false"
case_file_names="" # None means all

while getopts vcgnom:h f
do
	case $f in
	v)      verbose="true";                   continue;;
	c)      path_to_mlr=$ourdir/../../c/mlr;  continue;;
	g)      path_to_mlr=$ourdir/../../go/mlr; continue;;
	m)      path_to_mlr="$OPTARG";            continue;;
	o)      case_file_names=$(ls $ourdir/cases/case-c-*.sh); continue;;
	n)      case_file_names=$(ls $ourdir/cases/case-go-*.sh); continue;;
	h)      echo; usage;;
	esac
done
shift $(($OPTIND-1))
if [ "$case_file_names" = "" ]; then
  case_file_names="$@"
fi

# ----------------------------------------------------------------
if [ "$(uname)" = "Darwin" ]; then
  export        textdefault=$'\033[0m'
  export                red=$'\033[31;01m'
  export              green=$'\033[32;01m'
else
  export        textdefault="\e[0m"
  export                red="\e[31m"
  export              green="\e[32m"
fi

# Bash idiom to test if file descriptor #1 (stdout) is a terminal
if [[ -t 1 ]]; then
    PASS="${green}PASS${textdefault}"
    FAIL="${red}FAIL${textdefault}"
else
    PASS="PASS"
    FAIL="FAIL"
fi

# ----------------------------------------------------------------
mkdir -p $outdir

# Don't let the running user's .mlrrc affect the regression test
export MLRRC="__none__"

rm -rf $outdir
mkdir -p $outdir

echo Using mlr executable $path_to_mlr

# ----------------------------------------------------------------
# TODO: comments:
# * Input-globals:
#   o path_to_mlr
#   o verbose
#   o outfile (changes)
#
# * State-globals:
#   o num_invocations_attempted
#   o num_invocations_passed
#   o num_invocations_failed
#
# * Sketch:
#   o Discover well-ordered *.case files
#   o Contents are as now: announce, run_mlr, mlr_expect_fail
#   o Count global #pass #fail, as well as per-case-file #pass #fail
#   o Set verbose here
#   o Execute each case file with redirected output. Only details if -v.
# ----------------------------------------------------------------

# Over all cases:
num_cases_attempted=0
num_cases_passed=0
num_cases_failed=0

total_num_invocations_attempted=0

if [ "$case_file_names" = "" ]; then
    case_file_names=$(ls $ourdir/cases/case-*.sh)
fi

for case_file in $case_file_names; do

  # Per case:
  num_invocations_attempted=0
  num_invocations_passed=0
  num_invocations_failed=0

  if [ "$verbose" = "true" ] ; then
    echo ""
    echo "----------------------------------------------------------------"
    echo "BEGIN $case_file"
    echo ""
  fi

  case_name=$(basename $case_file)
  outfile=$outdir/$case_name.out
  errfile=$outdir/$case_name.err
  expfile=$expdir/$case_name.out

  echo > $outfile

  num_cases_attempted=`expr $num_cases_attempted + 1`

  # ----------------------------------------------------------------
  # Run all invocations in the case:
  . $case_file
  # ----------------------------------------------------------------

  # There are two ways to fail:
  # * Miller-command code was 0 not 1 (or vice versa) -- checked per-invocation
  # * Expected/actual output mismatch -- checked per-case

  case_passed=true
  if [ $num_invocations_failed -ne 0 ]; then
    case_passed=false
  fi

  if [ "$verbose" = "true" ]; then
    echo diff -a -I '^mlr' -I '^cat' -C5 $expfile $outfile
    diff -a -I '^mlr' -I '^cat' -C5 $expfile $outfile
  else
    diff -q -a -I '^mlr' -I '^cat' -C5 $expfile $outfile > /dev/null
  fi
  status=$?
  if [ $status -ne 0 ]; then
    case_passed=false
  fi

  if [ "$verbose" = "true" ]; then
    echo
  fi

  if [ $case_passed = "true" ]; then
    echo "$PASS  $case_file"
    num_cases_passed=`expr $num_cases_passed + 1`
  else
    echo "$FAIL  $case_file"
    num_cases_failed=`expr $num_cases_failed + 1`
  fi

  if [ "$verbose" = "true" ]; then
    echo "----------------------------------------------------------------"
  fi

  total_num_invocations_attempted=`expr $total_num_invocations_attempted + $num_invocations_attempted`
done

echo
echo "NUMBER OF MILLER RUNS $total_num_invocations_attempted"
echo "NUMBER OF CASES PASSED $num_cases_passed"
echo "NUMBER OF CASES FAILED $num_cases_failed"
echo

# ----------------------------------------------------------------
if [ $num_cases_failed -eq 0 ]; then
  echo "$PASS"
  exit 0
else
  echo "$FAIL"
  exit 1
fi
