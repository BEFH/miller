// ================================================================
// GRAMMAR FOR THE MILLER DOMAIN-SPECIFIC LANGUAGE
//
// This is the Miller DSL's BNF grammar, using the awesome GOCC tool framework
// from https://github.com/goccmack/gocc.
//
// The first section is lexical elements and the second section is syntactical
// elements. These are the analogs of lex and yacc, respectively, using a
// classical C/lex/yacc framework -- although for lex/yacc one would have
// separate .l and .y files, whereas here there is a single .bnf file.
//
// Notes:
//
// * Lexical items are either literals inlined within the syntactical section,
//   such as "/", or snake-cased named tokens within the lexical section, such
//   as md_token_field_name.
//
// * Syntactical items are all camel-cased, such as MapLiteral.
//
// * This grammar is used to auto-generate Go code, using bin/gocc.
//
// * Everything is delivered in the form of an abstract syntax tree (AST),
//   via <<...>>> code segments within this file's syntactical section, to be
//   processed in hand-written Go code. That code, in turn, turns the AST into
//   a CST (concrete syntax tree) which is what the DSL runtime executes.
//
// * The <<...>> code called by the gocc framework must accept interface{},
//   to be generic, but in practice all arguments end up being token.Token
//   (regcognizable here via string-literals or snake-cased namees) or
//   *miller.dsl.AstNode (recognizable here via camel-cased names).
//
// * Another pattern worth pointing out is that in the gocc framework,
//   return-types from AST methods must be a pair of (interface{}, error),
//   whereas argument going into those same methods are interface{} only.
//   Hence a few methods in the Miller AST API which don't return a pair of
//   interface{}/error since they are meant for nesting as arguments here
//   within this file.
//
// * Please see src/miller/dsl/ast.go for more about what the <<...>>
//   code here is calling.
// ================================================================

// ================================================================
// LEXICAL ELEMENTS
// ================================================================

// ----------------------------------------------------------------
// CHARACTER CLASSES
// ----------------------------------------------------------------

_letter : 'a'-'z' | 'A'-'Z' ;
_decdig : '0'-'9' ;
_hexdig : '0'-'9' | 'a'-'f' | 'A'-'F';
_bindig : '0'-'1' ;
_idchar : _letter | _decdig | '_' ;
!whitespace : ' ' | '\t' | '\n' | '\r' ;

// ----------------------------------------------------------------
// STRING/INT/FLOAT/BOOLEAN LITERALS
// ----------------------------------------------------------------

// Notes on string literals:
// * " isn't included here -- need \" handling to put that inside strings
// * GOCC seems to lack a '[^"] notation ...
_string_literal_element
  : 'A'-'Z' | 'a'-'z' | '0'-'9'
  | ' ' | '!' | '#' | '$' | '%' | '&' | '\'' | '\\'
  | '(' | ')' | '*' | '+' | ',' | '-' | '.' | '/'
  | ':' | ';' | '<' | '=' | '>' | '?' | '@' | '['
  | ']' | '^' | '_' | '`' | '{' | '|' | '}' | '~'
  | ( '\\' '"' )
  | '\u0100'-'\U0010FFFF'
;
md_token_string_literal : '"' {_string_literal_element} '"' ;

// md_token_regexi : \"([^\\\"]|\\.)*\"\i ;

// Notes on int literals:
// * Leading minus sign is handled via the unary-minus operator, not here.
md_token_int_literal
  : _decdig { _decdig }
  | '0' 'x' _hexdig { _hexdig }
  | '0' 'b' _bindig { _bindig }
;

// Notes on float literals:
// * Leading minus sign is handled via the unary-minus operator, not here.
// * The various shapes are for scientific notation. Examples:
//   123
//   123.
//   123.4
//   .234
//   1e2
//   1e-2
//   1.2e3 1.e3
//   1.2e-3 1.e-3
//   .2e3
//   .2e-3 1.e-3
_scinotE : 'e' | 'E' ;
md_token_float_literal
  : _decdig { _decdig} '.' { _decdig }
  | _decdig { _decdig}                        _scinotE     _decdig { _decdig}
  | _decdig { _decdig}                        _scinotE '-' _decdig { _decdig}
  | _decdig { _decdig} '.'         { _decdig} _scinotE     _decdig { _decdig}
  | _decdig { _decdig} '.'         { _decdig} _scinotE '-' _decdig { _decdig}
  |         { _decdig} '.' _decdig { _decdig} _scinotE     _decdig { _decdig}
  |         { _decdig} '.' _decdig { _decdig} _scinotE '-' _decdig { _decdig}
;

md_token_M_PI : 'M' '_' 'P' 'I' ;
md_token_M_E  : 'M' '_' 'E' ;

// Notes on boolean literals:
// * true and false should be defined here rather than as "true" / "false"
//   within the grammar below -- this forces them to be keywords, not legal as
//   variable names. We want them as keywords -- we don't want to allow things
//   like 'true = 3'.
_md_token_true : 't' 'r' 'u' 'e' ;
_md_token_false : 'f' 'a' 'l' 's' 'e';
md_token_boolean_literal : ( _md_token_true | _md_token_false );

// ----------------------------------------------------------------
// MILLER CONTEXT VARIABLES
// ----------------------------------------------------------------

md_token_IPS : 'I' 'P' 'S' ;
md_token_IFS : 'I' 'F' 'S' ;
md_token_IRS : 'I' 'R' 'S' ;

md_token_OPS : 'O' 'P' 'S' ;
md_token_OFS : 'O' 'F' 'S' ;
md_token_ORS : 'O' 'R' 'S' ;

md_token_NF  : 'N' 'F' ;
md_token_NR  : 'N' 'R' ;
md_token_FNR : 'F' 'N' 'R' ;

md_token_FILENAME : 'F' 'I' 'L' 'E' 'N' 'A' 'M' 'E' ;
md_token_FILENUM  : 'F' 'I' 'L' 'E' 'N' 'U' 'M' ;

// md_token_ENV   : 'E' 'N' 'V' ;

// ----------------------------------------------------------------
// MILLER KEYWORDS
// ----------------------------------------------------------------

// Notes on keywords:
// * Any new keywords defined here should also be documented
//   in dsl/mlr_dsl_cst.c's mlr_dsl_keyword_usage() et al.
// * true and false (boolean literals) are also keywords, defined above.

md_token_begin    : 'b' 'e' 'g' 'i' 'n' ;
md_token_do       : 'd' 'o' ;
md_token_dump     : 'd' 'u' 'm' 'p' ;
md_token_edump    : 'e' 'd' 'u' 'm' 'p' ;
md_token_elif     : 'e' 'l' 'i' 'f' ;
md_token_else     : 'e' 'l' 's' 'e' ;
md_token_emit     : 'e' 'm' 'i' 't' ;
md_token_end      : 'e' 'n' 'd' ;
md_token_filter   : 'f' 'i' 'l' 't' 'e' 'r' ;
md_token_for      : 'f' 'o' 'r' ;
md_token_if       : 'i' 'f' ;
md_token_in       : 'i' 'n' ;
md_token_while    : 'w' 'h' 'i' 'l' 'e' ;
md_token_break    : 'b' 'r' 'e' 'a' 'k' ;
md_token_continue : 'c' 'o' 'n' 't' 'i' 'n' 'u' 'e' ;

md_token_func     : 'f' 'u' 'n' 'c' ;
//md_token_subr     : 's' 'u' 'b' 'r' ;
//md_token_call     : 'c' 'a' 'l' 'l' ;
md_token_return   : 'r' 'e' 't' 'u' 'r' 'n' ;

md_token_int_type     : 'i' 'n' 't' ;
md_token_float_type   : 'f' 'l' 'o' 'a' 't' ;
//md_token_num_type   : 'n' 'u' 'm' ;
//md_token_bool_type  : 'b' 'o' 'o' 'l' ;
//md_token_str_type   : 's' 't' 'r' ;
//md_token_map_type   : 'm' 'a' 'p' ;
//md_token_array_type : 'a' 'r' 'r' 'a' 'y';

//md_token_unset    : 'u' 'n' 's' 'e' 't' ;
//md_token_all      : 'a' 'l' 'l' ;

//md_token_eprint   : 'e' 'p' 'r' 'i' 'n' 't' ;
//md_token_eprintn  : 'e' 'p' 'r' 'i' 'n' 't' 'n' ;
//md_token_print    : 'p' 'r' 'i' 'n' 't' ;
//md_token_printn   : 'p' 'r' 'i' 'n' 't' 'n' ;
//md_token_stderr   : 's' 't' 'd' 'e' 'r' 'r' ;
//md_token_stdout   : 's' 't' 'd' 'o' 'u' 't' ;
//md_token_tee      : 't' 'e' 'e' ;

// ----------------------------------------------------------------
// FIELD NAMES, OUT-OF-STREAM VARIABLES, LOCAL VARIABLES
// ----------------------------------------------------------------

// Note: the parser depends on the dollar sign being here. If this is changed,
// that needs to be changed as well.
//
// Also note: if we omit the '$' here and include it in the parser section
// below as "$", then we get an LR-1 conflict. So this must be dealt with at
// the AST level.
md_token_field_name : '$' _idchar { _idchar } ;

// This is for literal strings but where the field name might have spaces in it
// or somesuch.
_braced_char
  : 'A'-'Z' | 'a'-'z' | '0'-'9'
  | ' ' | '!' | '#' | '$' | '%' | '&' | '\'' | '\\'
  | '(' | ')' | '*' | '+' | ',' | '-' | '.' | '/'
  | ':' | ';' | '<' | '=' | '>' | '?' | '@' | '['
  | ']' | '^' | '_' | '`'       | '|'       | '~'
  | ( '\\' '{' ) | ( '\\' '}' )
  | '\u0100'-'\U0010FFFF'
;
md_token_braced_field_name: '$' '{' _braced_char { _braced_char } '}' ;

md_token_full_srec : '$' '*' ;

md_token_oosvar_name : '@' _idchar { _idchar } ;

// This is for literal strings but where the oosvar name might have spaces in it
// or somesuch.
md_token_braced_oosvar_name: '@' '{' _braced_char { _braced_char } '}' ;

md_token_full_oosvar : '@' '*' ;

// ----------------------------------------------------------------
// FUNCTIONS AND LOCAL VARIABLES

md_token_non_sigil_name : _idchar { _idchar } ;

// ----------------------------------------------------------------
// PANIC TOKEN
// ----------------------------------------------------------------

// This is for testing short-circuiting of "&&", "||", etc in the CST.  The
// sole job of the CST evaluator for this token is to panic the process -- so
// we'll know if we're evaluating something we should not.
md_token_panic : '%' '%' '%' 'p' 'a' 'n' 'i' 'c' '%' '%' '%' ;


// ================================================================
// SYNTAX ELEMENTS
// ================================================================

// ================================================================
// Parsing goes through three formats:
//
// (1) Source code which is a string of characters.
//
// (2) Abstract syntax tree (AST):
//
//    * Parentheses, commas, semicolons, line endings, whitespace are all stripped away
//    * Variable names and literal values remain as leaf nodes of the AST
//    * = + - * / ** {function names} remain as non-leaf nodes of the AST
//
// (3) Concrete syntax tree (CST): a reshaping of the AST with pre-processed
//     setup of function pointers to handle each type of statement on a
//     per-record basis. The if/else and/or switch statements to decide what to
//     do with each AST node are done at CST-build time, so they don't need to
//     be re-done when the syntax tree is executed once on every data record.
//
// The job of this parser is to turn (1) into (2).
//
// Note: This parser accepts many things that are invalid, e.g.
// * begin{end{}} -- begin/end not at top level
// * begin{$x=1} -- references to stream records at begin/end (there is no $x when
//   there is no input record yet)
// * break/continue outside of for/while/do-while
// * return outside of a function definition
// * $x=x -- boundvars outside of for-loop variable bindings
//
// All of the above are enforced by the CST builder's semantic-analysis logic,
// which takes this parser's output AST as input.  This is done (a) to keep
// this grammar from being overly complex, and (b) so we can get more
// informative error messages.
//
// For clearer visuals on what the ASTs look like, you can do 
//
//   mlr -n put -v 'your expression goes here'
//
// Also see reg_test/run's filter -v and put -v outputs, e.g. in
// reg_test/expected/out.
// ================================================================

// Import the AST/ASTNode types and functions
<< import "miller/dsl" >>

// ================================================================
// TOP-LEVEL PRODUCTION RULE FOR THE MILLER DSL

Root :
  : empty // mlr put ' ' is OK: this is zero statements
    << dsl.NewAST(dsl.NewASTNodeEmptyNestable(dsl.NodeTypeEmptyStatement)) >>
  | StatementBlock
    <<dsl.NewAST($0) >>
;

// Braceful statements are things like 'begin{...}', 'end{...}', 'if{...}', etc.
// Braceless statements are everything else -- such as assignments, subroutine
// calls, bare booleans.
StatementBlock

  : BracelessStatement
    << dsl.NewASTNodeUnary(nil, $0, dsl.NodeTypeStatementBlock) >>

  | BracelessStatement ";" StatementBlock
    <<dsl.PrependChild($2, $0) >>

  // Semicolons are separators, not terminators, in the Miller DSL -- most
  // importantly people can say '$x = 3' without '$x = 3;'.  However, we do
  // allow trailing semicolons.
  | BracelessStatement ";"
    << dsl.NewASTNodeUnary(nil, $0, dsl.NodeTypeStatementBlock) >>

  | BracefulStatement
    << dsl.NewASTNodeUnary(nil, $0, dsl.NodeTypeStatementBlock) >>

  // They don't need the semicolon in 'begin {@a = 1}; $x = 2'
  | BracefulStatement StatementBlock
    <<dsl.PrependChild($1, $0) >>

;

StatementBlockInBraces
  // Defining StatementBlock to be emptyable would have been more elegant ...
  // I got LR-1 conflicts though. :^/
  : "{" "}"
    << dsl.NewASTNodeZary(nil, dsl.NodeTypeStatementBlock) >>

  | "{" StatementBlock "}"
    << dsl.Wrap($1) >>
  ;

// ================================================================
// ASSIGMENT STATEMENTS

BracelessStatement
  : Assignment
  | BareBoolean
  | FilterStatement
  | EmitStatement
  | DumpStatement
  | EdumpStatement
  // Has braces but does not *end* in braces -- so it requires semicolon after.
  | DoWhileLoop
  | BreakStatement
  | ContinueStatement
  | ReturnStatement
;

Assignment
  : Lvalue "=" Rvalue
    << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeAssignment) >>
;

// In progress: expand Lvalue syntax here and prohibit it in the CST builder.
// This is to eliminate LR-1 conflicts on bare-boolean and awkish conds.  As a
// side effect, by allowing things like '1+2=3+4' here in the grammar and
// prohibiting them in the CST builder, we can more easily make more detailed
// error messages.
Lvalue : Rvalue ;

//// A BaseValue is anything on the left-hand side of an assignment, excluding
//// the indexing -- e.g. @a is a BaseValue and an Lvalue; @a[1][2][3] is an
//// Lvalue which is an indexed Lvalue.
//Lvalue
//  : BaseLvalue
//  | IndexedLvalue
//  // | SlicedLvalue -- like $text[3:7] = "interpolated"
//  // | ENVValue -- only ENV["foo"] but not arbitrarily indexable like ENV["foo"]["bar"]
//;

//BaseLvalue
//  : FieldValue
//  | OosvarValue
//  // positional field name $[[3]]
//  // positional field value $[[[3]]]
//  | FullSrec
//  | FullOosvar
//  // local variable abcd
//;

//IndexedLvalue
//  : Lvalue "[" Rvalue "]" 
//    << dsl.NewASTNodeBinary(
//      dsl.NewASTToken("[]", $1),
//      $0,
//      $2,
//      dsl.NodeTypeArrayOrMapIndexAccess,
//    )>>
//;

BareBoolean
  : Rvalue
    << dsl.NewASTNodeUnary(nil, $0, dsl.NodeTypeBareBoolean) >>
  ;

FilterStatement
  : md_token_filter Rvalue
    << dsl.NewASTNodeUnary($0, $1, dsl.NodeTypeFilterStatement) >>
  ;

EmitStatement
  : md_token_emit Rvalue // xxx more to do
    << dsl.NewASTNodeUnary($0, $1, dsl.NodeTypeEmitStatement) >>
  ;

DumpStatement
  : md_token_dump
    << dsl.NewASTNodeZary($0, dsl.NodeTypeDumpStatement) >>
  ;

EdumpStatement
  : md_token_edump // xxx more to do
    << dsl.NewASTNodeZary($0, dsl.NodeTypeEdumpStatement) >>
  ;

// ----------------------------------------------------------------
FieldValue
  : DirectFieldValue
  | IndirectFieldValue
  | BracedFieldValue
  //| PositionalFieldName
  //| PositionalFieldValue
  // ...
;

// Note: the field name is "$name" not "name" since md_token_field_name
// includes the '$'.  If we omit the '$' there and include it in the parser
// section here as "$", then we get an LR-1 conflict. So this must be dealt
// with at the AST level. Hence the NewASTNodeStripDollarOrAtSign.
DirectFieldValue
  : md_token_field_name
    << dsl.NewASTNodeStripDollarOrAtSign($0, dsl.NodeTypeDirectFieldValue) >>
;

IndirectFieldValue
  : "$[" Rvalue "]"
    << dsl.NewASTNodeUnary(dsl.NewASTToken("$[]", $0), $1, dsl.NodeTypeIndirectFieldValue) >>
;

// * Direct is '$name'
// * Indirect is '$["name"]'
// * Braced is '${name}' -- note no double-quotes. This is for when the field
//   name has spaces or somesuch in it.
BracedFieldValue
  : md_token_braced_field_name
    << dsl.NewASTNodeStripDollarOrAtSignAndCurlyBraces($0, dsl.NodeTypeDirectFieldValue) >>
;

FullSrec
  : md_token_full_srec
  << dsl.NewASTNode($0, dsl.NodeTypeFullSrec) >>
;

// ----------------------------------------------------------------
OosvarValue
  : DirectOosvarValue
  | IndirectOosvarValue
  | BracedOosvarValue
;

// Note: the oosvar name is "@name" not "name" since md_token_oosvar_name
// includes the '@'.  If we omit the '@' there and include it in the parser
// section here as "$", then we get an LR-1 conflict. So this must be dealt
// with at the AST level. Hence the NewASTNodeStripDollarOrAtSign.
DirectOosvarValue
  : md_token_oosvar_name
    << dsl.NewASTNodeStripDollarOrAtSign($0, dsl.NodeTypeDirectOosvarValue) >>
;

IndirectOosvarValue
  : "@[" Rvalue "]"
    << dsl.NewASTNodeUnary(dsl.NewASTToken("@[]", $0), $1, dsl.NodeTypeIndirectOosvarValue) >>
;

// * Direct is '@name'
// * Indirect is '@["name"]'
// * Braced is '@{name}' -- note no double-quotes. This is for when the oosvar
//   name has spaces or somesuch in it.
BracedOosvarValue
  : md_token_braced_oosvar_name
    << dsl.NewASTNodeStripDollarOrAtSignAndCurlyBraces($0, dsl.NodeTypeDirectOosvarValue) >>
;

FullOosvar
  : md_token_full_oosvar
  << dsl.NewASTNode($0, dsl.NodeTypeFullOosvar) >>
;

// ----------------------------------------------------------------
LocalVariable
  : md_token_non_sigil_name
    << dsl.NewASTNode($0, dsl.NodeTypeLocalVariable) >>
  ;

// ----------------------------------------------------------------
// REWRITE COMPOUND ASSIGNMENT OPERATORS
//
// Transform '$x += 1' which would have AST
//
//   +=
//       $x
//       1
//
// into '$x = $x + 1' with AST
//
//   =
//       $x
//       +
//           $x
//           1
//
// right here in the parser.
//
// Use the NewASTToken to clone the "||=" into "||" and so on.

Assignment

  : Lvalue "||=" Rvalue
    << dsl.NewASTNodeBinary(
      dsl.NewASTToken("=", $1),
      $0,
      dsl.NewASTNodeBinaryNestable(dsl.NewASTToken("||", $1), $0, $2, dsl.NodeTypeOperator),
      dsl.NodeTypeAssignment,
    ) >>

  | Lvalue "^^=" Rvalue
    << dsl.NewASTNodeBinary(
      dsl.NewASTToken("=", $1),
      $0,
      dsl.NewASTNodeBinaryNestable(dsl.NewASTToken("^^", $1), $0, $2, dsl.NodeTypeOperator),
      dsl.NodeTypeAssignment,
    ) >>

  | Lvalue "&&=" Rvalue
    << dsl.NewASTNodeBinary(
      dsl.NewASTToken("=", $1),
      $0,
      dsl.NewASTNodeBinaryNestable(dsl.NewASTToken("&&", $1), $0, $2, dsl.NodeTypeOperator),
      dsl.NodeTypeAssignment,
    ) >>

  | Lvalue "|=" Rvalue
    << dsl.NewASTNodeBinary(
      dsl.NewASTToken("=", $1),
      $0,
      dsl.NewASTNodeBinaryNestable(dsl.NewASTToken("|", $1), $0, $2, dsl.NodeTypeOperator),
      dsl.NodeTypeAssignment,
    ) >>

  | Lvalue "^=" Rvalue
    << dsl.NewASTNodeBinary(
      dsl.NewASTToken("=", $1),
      $0,
      dsl.NewASTNodeBinaryNestable(dsl.NewASTToken("^", $1), $0, $2, dsl.NodeTypeOperator),
      dsl.NodeTypeAssignment,
    ) >>

  | Lvalue "^=" Rvalue
    << dsl.NewASTNodeBinary(
      dsl.NewASTToken("=", $1),
      $0,
      dsl.NewASTNodeBinaryNestable(dsl.NewASTToken("^", $1), $0, $2, dsl.NodeTypeOperator),
      dsl.NodeTypeAssignment,
    ) >>

  | Lvalue "<<=" Rvalue
    << dsl.NewASTNodeBinary(
      dsl.NewASTToken("=", $1),
      $0,
      dsl.NewASTNodeBinaryNestable(dsl.NewASTToken("<<", $1), $0, $2, dsl.NodeTypeOperator),
      dsl.NodeTypeAssignment,
    ) >>

  | Lvalue ">>=" Rvalue
    << dsl.NewASTNodeBinary(
      dsl.NewASTToken("=", $1),
      $0,
      dsl.NewASTNodeBinaryNestable(dsl.NewASTToken(">"+">", $1), $0, $2, dsl.NodeTypeOperator),
      dsl.NodeTypeAssignment,
    ) >>

  | Lvalue ">>>=" Rvalue
    << dsl.NewASTNodeBinary(
      dsl.NewASTToken("=", $1),
      $0,
      dsl.NewASTNodeBinaryNestable(dsl.NewASTToken(">"+">"+">", $1), $0, $2, dsl.NodeTypeOperator),
      dsl.NodeTypeAssignment,
    ) >>

  | Lvalue "+=" Rvalue
    << dsl.NewASTNodeBinary(
      dsl.NewASTToken("=", $1),
      $0,
      dsl.NewASTNodeBinaryNestable(dsl.NewASTToken("+", $1), $0, $2, dsl.NodeTypeOperator),
      dsl.NodeTypeAssignment,
    ) >>

  | Lvalue ".=" Rvalue
    << dsl.NewASTNodeBinary(
      dsl.NewASTToken("=", $1),
      $0,
      dsl.NewASTNodeBinaryNestable(dsl.NewASTToken(".", $1), $0, $2, dsl.NodeTypeOperator),
      dsl.NodeTypeAssignment,
    ) >>

  | Lvalue "-=" Rvalue
    << dsl.NewASTNodeBinary(
      dsl.NewASTToken("=", $1),
      $0,
      dsl.NewASTNodeBinaryNestable(dsl.NewASTToken("-", $1), $0, $2, dsl.NodeTypeOperator),
      dsl.NodeTypeAssignment,
    ) >>

  | Lvalue "*=" Rvalue
    << dsl.NewASTNodeBinary(
      dsl.NewASTToken("=", $1),
      $0,
      dsl.NewASTNodeBinaryNestable(dsl.NewASTToken("*", $1), $0, $2, dsl.NodeTypeOperator),
      dsl.NodeTypeAssignment,
    ) >>

  | Lvalue "/=" Rvalue
    << dsl.NewASTNodeBinary(
      dsl.NewASTToken("=", $1),
      $0,
      dsl.NewASTNodeBinaryNestable(dsl.NewASTToken("/", $1), $0, $2, dsl.NodeTypeOperator),
      dsl.NodeTypeAssignment,
    ) >>

  | Lvalue "//=" Rvalue
    << dsl.NewASTNodeBinary(
      dsl.NewASTToken("=", $1),
      $0,
      dsl.NewASTNodeBinaryNestable(dsl.NewASTToken("//", $1), $0, $2, dsl.NodeTypeOperator),
      dsl.NodeTypeAssignment,
    ) >>

  | Lvalue "%=" Rvalue
    << dsl.NewASTNodeBinary(
      dsl.NewASTToken("=", $1),
      $0,
      dsl.NewASTNodeBinaryNestable(dsl.NewASTToken("%", $1), $0, $2, dsl.NodeTypeOperator),
      dsl.NodeTypeAssignment,
    ) >>

  | Lvalue "**=" Rvalue
    << dsl.NewASTNodeBinary(
      dsl.NewASTToken("=", $1),
      $0,
      dsl.NewASTNodeBinaryNestable(dsl.NewASTToken("**", $1), $0, $2, dsl.NodeTypeOperator),
      dsl.NodeTypeAssignment,
    ) >>
;

// ================================================================
// BEGIN RVALUE OPERATOR-PRECEDENCE CHAIN
// ================================================================

Rvalue : PrecedenceChainStart ;

PrecedenceChainStart : TernaryTerm ;

TernaryTerm
  : LogicalOrTerm "?" TernaryTerm ":" TernaryTerm
    << dsl.NewASTNodeTernary(dsl.NewASTToken("?:", $1), $0, $2, $4, dsl.NodeTypeOperator) >>
  | LogicalOrTerm
;

LogicalOrTerm
  : LogicalOrTerm "||" LogicalXORTerm
    << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | LogicalXORTerm
;

LogicalXORTerm
  : LogicalXORTerm "^^" LogicalAndTerm
    << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | LogicalAndTerm
;

LogicalAndTerm
  : LogicalAndTerm "&&" EqneTerm
    << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | EqneTerm
;

EqneTerm
  : EqneTerm "=~"  CmpTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | EqneTerm "!=~" CmpTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | EqneTerm "=="  CmpTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | EqneTerm "!="  CmpTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | CmpTerm
;

CmpTerm
  : CmpTerm ">"  BitwiseORTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | CmpTerm ">=" BitwiseORTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | CmpTerm "<"  BitwiseORTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | CmpTerm "<=" BitwiseORTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | BitwiseORTerm
;

BitwiseORTerm
  : BitwiseORTerm "|" BitwiseXORTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | BitwiseXORTerm
;

BitwiseXORTerm
  : BitwiseXORTerm "^" BitwiseANDTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | BitwiseANDTerm
;

BitwiseANDTerm
  : BitwiseANDTerm "&" BitwiseShiftTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | BitwiseShiftTerm
;

BitwiseShiftTerm
  : BitwiseShiftTerm "<<"  AddsubdotTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | BitwiseShiftTerm ">>"  AddsubdotTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | BitwiseShiftTerm ">>>" AddsubdotTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | AddsubdotTerm
;

AddsubdotTerm
  : AddsubdotTerm "+"  MuldivTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | AddsubdotTerm "-"  MuldivTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | AddsubdotTerm ".+" MuldivTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | AddsubdotTerm ".-" MuldivTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | AddsubdotTerm "."  MuldivTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | MuldivTerm
;

MuldivTerm
  : MuldivTerm "*"   UnaryOpTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | MuldivTerm "/"   UnaryOpTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | MuldivTerm "//"  UnaryOpTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | MuldivTerm "%"   UnaryOpTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | MuldivTerm ".*"  UnaryOpTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | MuldivTerm "./"  UnaryOpTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | MuldivTerm ".//" UnaryOpTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | UnaryOpTerm
;

UnaryOpTerm
  : "+"  PowTerm << dsl.NewASTNodeUnary($0, $1, dsl.NodeTypeOperator) >>
  | "-"  PowTerm << dsl.NewASTNodeUnary($0, $1, dsl.NodeTypeOperator) >>
  | ".+" PowTerm << dsl.NewASTNodeUnary($0, $1, dsl.NodeTypeOperator) >>
  | ".-" PowTerm << dsl.NewASTNodeUnary($0, $1, dsl.NodeTypeOperator) >>
  | "!"  PowTerm << dsl.NewASTNodeUnary($0, $1, dsl.NodeTypeOperator) >>
  | "~"  PowTerm << dsl.NewASTNodeUnary($0, $1, dsl.NodeTypeOperator) >>
  | PowTerm
;

PowTerm
  : PrecedenceChainEnd "**" PowTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | PrecedenceChainEnd
;

// Please Excuse My Dear Aunt Sally! :) We've gotten to the 'P' so we're done
// with the operator-precedence chain. :)

PrecedenceChainEnd
  : "(" Rvalue ")"
  << dsl.Nestable($1) >>
;

PrecedenceChainEnd : MlrvalOrFunction ;

// ================================================================
// END RVALUE OPERATOR-PRECEDENCE CHAIN
// ================================================================

// ================================================================
// Leaf-ish nodes, i.e. expressions without operators ... in things like '$y =
// 3 * $x + 4', the Rvalue operator-parse separates out the '3', the '$x', and
// the '4' ... but they could have as well been '$y = 3 * $x[7] + f($a,$b,$c)'.
//
// Grammar rules here have to do with nodes like '3', or '$x[7]', or
// 'f($a,$b,$c)'.
//
// At the moment I call these MlrvalOrFunction.

// ----------------------------------------------------------------
MlrvalOrFunction
  : FieldValue
  | FullSrec
  | OosvarValue
  | FullOosvar
  | LocalVariable
  // ENV -- only ENV["foo"] but not arbitrarily indexable
;

// ----------------------------------------------------------------
// STRING/INT/FLOAT/BOOL LITERALS

// As with '$' on md_token_field_name, so too for md_token_string_literal we
// get LR-1 conflicts if we attempt to put the double quotes here.  Hence the
// quote-stripper AST method. Also, since string literals can have
// backslash-escaped double-quotes like "...\"...\"...", we also unbackslash
// in the same method.
MlrvalOrFunction
  : md_token_string_literal  << dsl.NewASTNodeStripDoubleQuotePair(
    $0,
    dsl.NodeTypeStringLiteral,
  ) >>

  | md_token_int_literal
    << dsl.NewASTNode($0, dsl.NodeTypeIntLiteral) >>

  | md_token_float_literal
    << dsl.NewASTNode($0, dsl.NodeTypeFloatLiteral) >>

  | md_token_boolean_literal
    << dsl.NewASTNode($0, dsl.NodeTypeBoolLiteral) >>

  | md_token_M_PI 
    << dsl.NewASTNode(
      $0,
      dsl.NodeTypeConstant,
    ) >>

  | md_token_M_E
    << dsl.NewASTNode(
      $0,
      dsl.NodeTypeConstant,
    ) >>

  | md_token_panic
    << dsl.NewASTNode($0, dsl.NodeTypePanic) >>
;

//MlrvalOrFunction(A) ::= md_regexi(B). {
//	A = B;
//}

//md_regexi(A) ::= md_token_regexi(B). {
//	char* input = B->text;
//	char* stripped = &input[1];
//	int len = strlen(input);
//	stripped[len-3] = 0;
//	A = mlr_dsl_ast_node_alloc(mlr_alloc_unbackslash(stripped), B->type);
//}

// ================================================================
// Array literals in Miller are JSON-ish.

MlrvalOrFunction : ArrayLiteral ;

// ----------------------------------------------------------------
ArrayLiteral

  : "[" "]"
    << dsl.NewASTNodeZary(
      dsl.NewASTToken("[]", $0),
      dsl.NodeTypeArrayLiteral,
    ) >>

  | "[" ArrayLiteralElements "]"
    // As parsed there's an intermediate node between ArrayLiteral
    // and the children. Now we can remove it.
    //
    // Before:
    // * ArrayLiteral "[]"
    //     * ArrayLiteral
    //         * StringLiteral "a"
    //         * StringLiteral "b"
    //
    // After:
    // * ArrayLiteral "[]"
    //     * StringLiteral "a"
    //     * StringLiteral "b"
    << dsl.AdoptChildren(
      dsl.NewASTNodeNestable(
        dsl.NewASTToken("[]", $0),
        dsl.NodeTypeArrayLiteral,
      ),
      $1,
    ) >>
;

// ----------------------------------------------------------------
ArrayLiteralElements

  : Rvalue
    << dsl.NewASTNodeUnary(
      nil,
      $0,
      dsl.NodeTypeArrayLiteral,
    ) >>

  // Allow trailing final comma, especially for multiline statements
  | Rvalue ","
    << dsl.NewASTNodeUnary(
      nil,
      $0,
      dsl.NodeTypeArrayLiteral,
    ) >>

  // Allow trailing final comma, especially for multiline statements
  | Rvalue "," ArrayLiteralElements
    << dsl.PrependChild(
      $2,
      $0,
    ) >>
;

// ================================================================
// Map literals in Miller are JSON-ish.

MlrvalOrFunction : MapLiteral ;

// ----------------------------------------------------------------
MapLiteral

  : "{" "}"
    << dsl.NewASTNodeZary(
      dsl.NewASTToken("{}", $0),
      dsl.NodeTypeMapLiteral,
    ) >>

  | "{" MapLiteralKeyValuePairs "}"
    // As parsed there's an intermediate node between MapLiteral
    // and the children. Now we can remove it.
    //
    // Before:
    // * MapLiteral "{}"
    //     * MapLiteral
    //         * MapLiteralKeyValuePair ":"
    //             * StringLiteral "a"
    //             * StringLiteral "1"
    //         * MapLiteralKeyValuePair ":"
    //             * StringLiteral "b"
    //             * IntLiteral "2"
    //
    // After:
    // * MapLiteral "{}"
    //     * MapLiteralKeyValuePair ":"
    //         * StringLiteral "a"
    //         * StringLiteral "1"
    //     * MapLiteralKeyValuePair ":"
    //         * StringLiteral "b"
    //         * IntLiteral "2"
    << dsl.AdoptChildren(
      dsl.NewASTNodeNestable(
        dsl.NewASTToken("{}", $0),
        dsl.NodeTypeMapLiteral,
      ),
      $1,
    ) >>
;

// ----------------------------------------------------------------
MapLiteralKeyValuePairs

  : MapLiteralKeyValuePair
    << dsl.NewASTNodeUnary(
      nil,
      $0,
      dsl.NodeTypeMapLiteral,
    ) >>

  // Allow trailing final comma, especially for multiline statements
  | MapLiteralKeyValuePair ","
    << dsl.NewASTNodeUnary(
      nil,
      $0,
      dsl.NodeTypeMapLiteral,
    ) >>

  // Allow trailing final comma, especially for multiline statements
  | MapLiteralKeyValuePair "," MapLiteralKeyValuePairs
    << dsl.PrependChild(
      $2,
      $0,
    ) >>
;

// ----------------------------------------------------------------
MapLiteralKeyValuePair
  : Rvalue ":" Rvalue
    << dsl.NewASTNodeBinary(
      $1,
      $0,
      $2,
      dsl.NodeTypeMapLiteralKeyValuePair,
    ) >>
;

// ================================================================
MlrvalOrFunction : ContextVariable ;

ContextVariable
  : md_token_IPS << dsl.NewASTNode($0, dsl.NodeTypeContextVariable) >>
  | md_token_IFS << dsl.NewASTNode($0, dsl.NodeTypeContextVariable) >>
  | md_token_IRS << dsl.NewASTNode($0, dsl.NodeTypeContextVariable) >>

  | md_token_OPS << dsl.NewASTNode($0, dsl.NodeTypeContextVariable) >>
  | md_token_OFS << dsl.NewASTNode($0, dsl.NodeTypeContextVariable) >>
  | md_token_ORS << dsl.NewASTNode($0, dsl.NodeTypeContextVariable) >>

  | md_token_NF  << dsl.NewASTNode($0, dsl.NodeTypeContextVariable) >>
  | md_token_NR  << dsl.NewASTNode($0, dsl.NodeTypeContextVariable) >>
  | md_token_FNR << dsl.NewASTNode($0, dsl.NodeTypeContextVariable) >>

  | md_token_FILENAME << dsl.NewASTNode($0, dsl.NodeTypeContextVariable) >>
  | md_token_FILENUM  << dsl.NewASTNode($0, dsl.NodeTypeContextVariable) >>
;

// ----------------------------------------------------------------
//MlrvalOrFunction(A) ::= EnvIndex(B). {
//	A = B;
//}

//EnvIndex(A) ::= md_token_env(B) "[" Rvalue(C) "]". {
//	A = mlr_dsl_ast_node_alloc_binary("env", MD_AST_NODE_TYPE_ENV, B, C);
//}

// ================================================================
// INDEXED ACCESS
//
// For Array or Map -- which one, to be determined at runtime.

// ----------------------------------------------------------------
MlrvalOrFunction : ArrayOrMapIndexAccess ;

ArrayOrMapIndexAccess
  : MlrvalOrFunction "[" Rvalue "]" 
    << dsl.NewASTNodeBinary(
      dsl.NewASTToken("[]", $1),
      $0,
      $2,
      dsl.NodeTypeArrayOrMapIndexAccess,
    )>>
;

MlrvalOrFunction : ArraySliceAccess ;

ArraySliceAccess

  : MlrvalOrFunction "[" Rvalue ":" Rvalue "]" 
    << dsl.NewASTNodeTernary(
      dsl.NewASTToken("[]", $1),
      $0,
      $2,
      $4,
      dsl.NodeTypeArraySliceAccess,
    )>>

  | MlrvalOrFunction "[" ":" Rvalue "]" 
    << dsl.NewASTNodeTernary(
      dsl.NewASTToken("[]", $1),
      $0,
      dsl.NewASTNodeNestable(
        $2,
        dsl.NodeTypeArraySliceEmptyLowerIndex,
      ),
      $3,
      dsl.NodeTypeArraySliceAccess,
    )>>

  | MlrvalOrFunction "[" Rvalue ":" "]" 
    << dsl.NewASTNodeTernary(
      dsl.NewASTToken("[]", $1),
      $0,
      $2,
      dsl.NewASTNodeNestable(
        $3,
        dsl.NodeTypeArraySliceEmptyUpperIndex,
      ),
      dsl.NodeTypeArraySliceAccess,
    )>>

  | MlrvalOrFunction "[" ":" "]" 
    << dsl.NewASTNodeTernary(
      dsl.NewASTToken("[]", $1),
      $0,
      dsl.NewASTNodeNestable(
        $2,
        dsl.NodeTypeArraySliceEmptyLowerIndex,
      ),
      dsl.NewASTNodeNestable(
        $2,
        dsl.NodeTypeArraySliceEmptyUpperIndex,
      ),
      dsl.NodeTypeArraySliceAccess,
    )>>
;

// ================================================================
// FUNCTION/SUBROUTINE CALLS

MlrvalOrFunction
  : FcnOrSubrCall
;

FcnOrSubrCall

  : FunctionName "(" ")"
    << dsl.NewASTNodeZary(
      $0,
      dsl.NodeTypeFunctionCallsite,
    ) >>

  | FunctionName "(" FcnArgs ")"
    // As parsed there's an intermediate node between FcnOrSubrCall
    // and the children. Now we can remove it.
    //
    // Before:
    // * FcnOrSubrCall "[]"
    //     * FcnOrSubrCall
    //         * StringLiteral "a"
    //         * StringLiteral "b"
    //
    // After:
    // * FcnOrSubrCall "[]"
    //     * StringLiteral "a"
    //     * StringLiteral "b"
    << dsl.AdoptChildren(
      dsl.NewASTNodeNestable(
        $0,
        dsl.NodeTypeFunctionCallsite,
      ),
      $2,
    ) >>
;

// For most functions it suffices to use the md_token_non_sigil_name pattern.
// But int and float are keywords in the lexer so we need to spell those out
// explicitly.  (They're type-decl keywords but they're also the names of
// type-conversion functions.)
FunctionName
  : md_token_non_sigil_name
  | md_token_int_type
  | md_token_float_type
;

// ----------------------------------------------------------------
FcnArgs

  : Rvalue
    << dsl.NewASTNodeUnary(
      nil,
      $0,
      dsl.NodeTypeFunctionCallsite,
    ) >>

  // Allow trailing final comma, especially for multiline statements
  | Rvalue ","
    << dsl.NewASTNodeUnary(
      nil,
      $0,
      dsl.NodeTypeFunctionCallsite,
    ) >>

  // Allow trailing final comma, especially for multiline statements
  | Rvalue "," FcnArgs
    << dsl.PrependChild(
      $2,
      $0,
    ) >>
;

// ================================================================
// BEGIN/END BLOCKS

BracefulStatement
  : BeginBlock
  | EndBlock
  | CondBlock
  | IfChain
  | WhileLoop
  | ForLoop
  | FuncBlock
  // | SubrBlock
;

BeginBlock
  : md_token_begin StatementBlockInBraces
    << dsl.NewASTNodeUnary(nil, $1, dsl.NodeTypeBeginBlock) >>
;
EndBlock
  : md_token_end StatementBlockInBraces
    << dsl.NewASTNodeUnary(nil, $1, dsl.NodeTypeEndBlock) >>
;
// ================================================================
// AWKISH COND-BLOCKS
// E.g. mlr put 'NR > 10 { ... }'.
// Just shorthand for mlr put 'if (NR > 10) { ... }' without any elif/else.

CondBlock
  := Rvalue StatementBlockInBraces
    << dsl.NewASTNodeBinary(nil, $0, $1, dsl.NodeTypeCondBlock) >>
  ;

// ================================================================
// IF-STATEMENTS

// Cases:
//   if elif*
//   if elif* else

IfChain
  : IfElifStar
  | IfElifStar ElseBlock
    << dsl.AppendChild($0, $1) >>
  ;

IfElifStar
  : IfBlock
    << dsl.NewASTNodeUnary(nil, $0, dsl.NodeTypeIfChain) >>
  | IfElifStar ElifBlock
    << dsl.AppendChild($0, $1) >>
  ;

IfBlock
  : md_token_if "(" Rvalue ")" StatementBlockInBraces
    << dsl.NewASTNodeBinary($0, $2, $4, dsl.NodeTypeIfItem) >>
  ;

ElifBlock
  : md_token_elif "(" Rvalue ")" StatementBlockInBraces
    << dsl.NewASTNodeBinary($0, $2, $4, dsl.NodeTypeIfItem) >>
  ;

ElseBlock
  : md_token_else StatementBlockInBraces
    << dsl.NewASTNodeUnary($0, $1, dsl.NodeTypeIfItem) >>
  ;

// ================================================================
// WHILE AND DO-WHILE -LOOPS

WhileLoop
  : md_token_while "(" Rvalue ")" StatementBlockInBraces
    << dsl.NewASTNodeBinary($0, $2, $4, dsl.NodeTypeWhileLoop) >>
  ;

DoWhileLoop
  : md_token_do StatementBlockInBraces md_token_while "(" Rvalue ")"
    << dsl.NewASTNodeBinary($0, $1, $4, dsl.NodeTypeDoWhileLoop) >>
  ;

// ================================================================
// FOR-LOOPS

// TODO: typedefs on localvars

// ----------------------------------------------------------------
ForLoop
  : ForLoopKeyOnly
  | ForLoopKeyValue
  // | ForLoopMultipleKeysValue
  | TripleForLoop
  ;

// ----------------------------------------------------------------
// for(k in $*) { ... }
ForLoopKeyOnly
  : md_token_for
    "("
		  LocalVariable
		  md_token_in
      Rvalue
	  ")"
 	  StatementBlockInBraces
 <<
   dsl.NewASTNodeTernary(
     $0, // "for"
     $2, // k, etc.
     $4, // $*, etc.
     $6, // { ... }
     dsl.NodeTypeForLoopKeyOnly,
	 );
 >>
;

// ----------------------------------------------------------------
// for(k, v in $*) { ... }
ForLoopKeyValue
  : md_token_for
    "("
		  LocalVariable
      ","
		  LocalVariable
		  md_token_in
      Rvalue
	  ")"
   	StatementBlockInBraces
 <<
   dsl.NewASTNodeQuaternary(
     $0, // "for"
     $2, // k, etc.
     $4, // v, etc.
     $6, // $*, etc.
     $8, // { ... }
     dsl.NodeTypeForLoopKeyValue,
	 );
 >>
;

// ForLoopMultipleKeysValue

//// for((k1, k2), v in @*) { ... }
//// for((k1, k2, k3), v in @*) { ... }
//ForLoopMultipleKeysValue(A) ::=
//	md_token_for(F) "("
//		"(" ForMapKeylist(L) ")" "," LocalVariable(V)
//		md_token_in md_token_full_oosvar
//	")"
//	"{"
//		StatementBlock(S)
//	"}".
//{
//	mlr_dsl_ast_node_replace_text(S, "for_full_oosvar_block");
//	A = mlr_dsl_ast_node_alloc_ternary(
//		F->text,
//		MD_AST_NODE_TYPE_FOR_OOSVAR,
//		mlr_dsl_ast_node_alloc_binary(
//			"key_and_value_variables",
//			MD_AST_NODE_TYPE_FOR_VARIABLES,
//			L,
//			V
//		),
//		mlr_dsl_ast_node_alloc_zary("empty_keylist", MD_AST_NODE_TYPE_OOSVAR_KEYLIST),
//		S
//	);
//}

//ForMapKeylist(A) ::= ForLoopIndex(K). {
//	A = mlr_dsl_ast_node_alloc_unary("key_variables", MD_AST_NODE_TYPE_FOR_VARIABLES, K);
//}
//ForMapKeylist(A) ::= ForMapKeylist(L) "," ForLoopIndex(K). {
//	A = mlr_dsl_ast_node_append_arg(L, K);
//}

// ----------------------------------------------------------------
TripleForLoop
  :
  	md_token_for
    "("
    TripleForStart
    ";"
    TripleForContinuation
    ";"
    TripleForUpdate
  	")"
   	StatementBlockInBraces
 <<
   dsl.NewASTNodeQuaternary(
     $0, // for
     $2, // start
     $4, // continuation
     $6, // update
     $8, // body
     dsl.NodeTypeTripleForLoop,
	 );
 >>
;

TripleForStart
  : empty
    << dsl.NewASTNodeZary(nil, dsl.NodeTypeStatementBlock) >>
  | Assignment
    << dsl.NewASTNodeUnary(nil, $0, dsl.NodeTypeStatementBlock) >>
  | TripleForStart "," Assignment
    <<dsl.AppendChild($0, $2) >>
  ;

TripleForContinuation
  : empty
    << dsl.NewASTNodeZary(nil, dsl.NodeTypeStatementBlock) >>
  | BracelessStatement
    << dsl.NewASTNodeUnary(nil, $0, dsl.NodeTypeStatementBlock) >>
  ;

TripleForUpdate
  : empty
    << dsl.NewASTNodeZary(nil, dsl.NodeTypeStatementBlock) >>
  | Assignment
    << dsl.NewASTNodeUnary(nil, $0, dsl.NodeTypeStatementBlock) >>
  | TripleForUpdate "," Assignment
    <<dsl.AppendChild($0, $2) >>
;

// ----------------------------------------------------------------
BreakStatement
  : md_token_break
    << dsl.NewASTNodeZary($0, dsl.NodeTypeBreak) >>
  ;

ContinueStatement
  : md_token_continue
    << dsl.NewASTNodeZary($0, dsl.NodeTypeContinue) >>
  ;

// ================================================================
// FUNCTION AND SUBROUTINE DEFINITIONS

FuncBlock
  : md_token_func
	  md_token_non_sigil_name
    "("
    FuncOrSubrParameterList
    ")"
    StatementBlockInBraces
  <<
    dsl.NewASTNodeBinary(
      $1,
      $3, // parameter list
      $5, // { ... }
      dsl.NodeTypeFunctionDefinition,
    );
  >>
;

// With return-type annotation
//FuncBlock ::= md_token_func
//	md_token_non_sigil_name(F) "(" FuncOrSubrParameterList(A) ")"
//	md_token_colon Typedecl(M)
//	"{" StatementBlock(B) "}".
//{
//	A = mlr_dsl_ast_node_set_function_name(A, F->text);
//	mlr_dsl_ast_node_replace_text(B, "func_block");
//	C = mlr_dsl_ast_node_alloc_ternary(F->text, MD_AST_NODE_TYPE_FUNC_DEF, A, B, M);
//}

// ----------------------------------------------------------------
//SubrBlock(C) ::= md_token_subr
//	md_token_non_sigil_name(F) "(" FuncOrSubrParameterList(A) ")"
//	"{" StatementBlock(B) "}".
//{
//	A = mlr_dsl_ast_node_set_function_name(A, F->text);
//	mlr_dsl_ast_node_replace_text(B, "subr_block");
//	C = mlr_dsl_ast_node_alloc_binary(F->text, MD_AST_NODE_TYPE_SUBR_DEF, A, B);
//}

// ----------------------------------------------------------------
FuncOrSubrParameterList
  : empty
    << dsl.NewASTNodeZary(nil, dsl.NodeTypeParameterList) >>
  | FuncOrSubrNonEmptyParameterList
    << dsl.Wrap($0) >>
;

FuncOrSubrNonEmptyParameterList
  : FuncOrSubrParameter
    << dsl.NewASTNodeUnary(nil, $0, dsl.NodeTypeParameterList) >>
  | FuncOrSubrParameter ","
    << dsl.NewASTNodeUnary(nil, $0, dsl.NodeTypeParameterList) >>
  | FuncOrSubrParameter "," FuncOrSubrNonEmptyParameterList
    << dsl.PrependChild($2, $0) >>
;

FuncOrSubrParameter
  : FuncOrSubrParameterName
    << dsl.NewASTNodeUnary(nil, $0, dsl.NodeTypeParameter) >>

  // TODO: with typename
  // | Typedecl FuncOrSubrParameterName
  ;

//	A = mlr_dsl_ast_node_alloc(B->text, MD_AST_NODE_TYPE_UNTYPED_PARAMETER_DEFINITION);
//}
//FuncOrSubrParameter(A) ::= Typedecl(T) md_token_non_sigil_name(N). {
//	A = mlr_dsl_ast_node_alloc(N->text, T->type);
//}

// In GOCC this seemingly no-op rule converts the token md_token_non_sigil_name
// to an AST node FuncOrSubrParameterName
FuncOrSubrParameterName
  : md_token_non_sigil_name
    << dsl.NewASTNodeZary($0, dsl.NodeTypeParameterName) >>
  ;

//Statement : md_token_call FcnOrSubrCall(B). {
//	A = mlr_dsl_ast_node_alloc_unary("subr_call", MD_AST_NODE_TYPE_SUBR_CALLSITE, B);
//}

// ----------------------------------------------------------------
// Return statements for user-defined functions and subroutines

ReturnStatement
  // For user-defined functions: return a value
  : md_token_return Rvalue
    << dsl.NewASTNodeUnary($0, $1, dsl.NodeTypeReturn) >>

  // For user-defined subroutines
  // | md_token_return
  //    << dsl.NewASTNodeZary($0, dsl.NodeTypeReturn) >>

  ;

// ================================================================
// ================================================================
// ================================================================
// TO BE PORTED
// ================================================================
// ================================================================
// ================================================================

// ----------------------------------------------------------------
//// Local-variable definitions at the current scope
// xxx make TypedLocalDefinition with subcases for type-literals
//Statement(A) ::= UntypedLocalDefinition(B).    { A = B; }
//Statement(A) ::= TypedLocalDefinition(B).    { A = B; }
//TypedLocalDefinition : {type} ...

// Not valid in begin/end since they refer to srecs:
// xxx enforce that in the AST/CST, not here in the grammar -- much simpler.

//// Valid in begin/end since they don't refer to srecs (although the RHSs might):
//Statement(A) ::= BareBoolean(B).          { A = B; }
//Statement(A) ::= OosvarAssignment(B).     { A = B; }
//Statement(A) ::= FullOosvarAssignment(B). { A = B; }
//Statement(A) ::= md_filter(B).            { A = B; }
//Statement(A) ::= md_unset(B).             { A = B; }

//Statement(A) ::= TeeWrite(B).          { A = B; }
//Statement(A) ::= TeeAppend(B).         { A = B; }
//Statement(A) ::= TeePipe(B).           { A = B; }
//Statement(A) ::= md_emitf(B).          { A = B; }
//Statement(A) ::= EmitfWrite(B).        { A = B; }
//Statement(A) ::= EmitfAppend(B).       { A = B; }
//Statement(A) ::= EmitfPipe(B).         { A = B; }
//Statement(A) ::= md_emitp(B).          { A = B; }
//Statement(A) ::= EmitpWrite(B).        { A = B; }
//Statement(A) ::= EmitpAppend(B).       { A = B; }
//Statement(A) ::= EmitpPipe(B).         { A = B; }
//Statement(A) ::= md_emit(B).           { A = B; }
//Statement(A) ::= EmitWrite(B).         { A = B; }
//Statement(A) ::= EmitAppend(B).        { A = B; }
//Statement(A) ::= EmitPipe(B).          { A = B; }
//Statement(A) ::= EmitpLashed(B).       { A = B; }
//Statement(A) ::= EmitpLashedWrite(B).  { A = B; }
//Statement(A) ::= EmitpLashedAppend(B). { A = B; }
//Statement(A) ::= EmitpLashedPipe(B).   { A = B; }
//Statement(A) ::= EmitLashed(B).        { A = B; }
//Statement(A) ::= EmitLashedWrite(B).   { A = B; }
//Statement(A) ::= EmitLashedAppend(B).  { A = B; }
//Statement(A) ::= EmitLashedPipe(B).    { A = B; }

//Statement(A) ::= DumpWrite(B).    { A = B; }
//Statement(A) ::= DumpAppend(B).   { A = B; }
//Statement(A) ::= DumpPipe(B).     { A = B; }
//Statement(A) ::= md_print(B).     { A = B; }
//Statement(A) ::= md_eprint(B).    { A = B; }
//Statement(A) ::= PrintWrite(B).   { A = B; }
//Statement(A) ::= PrintAppend(B).  { A = B; }
//Statement(A) ::= PrintPipe(B).    { A = B; }
//Statement(A) ::= md_printn(B).    { A = B; }
//Statement(A) ::= md_eprintn(B).   { A = B; }
//Statement(A) ::= PrintnWrite(B).  { A = B; }
//Statement(A) ::= PrintnAppend(B). { A = B; }
//Statement(A) ::= PrintnPipe(B).   { A = B; }

// Valid only within for/while, but we accept them here syntactically and
// reject them in the AST-to-CST conversion, where we can produce much more
// informative error messages:
//Statement(A) ::= md_token_break(O). {
//	A = mlr_dsl_ast_node_alloc(O->text, MD_AST_NODE_TYPE_BREAK);
//}
//Statement(A) ::= md_token_continue(O). {
//	A = mlr_dsl_ast_node_alloc(O->text, MD_AST_NODE_TYPE_CONTINUE);
//}

//Typedecl(A) ::= md_token_var(B).     { A = B; A->type = MD_AST_NODE_TYPE_UNTYPED_PARAMETER_DEFINITION; }
//Typedecl(A) ::= md_token_numeric(B). { A = B; A->type = MD_AST_NODE_TYPE_NUMERIC_PARAMETER_DEFINITION; }
//Typedecl(A) ::= md_token_int(B).     { A = B; A->type = MD_AST_NODE_TYPE_INT_PARAMETER_DEFINITION;     }
//Typedecl(A) ::= md_token_float(B).   { A = B; A->type = MD_AST_NODE_TYPE_FLOAT_PARAMETER_DEFINITION;   }
//Typedecl(A) ::= md_token_string_literal(B).  { A = B; A->type = MD_AST_NODE_TYPE_STRING_PARAMETER_DEFINITION;  }
//Typedecl(A) ::= md_token_boolean(B). { A = B; A->type = MD_AST_NODE_TYPE_BOOLEAN_PARAMETER_DEFINITION; }
//Typedecl(A) ::= md_token_map(B).     { A = B; A->type = MD_AST_NODE_TYPE_MAP_PARAMETER_DEFINITION;     }

//// ----------------------------------------------------------------
//md_filter(A) ::= md_token_filter(O) Rvalue(B). {
//	A = mlr_dsl_ast_node_alloc_unary(O->text, MD_AST_NODE_TYPE_FILTER, B);
//}

//// ----------------------------------------------------------------
//md_unset(A) ::= md_token_unset(O) md_token_all(B). {
//	A = mlr_dsl_ast_node_alloc_unary(O->text, MD_AST_NODE_TYPE_UNSET, B);
//}
//md_unset(A) ::= md_token_unset(O) md_token_full_oosvar(B). {
//	A = mlr_dsl_ast_node_alloc_unary(O->text, MD_AST_NODE_TYPE_UNSET, B);
//}
//md_unset(A) ::= md_token_unset(O) UnsetArgs(B). {
//	A = mlr_dsl_ast_node_set_function_name(B, O->text);
//}
//// Need to invalidate "emit @a," -- use some non-empty-args expr.
//UnsetArgs(A) ::= . {
//	A = mlr_dsl_ast_node_alloc_zary("temp", MD_AST_NODE_TYPE_UNSET);
//}

//UnsetArgs(A) ::= DirectFieldValue(B). {
//	A = mlr_dsl_ast_node_alloc_unary("temp", MD_AST_NODE_TYPE_UNSET, B);
//}
//UnsetArgs(A) ::= IndirectFieldValue(B). {
//	A = mlr_dsl_ast_node_alloc_unary("temp", MD_AST_NODE_TYPE_UNSET, B);
//}
//UnsetArgs(A) ::= PositionalSrecValue(B). {
//	A = mlr_dsl_ast_node_alloc_unary("temp", MD_AST_NODE_TYPE_UNSET, B);
//}
//UnsetArgs(A) ::= md_token_full_srec(B). {
//	A = mlr_dsl_ast_node_alloc_unary("temp", MD_AST_NODE_TYPE_UNSET, B);
//}
//UnsetArgs(A) ::= OosvarKeylist(B). {
//	A = mlr_dsl_ast_node_alloc_unary("temp", MD_AST_NODE_TYPE_UNSET, B);
//}
//UnsetArgs(A) ::= NonindexedLocalVariable(B). {
//	A = mlr_dsl_ast_node_alloc_unary("temp", MD_AST_NODE_TYPE_UNSET, B);
//}
//UnsetArgs(A) ::= IndexedLocalVariable(B). {
//	A = mlr_dsl_ast_node_alloc_unary("temp", MD_AST_NODE_TYPE_UNSET, B);
//}

//UnsetArgs(A) ::= UnsetArgs(B) "," DirectFieldValue(C). {
//	A = mlr_dsl_ast_node_append_arg(B, C);
//}
//UnsetArgs(A) ::= UnsetArgs(B) "," OosvarKeylist(C). {
//	A = mlr_dsl_ast_node_append_arg(B, C);
//}
