// ================================================================
// MILLER DSL GRAMMAR
//
// This is the Miller DSL's BNF grammar, using the gocc tool framework.
//
// The first section is lexical elements and the second section is syntactical
// elements. These are the analogs of lex and yacc, respectively, using a
// classical C/lex/yacc framework -- although for lex/yacc one would have
// separate .l and .y files, whereas here there is a single .bnf file.
//
// Notes:
//
// * Lexical items are either literals inlined within the syntactical section,
//   such as "/", or snake-cased named tokens within the lexical section, such
//   as md_token_field_name.
//
// * Syntactical items are all camel-cased, such as SrecAssignment or MapLiteral.
//
// * This grammar is used to auto-generate Go code, using bin/gocc.
//
// * Everything is delivered in the form of an abstract syntax tree (AST),
//   via <<...>>> code segments within this file's syntactical section, to be
//   processed in hand-written Go code. That code, in turn, turns the AST into
//   a CST (concrete syntax tree) which is what the DSL runtime executes.
//
// * The <<...>> code called by the gocc framework must accept interface{},
//   to be generic, but in practice all arguments end up being token.Token
//   (regcognizable here via string-literals or snake-cased namees) or
//   *miller.dsl.AstNode (recognizable here via camel-cased names).
//
// * Another pattern worth pointing out is that in the gocc framework,
//   return-types from AST methods must be a pair of (interface{}, error),
//   whereas argument going into those same methods are interface{} only.
//   Hence a few methods in the Miller AST API which don't return a pair of
//   interface{}/error since they are meant for nesting as arguments here
//   within this file.
//
// * Please see src/miller/dsl/ast.go for more about what the <<...>>
//   code here is calling.
// ================================================================

// ================================================================
// LEXICAL ELEMENTS
// ================================================================

// ----------------------------------------------------------------
// CHARACTER CLASSES
// ----------------------------------------------------------------

_letter : 'a'-'z' | 'A'-'Z' ;
_decdig : '0'-'9' ;
_hexdig : '0'-'9' | 'a'-'f' | 'A'-'F';
_idchar : _letter | _decdig | '_' ;
!whitespace : ' ' | '\t' | '\n' | '\r' ;

// ----------------------------------------------------------------
// STRING/INT/FLOAT/BOOLEAN LITERALS
// ----------------------------------------------------------------

// Notes on string literals:
// * " isn't included here -- need \" handling to put that inside strings
// * GOCC seems to lack a '[^"] notation ...
_string_literal_element
  : 'A'-'Z' | 'a'-'z' | '0'-'9'
  | ' ' | '!' | '#' | '$' | '%' | '&' | '\'' | '\\'
  | '(' | ')' | '*' | '+' | ',' | '-' | '.' | '/'
  | ':' | ';' | '<' | '=' | '>' | '?' | '@' | '['
  | ']' | '^' | '_' | '`' | '{' | '|' | '}' | '~'
  | '\u0100'-'\U0010FFFF'
;
md_token_string_literal : '"' {_string_literal_element} '"' ;

//\"([^\\\"]|\\.)*\"\i {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_REGEXI);
//	return md_token_regexi;
//}

// Notes on int literals:
// * Leading minus sign is handled via the unary-minus operator, not here.
md_token_int_literal
  : _decdig { _decdig }
  | '0' 'x' _hexdig { _hexdig }
;

// Notes on float literals:
// * Leading minus sign is handled via the unary-minus operator, not here.
// * The various shapes are for scientific notation. Examples:
//   123
//   123.
//   123.4
//   .234
//   1e2
//   1e-2
//   1.2e3 1.e3
//   1.2e-3 1.e-3
//   .2e3
//   .2e-3 1.e-3
_scinotE : 'e' | 'E' ;
md_token_float_literal
  : _decdig { _decdig} '.' { _decdig }
  | _decdig { _decdig}                        _scinotE     _decdig { _decdig}
  | _decdig { _decdig}                        _scinotE '-' _decdig { _decdig}
  | _decdig { _decdig} '.'         { _decdig} _scinotE     _decdig { _decdig}
  | _decdig { _decdig} '.'         { _decdig} _scinotE '-' _decdig { _decdig}
  |         { _decdig} '.' _decdig { _decdig} _scinotE     _decdig { _decdig}
  |         { _decdig} '.' _decdig { _decdig} _scinotE '-' _decdig { _decdig}
;

// Notes on boolean literals:
// * true and false should be defined here rather than as string-literals within
//   the grammar -- this forces them to be keywords, not legal as variable names.
_md_token_true : 't' 'r' 'u' 'e' ;
_md_token_false : 'f' 'a' 'l' 's' 'e';
md_token_boolean_literal : ( _md_token_true | _md_token_false );

// ----------------------------------------------------------------
// MILLER CONTEXT VARIABLES
// ----------------------------------------------------------------

//\"([^\\\"]|\\.)*\" {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_STRING_LITERAL);
//	return md_token_string_literal;
//}

md_token_IPS : 'I' 'P' 'S' ;
md_token_IFS : 'I' 'F' 'S' ;
md_token_IRS : 'I' 'R' 'S' ;

md_token_OPS : 'O' 'P' 'S' ;
md_token_OFS : 'O' 'F' 'S' ;
md_token_ORS : 'O' 'R' 'S' ;

md_token_NF  : 'N' 'F' ;
md_token_NR  : 'N' 'R' ;
md_token_FNR : 'F' 'N' 'R' ;

md_token_FILENAME : 'F' 'I' 'L' 'E' 'N' 'A' 'M' 'E' ;
md_token_FILENUM  : 'F' 'I' 'L' 'E' 'N' 'U' 'M' ;

//"M_PI" {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_CONTEXT_VARIABLE);
//	return md_token_context_variable;
//}
//"M_E" {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_CONTEXT_VARIABLE);
//	return md_token_context_variable;
//}
//"ENV" {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_ENV);
//	return md_token_env;
//}

// ----------------------------------------------------------------
// MILLER KEYWORDS
// ----------------------------------------------------------------

// Notes on keywords:
// * Any new keywords defined here should also be documented
//   in dsl/mlr_dsl_cst.c's mlr_dsl_keyword_usage() et al.
// * true and false (boolean literals) are also keywords, defined above.

//md_token_if       : 'i' 'f' ;
//md_token_elif     : 'e' 'l' 'i' 'f' ;
//md_token_else     : 'e' 'l' 's' 'e' ;
//md_token_do       : 'd' 'o' ;
//md_token_while    : 'w' 'h' 'i' 'l' 'e'  ;
//md_token_for      : 'f' 'o' 'r' ;
//md_token_in       : 'i' 'n' ;
//md_token_break    : 'b' 'r' 'e' 'a' 'k';
//md_token_continue : 'c' 'o' 'n' 't' 'i'  'n'  'u' 'e';
//md_token_filter   : 'f' 'i' 'l' 't' 'e'  'r';

//"unset" {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_UNSET);
//	return md_token_unset;
//}
//"tee" {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_TEE);
//	return md_token_tee;
//}
//"emitf" {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_EMITF);
//	return md_token_emitf;
//}
//"emitp" {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_EMITP);
//	return md_token_emitp;
//}
//"emit" {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_EMIT);
//	return md_token_emit;
//}
//"dump" {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_DUMP);
//	return md_token_dump;
//}
//"edump" {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_EDUMP);
//	return md_token_edump;
//}
//"print" {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_PRINT);
//	return md_token_print;
//}
//"printn" {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_PRINTN);
//	return md_token_printn;
//}
//"eprint" {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_EPRINT);
//	return md_token_eprint;
//}
//"eprintn" {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_EPRINTN);
//	return md_token_eprintn;
//}
//"stdout" {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_STDOUT);
//	return md_token_stdout;
//}
//"stderr" {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_STDERR);
//	return md_token_stderr;
//}

//"func" {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_STRIPPED_AWAY);
//	return md_token_func_def;
//}
//"subr" {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_STRIPPED_AWAY);
//	return md_token_subr_def;
//}
//"call" {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_STRIPPED_AWAY);
//	return md_token_subr_call;
//}
//"return" {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_STRIPPED_AWAY);
//	return md_token_return;
//}
//"begin" {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_STRIPPED_AWAY);
//	return md_token_begin;
//}
//"end" {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_STRIPPED_AWAY);
//	return md_token_end;
//}
//"all" {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_ALL);
//	return md_token_all;
//}

// ----------------------------------------------------------------
// FIELD NAMES, OUT-OF-STREAM VARIABLES, LOCAL VARIABLES
// ----------------------------------------------------------------

// Note: the parser depends on the dollar sign being here. If this is changed,
// that needs to be changed as well.
md_token_field_name : '$' _idchar { _idchar } ;

//\$\* {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_FULL_SREC);
//	return md_token_full_srec;
//}

//\$ {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_STRIPPED_AWAY);
//	return md_token_dollar_sign;
//}

//\$\{([^\}]|\\.)*\} {
//	// Note: the parser depends on the dollar sign being here. If this is changed,
//	// that needs to be changed as well.
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_FIELD_NAME);
//	return md_token_braced_field_name;
//}

//@[a-zA-Z_0-9]+ {
//	// Note: the parser depends on the at-sign being here. If this is changed,
//	// that needs to be changed as well.
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_STRING_LITERAL);
//	return md_token_unbraced_oosvar_name;
//}
//@\{([^\}]|\\.)*\} {
//	// Note: the parser depends on the percent-sign being here. If this is changed,
//	// that needs to be changed as well.
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_STRING_LITERAL);
//	return md_token_braced_oosvar_name;
//}
//\@\* {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_FULL_OOSVAR);
//	return md_token_full_oosvar;
//}

//"map" {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_STRIPPED_AWAY);
//	return md_token_map;
//}
//"var" {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_STRIPPED_AWAY);
//	return md_token_var;
//}
//"num" {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_NUMERIC_LOCAL_DEFINITION);
//	return md_token_numeric;
//}
//"int" {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_INT_LOCAL_DEFINITION);
//	return md_token_int;
//}
//"float" {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_FLOAT_LOCAL_DEFINITION);
//	return md_token_float;
//}
//"bool" {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_BOOLEAN_LOCAL_DEFINITION);
//	return md_token_boolean;
//}
//"str" {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_STRING_LOCAL_DEFINITION);
//	return md_token_string_literal;
//}

//[a-zA-Z_][a-zA-Z_0-9]* {
//	*yyextra = mlr_dsl_ast_node_alloc(yytext, MD_AST_NODE_TYPE_NON_SIGIL_NAME);
//	return md_token_non_sigil_name;
//}



// ================================================================
// SYNTAX ELEMENTS
// ================================================================

// ================================================================
// AST:
// * Parentheses, commas, semicolons, line endings, whitespace are all stripped away
// * Variable names and literal values remain as leaf nodes of the AST
// * = + - * / ** {function names} remain as non-leaf nodes of the AST
//
// CST: See mlr_dsl_cst.c
//
// Note: This parser accepts many things that are invalid, e.g.
// * begin{end{}} -- begin/end not at top level
// * begin{$x=1} -- references to stream records at begin/end
// * break/continue outside of for/while/do-while
// * return outside of a function definition
// * $x=x -- boundvars outside of for-loop variable bindings
//
// All of the above are enforced by the CST builder's semantic-analysis logic,
// which takes this parser's output AST as input.  This is done (a) to keep
// this grammar from being overly complex, and (b) so we can get much more
// informative error messages in C than in Lemon ('syntax error').
//
// The parser hooks all build up an abstract syntax tree specifically for the
// CST builder.  For clearer visuals on what the ASTs look like:
// * See mlr_dsl_cst.c
// * See reg_test/run's filter -v and put -v outputs, e.g. in reg_test/expected/out
// * Do "mlr -n put -v 'your expression goes here'"
// ================================================================

// Import the AST/ASTNode types and functions
<< import "miller/dsl" >>

// TODO: port to gacc
//
//// The caller is expected to provide more context.
//%syntax_error {
//	fprintf(stderr, "mlr DSL: syntax error at \"%s\"\n", TOKEN->text);
//
////	This is confusing and (as is) worse than nothing.
////	Ideally we want to show the position within the input of the syntax error.
////
////	int n = sizeof(yyTokenName) / sizeof(yyTokenName[0]);
////	for (int i = 0; i < n; ++i) {
////			int a = yy_find_shift_action(pparser, (YYCODETYPE)i);
////			if (a < YYNSTATE + YYNRULE) {
////				fprintf(stderr, "Possible token \"%s\"\n", yyTokenName[i]);
////			}
////	}
//
//}

// ================================================================
Root :
  StatementBlock
    <<dsl.NewAST($0) >> ;

StatementBlock
  : Statement
    << dsl.NewASTNodeUnary(nil, $0, dsl.NodeTypeStatementBlock) >>

  | StatementBlock ";"
    // Semicolons are separators, not terminators, in the Miller DSL --
    // most importantly people can say '$x = 3' without '$x = 3;'.
    // However, we do allow trailing semicolons.
    << dsl.Nestable($0) >>

  | StatementBlock ";" Statement
    <<dsl.AppendChild($0, $2) >>
  ;

Statement : StatementInBody ;

// ----------------------------------------------------------------
//// Local-variable definitions at the current scope
//StatementInBody(A) ::= UntypedLocalDefinition(B).    { A = B; }
//StatementInBody(A) ::= NumericLocalDefinition(B).    { A = B; }
//StatementInBody(A) ::= IntLocalDefinition(B).        { A = B; }
//StatementInBody(A) ::= FloatLocalDefinition(B).      { A = B; }
//StatementInBody(A) ::= BooleanLocalDefinition(B).    { A = B; }
//StatementInBody(A) ::= StringLocalDefinition(B).     { A = B; }
//StatementInBody(A) ::= MapLocalDefinition(B).        { A = B; }
//StatementInBody(A) ::= NonindexedLocalAssignment(B). { A = B; }
//StatementInBody(A) ::= IndexedLocalAssignment(B).    { A = B; }

//// For user-defined functions
//StatementInBody(A) ::= md_token_return RHS(B). {
//	A = mlr_dsl_ast_node_alloc_unary("return_value", MD_AST_NODE_TYPE_RETURN_VALUE, B);
//}
//StatementInBody(A) ::= md_token_return MapLiteral(B). {
//	A = mlr_dsl_ast_node_alloc_unary("return_value", MD_AST_NODE_TYPE_RETURN_VALUE, B);
//}
//StatementInBody(A) ::= md_token_return md_token_full_srec(B). {
//	A = mlr_dsl_ast_node_alloc_unary("return_value", MD_AST_NODE_TYPE_RETURN_VALUE, B);
//}
//StatementInBody(A) ::= md_token_return md_token_full_oosvar(B). {
//	A = mlr_dsl_ast_node_alloc_unary("return_value", MD_AST_NODE_TYPE_RETURN_VALUE, B);
//}
//// For user-defined subroutines
//StatementInBody(A) ::= md_token_return. {
//	A = mlr_dsl_ast_node_alloc_zary("return_void", MD_AST_NODE_TYPE_RETURN_VOID);
//}

//// Begin/end
//StatementInBeginOrEnd(A) ::= FuncBlock(B).  { A = B; }
//StatementInBeginOrEnd(A) ::= SubrBlock(B).  { A = B; }
//StatementInBeginOrEnd(A) ::= BeginBlock(B). { A = B; }
//StatementInBeginOrEnd(A) ::= EndBlock(B).   { A = B; }

//// Nested control structures:
//StatementInBeginOrEnd(A) ::= CondBlock(B).                { A = B; }
//StatementInBeginOrEnd(A) ::= WhileBlock(B).               { A = B; }
//StatementInBeginOrEnd(A) ::= ForLoopFullSrec(B).          { A = B; }
//StatementInBeginOrEnd(A) ::= ForLoopFullSrecKeyOnly(B).   { A = B; }
//StatementInBeginOrEnd(A) ::= ForLoopFullOosvar(B).        { A = B; }
//StatementInBeginOrEnd(A) ::= ForLoopFullOosvarKeyOnly(B). { A = B; }
//StatementInBeginOrEnd(A) ::= ForLoopOosvar(B).            { A = B; }
//StatementInBeginOrEnd(A) ::= ForLoopOosvarKeyOnly(B).     { A = B; }
//StatementInBeginOrEnd(A) ::= ForLoopLocalMap(B).          { A = B; }
//StatementInBeginOrEnd(A) ::= ForLoopLocalMapKeyOnly(B).   { A = B; }
//StatementInBeginOrEnd(A) ::= ForLoopMapLiteral(B).        { A = B; }
//StatementInBeginOrEnd(A) ::= ForLoopMapLiteralKeyOnly(B). { A = B; }
//StatementInBeginOrEnd(A) ::= ForLoopFuncRetval(B).        { A = B; }
//StatementInBeginOrEnd(A) ::= ForLoopFuncRetvalKeyOnly(B). { A = B; }
//StatementInBeginOrEnd(A) ::= TripleFor(B).                { A = B; }
//StatementInBeginOrEnd(A) ::= IfChain(B).                  { A = B; }

//StatementInBody(A) ::= md_token_subr_call FcnOrSubrCall(B). {
//	A = mlr_dsl_ast_node_alloc_unary("subr_call", MD_AST_NODE_TYPE_SUBR_CALLSITE, B);
//}

// Not valid in begin/end since they refer to srecs:

StatementInBody : SrecAssignment ;

//StatementInBody(A) ::= SrecIndirectAssignment(B).        { A = B; }
//StatementInBody(A) ::= SrecPositionalNameAssignment(B).  { A = B; }
//StatementInBody(A) ::= SrecPositionalValueAssignment(B). { A = B; }
//StatementInBody(A) ::= OosvarFromFullSrecAssignment(B).  { A = B; }
//StatementInBody(A) ::= FullSrecAssignment(B).            { A = B; }
//StatementInBody(A) ::= EnvAssignment(B).                 { A = B; }

//// Valid in begin/end since they don't refer to srecs (although the RHSs might):
//StatementInBody(A) ::= DoWhileBlock(B).         { A = B; }
//StatementInBody(A) ::= BareBoolean(B).          { A = B; }
//StatementInBody(A) ::= OosvarAssignment(B).     { A = B; }
//StatementInBody(A) ::= FullOosvarAssignment(B). { A = B; }
//StatementInBody(A) ::= md_filter(B).            { A = B; }
//StatementInBody(A) ::= md_unset(B).             { A = B; }

//StatementInBody(A) ::= TeeWrite(B).          { A = B; }
//StatementInBody(A) ::= TeeAppend(B).         { A = B; }
//StatementInBody(A) ::= TeePipe(B).           { A = B; }
//StatementInBody(A) ::= md_emitf(B).          { A = B; }
//StatementInBody(A) ::= EmitfWrite(B).        { A = B; }
//StatementInBody(A) ::= EmitfAppend(B).       { A = B; }
//StatementInBody(A) ::= EmitfPipe(B).         { A = B; }
//StatementInBody(A) ::= md_emitp(B).          { A = B; }
//StatementInBody(A) ::= EmitpWrite(B).        { A = B; }
//StatementInBody(A) ::= EmitpAppend(B).       { A = B; }
//StatementInBody(A) ::= EmitpPipe(B).         { A = B; }
//StatementInBody(A) ::= md_emit(B).           { A = B; }
//StatementInBody(A) ::= EmitWrite(B).         { A = B; }
//StatementInBody(A) ::= EmitAppend(B).        { A = B; }
//StatementInBody(A) ::= EmitPipe(B).          { A = B; }
//StatementInBody(A) ::= EmitpLashed(B).       { A = B; }
//StatementInBody(A) ::= EmitpLashedWrite(B).  { A = B; }
//StatementInBody(A) ::= EmitpLashedAppend(B). { A = B; }
//StatementInBody(A) ::= EmitpLashedPipe(B).   { A = B; }
//StatementInBody(A) ::= EmitLashed(B).        { A = B; }
//StatementInBody(A) ::= EmitLashedWrite(B).   { A = B; }
//StatementInBody(A) ::= EmitLashedAppend(B).  { A = B; }
//StatementInBody(A) ::= EmitLashedPipe(B).    { A = B; }

//StatementInBody(A) ::= md_dump(B).      { A = B; }
//StatementInBody(A) ::= DumpWrite(B).    { A = B; }
//StatementInBody(A) ::= DumpAppend(B).   { A = B; }
//StatementInBody(A) ::= DumpPipe(B).     { A = B; }
//StatementInBody(A) ::= md_edump(B).     { A = B; }
//StatementInBody(A) ::= md_print(B).     { A = B; }
//StatementInBody(A) ::= md_eprint(B).    { A = B; }
//StatementInBody(A) ::= PrintWrite(B).   { A = B; }
//StatementInBody(A) ::= PrintAppend(B).  { A = B; }
//StatementInBody(A) ::= PrintPipe(B).    { A = B; }
//StatementInBody(A) ::= md_printn(B).    { A = B; }
//StatementInBody(A) ::= md_eprintn(B).   { A = B; }
//StatementInBody(A) ::= PrintnWrite(B).  { A = B; }
//StatementInBody(A) ::= PrintnAppend(B). { A = B; }
//StatementInBody(A) ::= PrintnPipe(B).   { A = B; }

// Valid only within for/while, but we accept them here syntactically and
// reject them in the AST-to-CST conversion, where we can produce much more
// informative error messages:
//StatementInBody(A) ::= md_token_break(O). {
//	A = mlr_dsl_ast_node_alloc(O->text, MD_AST_NODE_TYPE_BREAK);
//}
//StatementInBody(A) ::= md_token_continue(O). {
//	A = mlr_dsl_ast_node_alloc(O->text, MD_AST_NODE_TYPE_CONTINUE);
//}

// ================================================================
// Given "f(a,b,c)": since this is a bottom-up parser, we get first the "a",
// then "a,b", then "a,b,c", then finally "f(a,b,c)". So:
// * On the "a" we make a function sub-AST called "anon(a)".
// * On the "b" we append the next argument to get "anon(a,b)".
// * On the "c" we append the next argument to get "anon(a,b,c)".
// * On the "f" we change the function name to get "f(a,b,c)".

//FuncBlock(C) ::= md_token_func_def
//	md_token_non_sigil_name(F) "(" FuncOrSubrParameterList(A) ")"
//	"{" StatementBlock(B) "}".
//{
//	A = mlr_dsl_ast_node_set_function_name(A, F->text);
//	mlr_dsl_ast_node_replace_text(B, "func_block");
//	C = mlr_dsl_ast_node_alloc_binary(F->text, MD_AST_NODE_TYPE_FUNC_DEF, A, B);
//}

//FuncBlock(C) ::= md_token_func_def
//	md_token_non_sigil_name(F) "(" FuncOrSubrParameterList(A) ")"
//	md_token_colon Typedecl(M)
//	"{" StatementBlock(B) "}".
//{
//	A = mlr_dsl_ast_node_set_function_name(A, F->text);
//	mlr_dsl_ast_node_replace_text(B, "func_block");
//	C = mlr_dsl_ast_node_alloc_ternary(F->text, MD_AST_NODE_TYPE_FUNC_DEF, A, B, M);
//}

//SubrBlock(C) ::= md_token_subr_def
//	md_token_non_sigil_name(F) "(" FuncOrSubrParameterList(A) ")"
//	"{" StatementBlock(B) "}".
//{
//	A = mlr_dsl_ast_node_set_function_name(A, F->text);
//	mlr_dsl_ast_node_replace_text(B, "subr_block");
//	C = mlr_dsl_ast_node_alloc_binary(F->text, MD_AST_NODE_TYPE_SUBR_DEF, A, B);
//}

//FuncOrSubrParameterList(A) ::= . {
//	A = mlr_dsl_ast_node_alloc_zary("anon", MD_AST_NODE_TYPE_NON_SIGIL_NAME);
//}
//FuncOrSubrParameterList(A) ::= FuncOrSubrNonEmptyParameterList(B). {
//	A = B;
//}
//FuncOrSubrNonEmptyParameterList(A) ::= FuncOrSubrParameter(B). {
//	A = mlr_dsl_ast_node_alloc_unary("anon", MD_AST_NODE_TYPE_NON_SIGIL_NAME, B);
//}
//FuncOrSubrNonEmptyParameterList(A) ::= FuncOrSubrParameter(B) ",". {
//	A = mlr_dsl_ast_node_alloc_unary("anon", MD_AST_NODE_TYPE_NON_SIGIL_NAME, B);
//}
//FuncOrSubrNonEmptyParameterList(A) ::= FuncOrSubrParameter(B) ","
//	FuncOrSubrNonEmptyParameterList(C).
//{
//	A = mlr_dsl_ast_node_prepend_arg(C, B);
//}

//FuncOrSubrParameter(A) ::= md_token_non_sigil_name(B). {
//	A = mlr_dsl_ast_node_alloc(B->text, MD_AST_NODE_TYPE_UNTYPED_PARAMETER_DEFINITION);
//}
//FuncOrSubrParameter(A) ::= Typedecl(T) md_token_non_sigil_name(N). {
//	A = mlr_dsl_ast_node_alloc(N->text, T->type);
//}

//Typedecl(A) ::= md_token_var(B).     { A = B; A->type = MD_AST_NODE_TYPE_UNTYPED_PARAMETER_DEFINITION; }
//Typedecl(A) ::= md_token_numeric(B). { A = B; A->type = MD_AST_NODE_TYPE_NUMERIC_PARAMETER_DEFINITION; }
//Typedecl(A) ::= md_token_int(B).     { A = B; A->type = MD_AST_NODE_TYPE_INT_PARAMETER_DEFINITION;     }
//Typedecl(A) ::= md_token_float(B).   { A = B; A->type = MD_AST_NODE_TYPE_FLOAT_PARAMETER_DEFINITION;   }
//Typedecl(A) ::= md_token_string_literal(B).  { A = B; A->type = MD_AST_NODE_TYPE_STRING_PARAMETER_DEFINITION;  }
//Typedecl(A) ::= md_token_boolean(B). { A = B; A->type = MD_AST_NODE_TYPE_BOOLEAN_PARAMETER_DEFINITION; }
//Typedecl(A) ::= md_token_map(B).     { A = B; A->type = MD_AST_NODE_TYPE_MAP_PARAMETER_DEFINITION;     }

//// ================================================================
//BeginBlock(A) ::= md_token_begin(O) "{" StatementBlock(B) "}". {
//	mlr_dsl_ast_node_replace_text(B, "begin_block");
//	A = mlr_dsl_ast_node_alloc_unary(O->text, MD_AST_NODE_TYPE_BEGIN, B);
//}
//EndBlock(A)   ::= md_token_end(O)   "{" StatementBlock(B) "}". {
//	mlr_dsl_ast_node_replace_text(B, "end_block");
//	A = mlr_dsl_ast_node_alloc_unary(O->text, MD_AST_NODE_TYPE_END, B);
//}

//// ----------------------------------------------------------------
//CondBlock(A) ::= RHS(B) "{" StatementBlock(C) "}". {
//	mlr_dsl_ast_node_replace_text(C, "cond_block");
//	A = mlr_dsl_ast_node_alloc_binary("cond", MD_AST_NODE_TYPE_CONDITIONAL_BLOCK, B, C);
//}

//// ----------------------------------------------------------------
//WhileBlock(A) ::=
//	md_token_while(O)
//		"(" RHS(B) ")"
//		"{" StatementBlock(C) "}".
//{
//	mlr_dsl_ast_node_replace_text(C, "while_block");
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_WHILE, B, C);
//}

//// ----------------------------------------------------------------
//DoWhileBlock(A) ::=
//	MD_TOKEN_DO(O)
//		"{" StatementBlock(B) "}"
//	md_token_while
//		"(" RHS(C) ")".
//{
//	mlr_dsl_ast_node_replace_text(B, "do_while_block");
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_DO_WHILE, B, C);
//}

//// ----------------------------------------------------------------
//// for(k, v in $*) { ... }
//ForLoopFullSrec(A) ::=
//	md_token_for(F) "("
//		ForLoopIndex(K) "," ForLoopIndex(V)
//		md_token_in md_token_full_srec
//	")"
//	"{"
//		StatementBlock(S)
//	"}".
//{
//	mlr_dsl_ast_node_replace_text(S, "for_full_srec_block");
//	A = mlr_dsl_ast_node_alloc_binary(
//		F->text,
//		MD_AST_NODE_TYPE_FOR_SREC,
//		mlr_dsl_ast_node_alloc_binary(
//			"variables",
//			MD_AST_NODE_TYPE_FOR_VARIABLES,
//			K,
//			V
//		),
//		S
//	);
//}

//// for(k in $*) { ... }
//ForLoopFullSrecKeyOnly(A) ::=
//	md_token_for(F) "("
//		ForLoopIndex(K) md_token_in md_token_full_srec
//	")"
//	"{"
//		StatementBlock(S)
//	"}".
//{
//	mlr_dsl_ast_node_replace_text(S, "for_full_srec_block");
//	A = mlr_dsl_ast_node_alloc_binary(
//		F->text,
//		MD_AST_NODE_TYPE_FOR_SREC_KEY_ONLY,
//		mlr_dsl_ast_node_alloc_unary(
//			"variables",
//			MD_AST_NODE_TYPE_FOR_VARIABLES,
//			K
//		),
//		S
//	);
//}

//// for(k, v in @*) { ... }
//ForLoopFullOosvar(A) ::=
//	md_token_for(F) "("
//		ForLoopIndex(K) "," ForLoopIndex(V)
//		md_token_in md_token_full_oosvar
//	")"
//	"{"
//		StatementBlock(S)
//	"}".
//{
//	mlr_dsl_ast_node_replace_text(S, "for_full_oosvar_block");
//	A = mlr_dsl_ast_node_alloc_ternary(
//		F->text,
//		MD_AST_NODE_TYPE_FOR_OOSVAR,
//		mlr_dsl_ast_node_alloc_binary(
//			"key_and_value_variables",
//			MD_AST_NODE_TYPE_FOR_VARIABLES,
//			mlr_dsl_ast_node_alloc_unary(
//				"key_variables",
//				MD_AST_NODE_TYPE_FOR_VARIABLES,
//				K
//			),
//			V
//		),
//		mlr_dsl_ast_node_alloc_zary("empty_keylist", MD_AST_NODE_TYPE_OOSVAR_KEYLIST),
//		S
//	);
//}

//// for((k1, k2), v in @*) { ... }
//// for((k1, k2, k3), v in @*) { ... }
//ForLoopFullOosvar(A) ::=
//	md_token_for(F) "("
//		"(" ForMapKeylist(L) ")" "," ForLoopIndex(V)
//		md_token_in md_token_full_oosvar
//	")"
//	"{"
//		StatementBlock(S)
//	"}".
//{
//	mlr_dsl_ast_node_replace_text(S, "for_full_oosvar_block");
//	A = mlr_dsl_ast_node_alloc_ternary(
//		F->text,
//		MD_AST_NODE_TYPE_FOR_OOSVAR,
//		mlr_dsl_ast_node_alloc_binary(
//			"key_and_value_variables",
//			MD_AST_NODE_TYPE_FOR_VARIABLES,
//			L,
//			V
//		),
//		mlr_dsl_ast_node_alloc_zary("empty_keylist", MD_AST_NODE_TYPE_OOSVAR_KEYLIST),
//		S
//	);
//}

//// for(k in @*) { ... }
//ForLoopFullOosvarKeyOnly(A) ::=
//	md_token_for(F) "("
//		ForLoopIndex(K)
//		md_token_in
//		md_token_full_oosvar
//	")"
//	"{"
//		StatementBlock(S)
//	"}".
//{
//	mlr_dsl_ast_node_replace_text(S, "for_full_oosvar_block");
//	A = mlr_dsl_ast_node_alloc_ternary(
//		F->text,
//		MD_AST_NODE_TYPE_FOR_OOSVAR_KEY_ONLY,
//		K,
//		mlr_dsl_ast_node_alloc_zary("empty_keylist", MD_AST_NODE_TYPE_OOSVAR_KEYLIST),
//		S
//	);
//}

//// for(k, v in @o[1][2]) { ... }
//ForLoopOosvar(A) ::=
//	md_token_for(F) "("
//		ForLoopIndex(K) "," ForLoopIndex(V)
//		md_token_in OosvarKeylist(O)
//	")"
//	"{"
//		StatementBlock(S)
//	"}".
//{
//	mlr_dsl_ast_node_replace_text(S, "for_loop_oosvar_block");
//	A = mlr_dsl_ast_node_alloc_ternary(
//		F->text,
//		MD_AST_NODE_TYPE_FOR_OOSVAR,
//		mlr_dsl_ast_node_alloc_binary(
//			"key_and_value_variables",
//			MD_AST_NODE_TYPE_FOR_VARIABLES,
//			mlr_dsl_ast_node_alloc_unary(
//				"key_variables",
//				MD_AST_NODE_TYPE_FOR_VARIABLES,
//				K
//			),
//			V
//		),
//		O,
//		S
//	);
//}

//// for((k1, k2), v in @o[1][2]) { ... }
//// for((k1, k2, k3), v in @o[1][2]) { ... }
//ForLoopOosvar(A) ::=
//	md_token_for(F) "("
//		"(" ForMapKeylist(L) ")" "," ForLoopIndex(V)
//		md_token_in OosvarKeylist(O)
//	")"
//	"{"
//		StatementBlock(S)
//	"}".
//{
//	mlr_dsl_ast_node_replace_text(S, "for_loop_oosvar_block");
//	A = mlr_dsl_ast_node_alloc_ternary(
//		F->text,
//		MD_AST_NODE_TYPE_FOR_OOSVAR,
//		mlr_dsl_ast_node_alloc_binary(
//			"key_and_value_variables",
//			MD_AST_NODE_TYPE_FOR_VARIABLES,
//			L,
//			V
//		),
//		O,
//		S
//	);
//}

//ForLoopIndex(A) ::= md_token_non_sigil_name(B). {
//	A = mlr_dsl_ast_node_alloc(B->text, MD_AST_NODE_TYPE_UNTYPED_LOCAL_DEFINITION);
//}
//ForLoopIndex(A) ::= md_token_numeric md_token_non_sigil_name(B). {
//	A = mlr_dsl_ast_node_alloc(B->text, MD_AST_NODE_TYPE_NUMERIC_LOCAL_DEFINITION);
//}
//ForLoopIndex(A) ::= md_token_int md_token_non_sigil_name(B). {
//	A = mlr_dsl_ast_node_alloc(B->text, MD_AST_NODE_TYPE_INT_LOCAL_DEFINITION);
//}
//ForLoopIndex(A) ::= md_token_float md_token_non_sigil_name(B). {
//	A = mlr_dsl_ast_node_alloc(B->text, MD_AST_NODE_TYPE_FLOAT_LOCAL_DEFINITION);
//}
//ForLoopIndex(A) ::= md_token_string_literal md_token_non_sigil_name(B). {
//	A = mlr_dsl_ast_node_alloc(B->text, MD_AST_NODE_TYPE_STRING_LOCAL_DEFINITION);
//}
//ForLoopIndex(A) ::= md_token_boolean md_token_non_sigil_name(B). {
//	A = mlr_dsl_ast_node_alloc(B->text, MD_AST_NODE_TYPE_BOOLEAN_LOCAL_DEFINITION);
//}

//ForMapKeylist(A) ::= ForLoopIndex(K). {
//	A = mlr_dsl_ast_node_alloc_unary("key_variables", MD_AST_NODE_TYPE_FOR_VARIABLES, K);
//}
//ForMapKeylist(A) ::= ForMapKeylist(L) "," ForLoopIndex(K). {
//	A = mlr_dsl_ast_node_append_arg(L, K);
//}

//// for(k in @o[1][2]) { ... }
//ForLoopOosvarKeyOnly(A) ::=
//	md_token_for(F) "("
//		ForLoopIndex(K)
//		md_token_in OosvarKeylist(O)
//	")"
//	"{"
//		StatementBlock(S)
//	"}".
//{
//	mlr_dsl_ast_node_replace_text(S, "for_loop_oosvar_block");
//	A = mlr_dsl_ast_node_alloc_ternary(
//		F->text,
//		MD_AST_NODE_TYPE_FOR_OOSVAR_KEY_ONLY,
//		K,
//		O,
//		S
//	);
//}

//// ----------------------------------------------------------------
//// for(k, v in o[1][2]) { ... }
//ForLoopLocalMap(A) ::=
//	md_token_for(F) "("
//		ForLoopIndex(K) "," ForLoopIndex(V)
//		md_token_in LocalMapKeylist(O)
//	")"
//	"{"
//		StatementBlock(S)
//	"}".
//{
//	mlr_dsl_ast_node_replace_text(S, "for_loop_local_map_block");
//	A = mlr_dsl_ast_node_alloc_ternary(
//		F->text,
//		MD_AST_NODE_TYPE_FOR_LOCAL_MAP,
//		mlr_dsl_ast_node_alloc_binary(
//			"key_and_value_variables",
//			MD_AST_NODE_TYPE_FOR_VARIABLES,
//			mlr_dsl_ast_node_alloc_unary(
//				"key_variables",
//				MD_AST_NODE_TYPE_FOR_VARIABLES,
//				K
//			),
//			V
//		),
//		O,
//		S
//	);
//}

//// for((k1, k2), v in o[1][2]) { ... }
//// for((k1, k2, k3), v in o[1][2]) { ... }
//ForLoopLocalMap(A) ::=
//	md_token_for(F) "("
//		"(" ForMapKeylist(L) ")" "," ForLoopIndex(V)
//		md_token_in LocalMapKeylist(O)
//	")"
//	"{"
//		StatementBlock(S)
//	"}".
//{
//	mlr_dsl_ast_node_replace_text(S, "for_loop_local_map_block");
//	A = mlr_dsl_ast_node_alloc_ternary(
//		F->text,
//		MD_AST_NODE_TYPE_FOR_LOCAL_MAP,
//		mlr_dsl_ast_node_alloc_binary(
//			"key_and_value_variables",
//			MD_AST_NODE_TYPE_FOR_VARIABLES,
//			L,
//			V
//		),
//		O,
//		S
//	);
//}

//// for(k in o[1][2]) { ... }
//ForLoopLocalMapKeyOnly(A) ::=
//	md_token_for(F) "("
//		ForLoopIndex(K)
//		md_token_in LocalMapKeylist(O)
//	")"
//	"{"
//		StatementBlock(S)
//	"}".
//{
//	mlr_dsl_ast_node_replace_text(S, "for_loop_local_map_block");
//	A = mlr_dsl_ast_node_alloc_ternary(
//		F->text,
//		MD_AST_NODE_TYPE_FOR_LOCAL_MAP_KEY_ONLY,
//		K,
//		O,
//		S
//	);
//}

//// ----------------------------------------------------------------
//// for(k, v in o[1][2]) { ... }
//ForLoopMapLiteral(A) ::=
//	md_token_for(F) "("
//		ForLoopIndex(K) "," ForLoopIndex(V)
//		md_token_in MapLiteral(O)
//	")"
//	"{"
//		StatementBlock(S)
//	"}".
//{
//	mlr_dsl_ast_node_replace_text(S, "for_loop_map_literal_block");
//	A = mlr_dsl_ast_node_alloc_ternary(
//		F->text,
//		MD_AST_NODE_TYPE_FOR_MAP_LITERAL,
//		mlr_dsl_ast_node_alloc_binary(
//			"key_and_value_variables",
//			MD_AST_NODE_TYPE_FOR_VARIABLES,
//			mlr_dsl_ast_node_alloc_unary(
//				"key_variables",
//				MD_AST_NODE_TYPE_FOR_VARIABLES,
//				K
//			),
//			V
//		),
//		O,
//		S
//	);
//}

//// for((k1, k2), v in o[1][2]) { ... }
//// for((k1, k2, k3), v in o[1][2]) { ... }
//ForLoopMapLiteral(A) ::=
//	md_token_for(F) "("
//		"(" ForMapKeylist(L) ")" "," ForLoopIndex(V)
//		md_token_in MapLiteral(O)
//	")"
//	"{"
//		StatementBlock(S)
//	"}".
//{
//	mlr_dsl_ast_node_replace_text(S, "for_loop_map_literal_block");
//	A = mlr_dsl_ast_node_alloc_ternary(
//		F->text,
//		MD_AST_NODE_TYPE_FOR_MAP_LITERAL,
//		mlr_dsl_ast_node_alloc_binary(
//			"key_and_value_variables",
//			MD_AST_NODE_TYPE_FOR_VARIABLES,
//			L,
//			V
//		),
//		O,
//		S
//	);
//}

//// for(k in o[1][2]) { ... }
//ForLoopMapLiteralKeyOnly(A) ::=
//	md_token_for(F) "("
//		ForLoopIndex(K)
//		md_token_in MapLiteral(O)
//	")"
//	"{"
//		StatementBlock(S)
//	"}".
//{
//	mlr_dsl_ast_node_replace_text(S, "for_loop_map_literal_block");
//	A = mlr_dsl_ast_node_alloc_ternary(
//		F->text,
//		MD_AST_NODE_TYPE_FOR_MAP_LITERAL_KEY_ONLY,
//		K,
//		O,
//		S
//	);
//}

//// ----------------------------------------------------------------
//// for(k, v in o[1][2]) { ... }
//ForLoopFuncRetval(A) ::=
//	md_token_for(F) "("
//		ForLoopIndex(K) "," ForLoopIndex(V)
//		md_token_in FcnOrSubrCall(O)
//	")"
//	"{"
//		StatementBlock(S)
//	"}".
//{
//	mlr_dsl_ast_node_replace_text(S, "for_loop_func_retval_block");
//	A = mlr_dsl_ast_node_alloc_ternary(
//		F->text,
//		MD_AST_NODE_TYPE_FOR_FUNC_RETVAL,
//		mlr_dsl_ast_node_alloc_binary(
//			"key_and_value_variables",
//			MD_AST_NODE_TYPE_FOR_VARIABLES,
//			mlr_dsl_ast_node_alloc_unary(
//				"key_variables",
//				MD_AST_NODE_TYPE_FOR_VARIABLES,
//				K
//			),
//			V
//		),
//		O,
//		S
//	);
//}

//// for((k1, k2), v in o[1][2]) { ... }
//// for((k1, k2, k3), v in o[1][2]) { ... }
//ForLoopFuncRetval(A) ::=
//	md_token_for(F) "("
//		"(" ForMapKeylist(L) ")" "," ForLoopIndex(V)
//		md_token_in FcnOrSubrCall(O)
//	")"
//	"{"
//		StatementBlock(S)
//	"}".
//{
//	mlr_dsl_ast_node_replace_text(S, "for_loop_func_retval_block");
//	A = mlr_dsl_ast_node_alloc_ternary(
//		F->text,
//		MD_AST_NODE_TYPE_FOR_FUNC_RETVAL,
//		mlr_dsl_ast_node_alloc_binary(
//			"key_and_value_variables",
//			MD_AST_NODE_TYPE_FOR_VARIABLES,
//			L,
//			V
//		),
//		O,
//		S
//	);
//}

//// for(k in o[1][2]) { ... }
//ForLoopFuncRetvalKeyOnly(A) ::=
//	md_token_for(F) "("
//		ForLoopIndex(K)
//		md_token_in FcnOrSubrCall(O)
//	")"
//	"{"
//		StatementBlock(S)
//	"}".
//{
//	mlr_dsl_ast_node_replace_text(S, "for_loop_func_retval_block");
//	A = mlr_dsl_ast_node_alloc_ternary(
//		F->text,
//		MD_AST_NODE_TYPE_FOR_FUNC_RETVAL_KEY_ONLY,
//		K,
//		O,
//		S
//	);
//}

//// ----------------------------------------------------------------
//TripleFor(A) ::=
//	md_token_for(F) "("
//		TripleForStart(S)
//			md_token_semicolon
//		TripleForContinuation(C)
//			md_token_semicolon
//		TripleForUpdate(U)
//	")"
//	"{"
//		StatementBlock(L)
//	"}".
//{
//	mlr_dsl_ast_node_replace_text(L, "triple_for_block");
//	A = mlr_dsl_ast_node_alloc_quaternary(F->text, MD_AST_NODE_TYPE_TRIPLE_FOR, S, C, U, L);
//}

//TripleForStart(A) ::= StatementInBody(B). {
//	if (B->type == MD_AST_NODE_TYPE_NOP) {
//		mlr_dsl_ast_node_free(B);
//		A = mlr_dsl_ast_node_alloc_zary("triple_for_start_statements", MD_AST_NODE_TYPE_STATEMENT_LIST);
//	} else {
//		A = mlr_dsl_ast_node_alloc_unary("triple_for_start_statements", MD_AST_NODE_TYPE_STATEMENT_LIST, B);
//	}
//}
//TripleForStart(A) ::= TripleForStart(B) "," StatementInBody(C). {
//	if (B->type == MD_AST_NODE_TYPE_NOP) {
//		mlr_dsl_ast_node_free(B);
//		A = C;
//	} else {
//		A = mlr_dsl_ast_node_append_arg(B, C);
//	}
//}

//TripleForContinuation(A) ::= StatementInBody(B). {
//	if (B->type == MD_AST_NODE_TYPE_NOP) {
//		mlr_dsl_ast_node_free(B);
//		A = mlr_dsl_ast_node_alloc_zary("triple_for_continuation_statements", MD_AST_NODE_TYPE_STATEMENT_LIST);
//	} else {
//		A = mlr_dsl_ast_node_alloc_unary("triple_for_continuation_statements", MD_AST_NODE_TYPE_STATEMENT_LIST, B);
//	}
//}
//TripleForContinuation(A) ::= TripleForContinuation(B) "," StatementInBody(C). {
//	if (B->type == MD_AST_NODE_TYPE_NOP) {
//		mlr_dsl_ast_node_free(B);
//		A = C;
//	} else {
//		A = mlr_dsl_ast_node_append_arg(B, C);
//	}
//}

//TripleForUpdate(A) ::= StatementInBody(B). {
//	if (B->type == MD_AST_NODE_TYPE_NOP) {
//		mlr_dsl_ast_node_free(B);
//		A = mlr_dsl_ast_node_alloc_zary("triple_for_update_statements", MD_AST_NODE_TYPE_STATEMENT_LIST);
//	} else {
//		A = mlr_dsl_ast_node_alloc_unary("triple_for_update_statements", MD_AST_NODE_TYPE_STATEMENT_LIST, B);
//	}
//}
//TripleForUpdate(A) ::= TripleForUpdate(B) "," StatementInBody(C). {
//	if (B->type == MD_AST_NODE_TYPE_NOP) {
//		mlr_dsl_ast_node_free(B);
//		A = C;
//	} else {
//		A = mlr_dsl_ast_node_append_arg(B, C);
//	}
//}

//// ----------------------------------------------------------------
//// Cases:
////   if elif*
////   if elif* else

//IfChain(A) ::= IfElifStar(B) . {
//	A = B;
//}
//IfChain(A) ::= IfElifStar(B) ElseBlock(C). {
//	A = mlr_dsl_ast_node_append_arg(B, C);
//}
//IfElifStar(A) ::= IfBlock(B). {
//	A = mlr_dsl_ast_node_alloc_unary("if_head", MD_AST_NODE_TYPE_IF_HEAD, B);
//}
//IfElifStar(A) ::= IfElifStar(B) ElifBlock(C). {
//	A = mlr_dsl_ast_node_append_arg(B, C);
//}

//IfBlock(A) ::=
//	md_token_if(O)
//		"(" RHS(B) ")"
//		"{" StatementBlock(C) "}".
//{
//	mlr_dsl_ast_node_replace_text(C, "if_block");
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_IF_ITEM, B, C);
//}

//ElifBlock(A) ::=
//	md_token_elif(O)
//		"(" RHS(B) ")"
//		"{" StatementBlock(C) "}".
//{
//	mlr_dsl_ast_node_replace_text(C, "elif_block");
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_IF_ITEM, B, C);
//}

//ElseBlock(A) ::=
//	md_token_else(O)
//		"{" StatementBlock(C) "}".
//{
//	mlr_dsl_ast_node_replace_text(C, "else_block");
//	A = mlr_dsl_ast_node_alloc_unary(O->text, MD_AST_NODE_TYPE_IF_ITEM, C);
//}

//// ----------------------------------------------------------------
//BareBoolean(A) ::= RHS(B). {
//	A = B;
//}

//// ----------------------------------------------------------------
//md_filter(A) ::= md_token_filter(O) RHS(B). {
//	A = mlr_dsl_ast_node_alloc_unary(O->text, MD_AST_NODE_TYPE_FILTER, B);
//}

//// ----------------------------------------------------------------
//UntypedLocalDefinition(A) ::= md_token_var(T) NonindexedLocalVariable(N) "=" RHS(B). {
//	A = mlr_dsl_ast_node_alloc_binary(T->text, MD_AST_NODE_TYPE_UNTYPED_LOCAL_DEFINITION, N, B);
//}
//UntypedLocalDefinition(A) ::= md_token_var(T) NonindexedLocalVariable(N) "=" md_token_full_srec(B). {
//	A = mlr_dsl_ast_node_alloc_binary(T->text, MD_AST_NODE_TYPE_UNTYPED_LOCAL_DEFINITION, N, B);
//}
//UntypedLocalDefinition(A) ::= md_token_var(T) NonindexedLocalVariable(N) "=" md_token_full_oosvar(B). {
//	A = mlr_dsl_ast_node_alloc_binary(T->text, MD_AST_NODE_TYPE_UNTYPED_LOCAL_DEFINITION, N, B);
//}
//UntypedLocalDefinition(A) ::= md_token_var(T) NonindexedLocalVariable(N) "=" MapLiteral(C). {
//	A = mlr_dsl_ast_node_alloc_binary(T->text, MD_AST_NODE_TYPE_MAP_LOCAL_DEFINITION, N, C);
//}

//NumericLocalDefinition(A) ::= md_token_numeric(T) NonindexedLocalVariable(N) "=" RHS(B). {
//	A = mlr_dsl_ast_node_alloc_binary(T->text, MD_AST_NODE_TYPE_NUMERIC_LOCAL_DEFINITION, N, B);
//}
//IntLocalDefinition(A) ::= md_token_int(T) NonindexedLocalVariable(N) "=" RHS(B). {
//	A = mlr_dsl_ast_node_alloc_binary(T->text, MD_AST_NODE_TYPE_INT_LOCAL_DEFINITION, N, B);
//}
//FloatLocalDefinition(A) ::= md_token_float(T) NonindexedLocalVariable(N) "=" RHS(B). {
//	A = mlr_dsl_ast_node_alloc_binary(T->text, MD_AST_NODE_TYPE_FLOAT_LOCAL_DEFINITION, N, B);
//}
//BooleanLocalDefinition(A) ::= md_token_boolean(T) NonindexedLocalVariable(N) "=" RHS(B). {
//	A = mlr_dsl_ast_node_alloc_binary(T->text, MD_AST_NODE_TYPE_BOOLEAN_LOCAL_DEFINITION, N, B);
//}
//StringLocalDefinition(A) ::= md_token_string_literal(T) NonindexedLocalVariable(N) "=" RHS(B). {
//	A = mlr_dsl_ast_node_alloc_binary(T->text, MD_AST_NODE_TYPE_STRING_LOCAL_DEFINITION, N, B);
//}

//MapLocalDefinition(A) ::= md_token_map(T) NonindexedLocalVariable(N) "=" MapLiteral(C). {
//	A = mlr_dsl_ast_node_alloc_binary(T->text, MD_AST_NODE_TYPE_MAP_LOCAL_DEFINITION, N, C);
//}
//MapLocalDefinition(A) ::= md_token_map(T) NonindexedLocalVariable(N) "=" md_token_full_srec(C). {
//	A = mlr_dsl_ast_node_alloc_binary(T->text, MD_AST_NODE_TYPE_MAP_LOCAL_DEFINITION, N, C);
//}
//MapLocalDefinition(A) ::= md_token_map(T) NonindexedLocalVariable(N) "=" md_token_full_oosvar(C). {
//	A = mlr_dsl_ast_node_alloc_binary(T->text, MD_AST_NODE_TYPE_MAP_LOCAL_DEFINITION, N, C);
//}
//MapLocalDefinition(A) ::= md_token_map(T) NonindexedLocalVariable(N) "=" RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary(T->text, MD_AST_NODE_TYPE_MAP_LOCAL_DEFINITION, N, C);
//}

//NonindexedLocalAssignment(A)  ::= NonindexedLocalVariable(B) "="(O) RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_NONINDEXED_LOCAL_ASSIGNMENT, B, C);
//}
//IndexedLocalAssignment(A)  ::= IndexedLocalVariable(B) "="(O) RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_INDEXED_LOCAL_ASSIGNMENT, B, C);
//}

//NonindexedLocalAssignment(A)  ::= NonindexedLocalVariable(B) "="(O) MapLiteral(C). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_NONINDEXED_LOCAL_ASSIGNMENT, B, C);
//}
//IndexedLocalAssignment(A)  ::= IndexedLocalVariable(B) "="(O) MapLiteral(C). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_INDEXED_LOCAL_ASSIGNMENT, B, C);
//}

//NonindexedLocalAssignment(A)  ::= NonindexedLocalVariable(B) "="(O) md_token_full_oosvar(C). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_NONINDEXED_LOCAL_ASSIGNMENT, B, C);
//}
//IndexedLocalAssignment(A)  ::= IndexedLocalVariable(B) "="(O) md_token_full_oosvar(C). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_INDEXED_LOCAL_ASSIGNMENT, B, C);
//}

//NonindexedLocalAssignment(A)  ::= NonindexedLocalVariable(B) "="(O) md_token_full_srec(C). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_NONINDEXED_LOCAL_ASSIGNMENT, B, C);
//}
//IndexedLocalAssignment(A)  ::= IndexedLocalVariable(B) "="(O) md_token_full_srec(C). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_INDEXED_LOCAL_ASSIGNMENT, B, C);
//}

//// ----------------------------------------------------------------
// xxx

SrecAssignment : SrecDirectAssignment ;

SrecDirectAssignment
  : FieldName "=" RHS
    << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeSrecDirectAssignment) >> ;

//SrecIndirectAssignment(A)  ::=
//	"$[" RHS "]"
//	"="(O) RHS(C).
//{
//	A = mlr_dsl_ast_node_alloc_binary(
//		O->text,
//		MD_AST_NODE_TYPE_INDIRECT_SREC_ASSIGNMENT,
//		B,
//		C
//	);
//}
//SrecPositionalNameAssignment(A)  ::=
//	"$[["
//			RHS(B)
//		"]]"
//	"="(O) RHS(C).
//{
//	A = mlr_dsl_ast_node_alloc_binary(
//		O->text,
//		MD_AST_NODE_TYPE_POSITIONAL_SREC_NAME_ASSIGNMENT,
//		B,
//		C
//	);
//}
//// '$[[[3]]] = "new"' is shorthand for '$[ $[[3]] ] = "new"'.
//// Note that '$[[3]]' is key at srec position 3 and '$[[[3]]]' is value at srec position 3.
//SrecPositionalValueAssignment(A)  ::=
//	"$[[["
//			RHS(B)
//		"]]]"
//	"="(O) RHS(C).
//{
//	A = mlr_dsl_ast_node_alloc_binary(
//		O->text,
//		MD_AST_NODE_TYPE_INDIRECT_SREC_ASSIGNMENT,
//		mlr_dsl_ast_node_alloc_unary(
//			"positional_srec_field_name",
//			MD_AST_NODE_TYPE_POSITIONAL_SREC_NAME,
//			B
//		),
//		C
//	);
//}

//OosvarAssignment(A)  ::= OosvarKeylist(B) "="(O) RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_OOSVAR_ASSIGNMENT, B, C);
//}

//OosvarAssignment(A)  ::= OosvarKeylist(B) "="(O) MapLiteral(C). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_OOSVAR_ASSIGNMENT, B, C);
//}

//OosvarAssignment(A)  ::= OosvarKeylist(B) "="(O) md_token_full_oosvar(C). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_OOSVAR_ASSIGNMENT, B, C);
//}

//FullOosvarAssignment(A)  ::= md_token_full_oosvar(B) "="(O) RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_FULL_OOSVAR_ASSIGNMENT, B, C);
//}

//FullOosvarAssignment(A)  ::= md_token_full_oosvar(B) "="(O) MapLiteral(C). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_FULL_OOSVAR_ASSIGNMENT, B, C);
//}

//FullOosvarAssignment(A)  ::= md_token_full_oosvar(B) "="(O) md_token_full_oosvar(C). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_FULL_OOSVAR_ASSIGNMENT, B, C);
//}

//FullOosvarAssignment(A)  ::= md_token_full_oosvar(B) "="(O) md_token_full_srec(C). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_FULL_OOSVAR_FROM_FULL_SREC_ASSIGNMENT, B, C);
//}

//FullOosvarAssignment(A)  ::= md_token_full_oosvar(B) "="(O) FcnOrSubrCall(C). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_FULL_OOSVAR_FROM_FULL_SREC_ASSIGNMENT, B, C);
//}

//OosvarFromFullSrecAssignment(A)  ::= OosvarKeylist(B) "="(O) md_token_full_srec(C). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_OOSVAR_FROM_FULL_SREC_ASSIGNMENT, B, C);
//}

//FullSrecAssignment(A)  ::= md_token_full_srec(B) "="(O) RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text,
//		MD_AST_NODE_TYPE_FULL_SREC_ASSIGNMENT, B, C);
//}
//FullSrecAssignment(A)  ::= md_token_full_srec(B) "="(O) MapLiteral(C). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_FULL_SREC_ASSIGNMENT, B, C);
//}
//FullSrecAssignment(A)  ::= md_token_full_srec(B) "="(O) md_token_full_srec(C). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_FULL_SREC_ASSIGNMENT, B, C);
//}
//FullSrecAssignment(A)  ::= md_token_full_srec(B) "="(O) md_token_full_oosvar(C). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_FULL_SREC_ASSIGNMENT, B, C);
//}

//EnvAssignment(A)  ::= EnvIndex(B) "="(O) RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_ENV_ASSIGNMENT, B, C);
//}

// ----------------------------------------------------------------
// xxx awkward factorization -- there will be huge cardinality if this is
// number of assignment operators times number of possible LHSes.

SrecDirectAssignment
  : FieldName "||=" RHS << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeSrecDirectAssignment) >>
  | FieldName "^^=" RHS << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeSrecDirectAssignment) >>
  | FieldName "&&=" RHS << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeSrecDirectAssignment) >>
  | FieldName "|="  RHS << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeSrecDirectAssignment) >>
  | FieldName "^="  RHS << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeSrecDirectAssignment) >>
  | FieldName "&="  RHS << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeSrecDirectAssignment) >>
  | FieldName "<<=" RHS << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeSrecDirectAssignment) >>
  | FieldName ">>=" RHS << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeSrecDirectAssignment) >>
  | FieldName "+="  RHS << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeSrecDirectAssignment) >>
  | FieldName ".="  RHS << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeSrecDirectAssignment) >>
  | FieldName "-="  RHS << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeSrecDirectAssignment) >>
  | FieldName "*="  RHS << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeSrecDirectAssignment) >>
  | FieldName "/="  RHS << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeSrecDirectAssignment) >>
  | FieldName "//=" RHS << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeSrecDirectAssignment) >>
  | FieldName "%="  RHS << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeSrecDirectAssignment) >>
  | FieldName "**=" RHS << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeSrecDirectAssignment) >>
;

//OosvarAssignment(A)  ::= OosvarKeylist(B) md_token_logical_or_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_OOSVAR_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("||", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//OosvarAssignment(A)  ::= OosvarKeylist(B) md_token_logical_xor_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_OOSVAR_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("^^", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//OosvarAssignment(A)  ::= OosvarKeylist(B) md_token_logical_and_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_OOSVAR_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("&&", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//OosvarAssignment(A)  ::= OosvarKeylist(B) md_token_bitwise_or_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_OOSVAR_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("|", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//OosvarAssignment(A)  ::= OosvarKeylist(B) md_token_bitwise_xor_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_OOSVAR_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("^", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//OosvarAssignment(A)  ::= OosvarKeylist(B) md_token_bitwise_and_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_OOSVAR_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("&", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//OosvarAssignment(A)  ::= OosvarKeylist(B) md_token_bitwise_lsh_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_OOSVAR_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("<<", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//OosvarAssignment(A)  ::= OosvarKeylist(B) md_token_bitwise_rsh_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_OOSVAR_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary(">>", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}

//OosvarAssignment(A)  ::= OosvarKeylist(B) md_token_plus_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_OOSVAR_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("+", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//OosvarAssignment(A)  ::= OosvarKeylist(B) md_token_minus_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_OOSVAR_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("-", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//OosvarAssignment(A)  ::= OosvarKeylist(B) MD_TOKEN_DOT_EQUALS RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_OOSVAR_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary(".", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//OosvarAssignment(A)  ::= OosvarKeylist(B) md_token_times_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_OOSVAR_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("*", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//OosvarAssignment(A)  ::= OosvarKeylist(B) md_token_divide_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_OOSVAR_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("/", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//OosvarAssignment(A)  ::= OosvarKeylist(B) md_token_int_divide_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_OOSVAR_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("//", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//OosvarAssignment(A)  ::= OosvarKeylist(B) md_token_mod_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_OOSVAR_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("%", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//OosvarAssignment(A)  ::= OosvarKeylist(B) md_token_pow_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_OOSVAR_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("**", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}

//OosvarAssignment(A)  ::= OosvarKeylist(B) md_token_oplus_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_OOSVAR_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary(".+", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//OosvarAssignment(A)  ::= OosvarKeylist(B) md_token_ominus_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_OOSVAR_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary(".-", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//OosvarAssignment(A)  ::= OosvarKeylist(B) md_token_otimes_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_OOSVAR_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary(".*", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//OosvarAssignment(A)  ::= OosvarKeylist(B) md_token_odivide_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_OOSVAR_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("./", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//OosvarAssignment(A)  ::= OosvarKeylist(B) md_token_int_odivide_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_OOSVAR_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary(".//", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}

//NonindexedLocalAssignment(A)  ::= NonindexedLocalVariable(B) md_token_logical_or_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_NONINDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("||", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//NonindexedLocalAssignment(A)  ::= NonindexedLocalVariable(B) md_token_logical_xor_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_NONINDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("^^", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//NonindexedLocalAssignment(A)  ::= NonindexedLocalVariable(B) md_token_logical_and_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_NONINDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("&&", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//NonindexedLocalAssignment(A)  ::= NonindexedLocalVariable(B) md_token_bitwise_or_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_NONINDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("|", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//NonindexedLocalAssignment(A)  ::= NonindexedLocalVariable(B) md_token_bitwise_xor_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_NONINDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("^", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//NonindexedLocalAssignment(A)  ::= NonindexedLocalVariable(B) md_token_bitwise_and_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_NONINDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("&", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//NonindexedLocalAssignment(A)  ::= NonindexedLocalVariable(B) md_token_bitwise_lsh_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_NONINDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("<<", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//NonindexedLocalAssignment(A)  ::= NonindexedLocalVariable(B) md_token_bitwise_rsh_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_NONINDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary(">>", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}

//NonindexedLocalAssignment(A)  ::= NonindexedLocalVariable(B) md_token_plus_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_NONINDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("+", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//NonindexedLocalAssignment(A)  ::= NonindexedLocalVariable(B) md_token_minus_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_NONINDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("-", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//NonindexedLocalAssignment(A)  ::= NonindexedLocalVariable(B) MD_TOKEN_DOT_EQUALS RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_NONINDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary(".", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//NonindexedLocalAssignment(A)  ::= NonindexedLocalVariable(B) md_token_times_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_NONINDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("*", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//NonindexedLocalAssignment(A)  ::= NonindexedLocalVariable(B) md_token_divide_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_NONINDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("/", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//NonindexedLocalAssignment(A)  ::= NonindexedLocalVariable(B) md_token_int_divide_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_NONINDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("//", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//NonindexedLocalAssignment(A)  ::= NonindexedLocalVariable(B) md_token_mod_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_NONINDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("%", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//NonindexedLocalAssignment(A)  ::= NonindexedLocalVariable(B) md_token_pow_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_NONINDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("**", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}

//NonindexedLocalAssignment(A)  ::= NonindexedLocalVariable(B) md_token_oplus_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_NONINDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary(".+", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//NonindexedLocalAssignment(A)  ::= NonindexedLocalVariable(B) md_token_ominus_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_NONINDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary(".-", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//NonindexedLocalAssignment(A)  ::= NonindexedLocalVariable(B) md_token_otimes_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_NONINDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary(".*", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//NonindexedLocalAssignment(A)  ::= NonindexedLocalVariable(B) md_token_odivide_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_NONINDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("./", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//NonindexedLocalAssignment(A)  ::= NonindexedLocalVariable(B) md_token_int_odivide_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_NONINDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary(".//", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}

//IndexedLocalAssignment(A)  ::= IndexedLocalVariable(B) md_token_logical_or_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_INDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("||", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//IndexedLocalAssignment(A)  ::= IndexedLocalVariable(B) md_token_logical_xor_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_INDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("^^", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//IndexedLocalAssignment(A)  ::= IndexedLocalVariable(B) md_token_logical_and_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_INDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("&&", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//IndexedLocalAssignment(A)  ::= IndexedLocalVariable(B) md_token_bitwise_or_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_INDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("|", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//IndexedLocalAssignment(A)  ::= IndexedLocalVariable(B) md_token_bitwise_xor_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_INDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("^", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//IndexedLocalAssignment(A)  ::= IndexedLocalVariable(B) md_token_bitwise_and_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_INDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("&", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//IndexedLocalAssignment(A)  ::= IndexedLocalVariable(B) md_token_bitwise_lsh_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_INDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("<<", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//IndexedLocalAssignment(A)  ::= IndexedLocalVariable(B) md_token_bitwise_rsh_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_INDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary(">>", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}

//IndexedLocalAssignment(A)  ::= IndexedLocalVariable(B) md_token_plus_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_INDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("+", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//IndexedLocalAssignment(A)  ::= IndexedLocalVariable(B) md_token_minus_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_INDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("-", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//IndexedLocalAssignment(A)  ::= IndexedLocalVariable(B) MD_TOKEN_DOT_EQUALS RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_INDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary(".", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//IndexedLocalAssignment(A)  ::= IndexedLocalVariable(B) md_token_times_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_INDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("*", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//IndexedLocalAssignment(A)  ::= IndexedLocalVariable(B) md_token_divide_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_INDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("/", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//IndexedLocalAssignment(A)  ::= IndexedLocalVariable(B) md_token_int_divide_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_INDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("//", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//IndexedLocalAssignment(A)  ::= IndexedLocalVariable(B) md_token_mod_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_INDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("%", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//IndexedLocalAssignment(A)  ::= IndexedLocalVariable(B) md_token_pow_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_INDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("**", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}

//IndexedLocalAssignment(A)  ::= IndexedLocalVariable(B) md_token_oplus_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_INDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary(".+", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//IndexedLocalAssignment(A)  ::= IndexedLocalVariable(B) md_token_ominus_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_INDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary(".-", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//IndexedLocalAssignment(A)  ::= IndexedLocalVariable(B) md_token_otimes_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_INDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary(".*", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//IndexedLocalAssignment(A)  ::= IndexedLocalVariable(B) md_token_odivide_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_INDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("./", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//IndexedLocalAssignment(A)  ::= IndexedLocalVariable(B) md_token_int_odivide_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_INDEXED_LOCAL_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary(".//", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}

//// ----------------------------------------------------------------
//EnvAssignment(A)  ::= EnvIndex(B) md_token_logical_or_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_ENV_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("||", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//EnvAssignment(A)  ::= EnvIndex(B) md_token_logical_xor_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_ENV_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("^^", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//EnvAssignment(A)  ::= EnvIndex(B) md_token_logical_and_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_ENV_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("&&", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//EnvAssignment(A)  ::= EnvIndex(B) md_token_bitwise_or_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_ENV_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("|", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//EnvAssignment(A)  ::= EnvIndex(B) md_token_bitwise_xor_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_ENV_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("^", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//EnvAssignment(A)  ::= EnvIndex(B) md_token_bitwise_and_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_ENV_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("&", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//EnvAssignment(A)  ::= EnvIndex(B) md_token_bitwise_lsh_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_ENV_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("<<", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//EnvAssignment(A)  ::= EnvIndex(B) md_token_bitwise_rsh_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_ENV_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary(">>", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//EnvAssignment(A)  ::= EnvIndex(B) md_token_plus_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_ENV_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("+", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//EnvAssignment(A)  ::= EnvIndex(B) md_token_minus_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_ENV_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("-", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//EnvAssignment(A)  ::= EnvIndex(B) MD_TOKEN_DOT_EQUALS RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_ENV_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary(".", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}

//EnvAssignment(A)  ::= EnvIndex(B) md_token_times_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_ENV_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("*", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//EnvAssignment(A)  ::= EnvIndex(B) md_token_divide_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_ENV_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("/", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//EnvAssignment(A)  ::= EnvIndex(B) md_token_int_divide_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_ENV_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("//", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//EnvAssignment(A)  ::= EnvIndex(B) md_token_mod_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_ENV_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("%", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//EnvAssignment(A)  ::= EnvIndex(B) md_token_pow_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_ENV_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("**", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}

//EnvAssignment(A)  ::= EnvIndex(B) md_token_otimes_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_ENV_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary(".*", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//EnvAssignment(A)  ::= EnvIndex(B) md_token_odivide_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_ENV_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary("./", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//EnvAssignment(A)  ::= EnvIndex(B) md_token_oint_divide_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_ENV_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary(".//", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//EnvAssignment(A)  ::= EnvIndex(B) md_token_omod_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_ENV_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary(".%", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}
//EnvAssignment(A)  ::= EnvIndex(B) md_token_opow_equals RHS(C). {
//	A = mlr_dsl_ast_node_alloc_binary("=", MD_AST_NODE_TYPE_ENV_ASSIGNMENT, B,
//		mlr_dsl_ast_node_alloc_binary(".**", MD_AST_NODE_TYPE_OPERATOR, mlr_dsl_ast_tree_copy(B) , C));
//}

//// ----------------------------------------------------------------
//md_unset(A) ::= md_token_unset(O) md_token_all(B). {
//	A = mlr_dsl_ast_node_alloc_unary(O->text, MD_AST_NODE_TYPE_UNSET, B);
//}
//md_unset(A) ::= md_token_unset(O) md_token_full_oosvar(B). {
//	A = mlr_dsl_ast_node_alloc_unary(O->text, MD_AST_NODE_TYPE_UNSET, B);
//}
//md_unset(A) ::= md_token_unset(O) UnsetArgs(B). {
//	A = mlr_dsl_ast_node_set_function_name(B, O->text);
//}
//// Need to invalidate "emit @a," -- use some non-empty-args expr.
//UnsetArgs(A) ::= . {
//	A = mlr_dsl_ast_node_alloc_zary("temp", MD_AST_NODE_TYPE_UNSET);
//}

//UnsetArgs(A) ::= DirectFieldName(B). {
//	A = mlr_dsl_ast_node_alloc_unary("temp", MD_AST_NODE_TYPE_UNSET, B);
//}
//UnsetArgs(A) ::= IndirectFieldName(B). {
//	A = mlr_dsl_ast_node_alloc_unary("temp", MD_AST_NODE_TYPE_UNSET, B);
//}
//UnsetArgs(A) ::= PositionalSrecName(B). {
//	A = mlr_dsl_ast_node_alloc_unary("temp", MD_AST_NODE_TYPE_UNSET, B);
//}
//UnsetArgs(A) ::= md_token_full_srec(B). {
//	A = mlr_dsl_ast_node_alloc_unary("temp", MD_AST_NODE_TYPE_UNSET, B);
//}
//UnsetArgs(A) ::= OosvarKeylist(B). {
//	A = mlr_dsl_ast_node_alloc_unary("temp", MD_AST_NODE_TYPE_UNSET, B);
//}
//UnsetArgs(A) ::= NonindexedLocalVariable(B). {
//	A = mlr_dsl_ast_node_alloc_unary("temp", MD_AST_NODE_TYPE_UNSET, B);
//}
//UnsetArgs(A) ::= IndexedLocalVariable(B). {
//	A = mlr_dsl_ast_node_alloc_unary("temp", MD_AST_NODE_TYPE_UNSET, B);
//}

//UnsetArgs(A) ::= UnsetArgs(B) "," DirectFieldName(C). {
//	A = mlr_dsl_ast_node_append_arg(B, C);
//}
//UnsetArgs(A) ::= UnsetArgs(B) "," OosvarKeylist(C). {
//	A = mlr_dsl_ast_node_append_arg(B, C);
//}

//// ----------------------------------------------------------------
//TeeWrite(A) ::= md_token_tee(O) md_token_gt OutputFile(F) "," md_token_full_srec(M). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_TEE,
//		mlr_dsl_ast_node_alloc_unary(">", MD_AST_NODE_TYPE_FILE_WRITE, F),
//		M);
//}

//TeeAppend(A) ::= md_token_tee(O) md_token_bitwise_rsh OutputFile(F) "," md_token_full_srec(M). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_TEE,
//		mlr_dsl_ast_node_alloc_unary(">>", MD_AST_NODE_TYPE_FILE_APPEND, F),
//		M);
//}

//TeePipe(A) ::= md_token_tee(O) md_token_bitwise_or RHS(P) "," md_token_full_srec(M). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_TEE,
//		mlr_dsl_ast_node_alloc_unary("|", MD_AST_NODE_TYPE_PIPE, P),
//		M);
//}

//// ----------------------------------------------------------------
//// Given "emitf @a,@b,@c": since this is a bottom-up parser, we get first the "@a",
//// then "@a,@b", then "@a,@b,@c", then finally "emit @a,@b,@c". So:
//// * On the "@a" we make a sub-AST called "temp @a" (although we could call it "emit").
//// * On the "@b" we append the next argument to get "temp @a,@b".
//// * On the "@c" we append the next argument to get "temp @a,@b,@c".
//// * On the "emit" we change the name to get "emit @a,@b,@c".

//md_emitf(A) ::= md_token_emitf(O) EmitfArgs(B). {
//	B = mlr_dsl_ast_node_set_function_name(B, O->text);
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMITF, B,
//		mlr_dsl_ast_node_alloc_zary("stream", MD_AST_NODE_TYPE_STREAM));
//}
//// Need to invalidate "emit @a," -- use some non-empty-args expr.
//EmitfArgs(A) ::= . {
//	A = mlr_dsl_ast_node_alloc_zary("temp", MD_AST_NODE_TYPE_EMITF);
//}
//EmitfArgs(A) ::= OosvarKeylist(B). {
//	A = mlr_dsl_ast_node_alloc_unary("temp", MD_AST_NODE_TYPE_EMITF, B);
//}
//EmitfArgs(A) ::= NonindexedLocalVariable(B). {
//	A = mlr_dsl_ast_node_alloc_unary("temp", MD_AST_NODE_TYPE_EMITF, B);
//}
//EmitfArgs(A) ::= IndexedLocalVariable(B). {
//	A = mlr_dsl_ast_node_alloc_unary("temp", MD_AST_NODE_TYPE_EMITF, B);
//}
//EmitfArgs(A) ::= EmitfArgs(B) "," OosvarKeylist(C). {
//	A = mlr_dsl_ast_node_append_arg(B, C);
//}
//EmitfArgs(A) ::= EmitfArgs(B) "," NonindexedLocalVariable(C). {
//	A = mlr_dsl_ast_node_append_arg(B, C);
//}
//EmitfArgs(A) ::= EmitfArgs(B) "," IndexedLocalVariable(C). {
//	A = mlr_dsl_ast_node_append_arg(B, C);
//}

//EmitfWrite(A) ::= md_token_emitf(O) md_token_gt OutputFile(F) "," EmitfArgs(B). {
//	B = mlr_dsl_ast_node_set_function_name(B, O->text);
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMITF, B,
//		mlr_dsl_ast_node_alloc_unary(">", MD_AST_NODE_TYPE_FILE_WRITE, F));
//}

//EmitfAppend(A) ::= md_token_emitf(O) md_token_bitwise_rsh OutputFile(F) "," EmitfArgs(B). {
//	B = mlr_dsl_ast_node_set_function_name(B, O->text);
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMITF, B,
//		mlr_dsl_ast_node_alloc_unary(">>", MD_AST_NODE_TYPE_FILE_APPEND, F));
//}

//EmitfPipe(A) ::= md_token_emitf(O) md_token_bitwise_or RHS(P) "," EmitfArgs(B). {
//	B = mlr_dsl_ast_node_set_function_name(B, O->text);
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMITF, B,
//		mlr_dsl_ast_node_alloc_unary("|", MD_AST_NODE_TYPE_PIPE, P));
//}


//// ----------------------------------------------------------------
//md_emitp(A) ::= md_token_emitp(O) Emittable(B). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMITP,
//		mlr_dsl_ast_node_alloc_unary(O->text, MD_AST_NODE_TYPE_EMITP, B),
//		mlr_dsl_ast_node_alloc_zary("stream", MD_AST_NODE_TYPE_STREAM));
//}

//md_emitp(A) ::= md_token_emitp(O) Emittable(B) "," EmitpNamelist(C). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMITP,
//		mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMITP, B, C),
//		mlr_dsl_ast_node_alloc_zary("stream", MD_AST_NODE_TYPE_STREAM));
//}

//EmitpWrite(A) ::= md_token_emitp(O) md_token_gt OutputFile(F) ","
//	Emittable(B).
//{
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMITP,
//		mlr_dsl_ast_node_alloc_unary(O->text, MD_AST_NODE_TYPE_EMITP, B),
//		mlr_dsl_ast_node_alloc_unary(">", MD_AST_NODE_TYPE_FILE_WRITE,
//		F));
//}
//EmitpWrite(A) ::= md_token_emitp(O) md_token_gt OutputFile(F) ","
//	Emittable(B) "," EmitpNamelist(C).
//{
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMITP,
//		mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMITP, B, C),
//		mlr_dsl_ast_node_alloc_unary(">", MD_AST_NODE_TYPE_FILE_WRITE,
//		F));
//}

//EmitpAppend(A) ::= md_token_emitp(O) md_token_bitwise_rsh OutputFile(F) ","
//	Emittable(B).
//{
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMITP,
//		mlr_dsl_ast_node_alloc_unary(O->text, MD_AST_NODE_TYPE_EMITP, B),
//		mlr_dsl_ast_node_alloc_unary(">>", MD_AST_NODE_TYPE_FILE_APPEND,
//		F));
//}
//EmitpAppend(A) ::= md_token_emitp(O) md_token_bitwise_rsh OutputFile(F) ","
//	Emittable(B) "," EmitpNamelist(C).
//{
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMITP,
//		mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMITP, B, C),
//		mlr_dsl_ast_node_alloc_unary(">>", MD_AST_NODE_TYPE_FILE_APPEND,
//		F));
//}

//EmitpPipe(A) ::= md_token_emitp(O) md_token_bitwise_or RHS(P) ","
//	Emittable(B).
//{
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMITP,
//		mlr_dsl_ast_node_alloc_unary(O->text, MD_AST_NODE_TYPE_EMITP, B),
//		mlr_dsl_ast_node_alloc_unary("|", MD_AST_NODE_TYPE_PIPE,
//		P));
//}
//EmitpPipe(A) ::= md_token_emitp(O) md_token_bitwise_or RHS(P) ","
//	Emittable(B) "," EmitpNamelist(C).
//{
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMITP,
//		mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMITP, B, C),
//		mlr_dsl_ast_node_alloc_unary("|", MD_AST_NODE_TYPE_PIPE,
//		P));
//}

//// ----------------------------------------------------------------
//EmitpNamelist(A) ::= RHS(B). {
//	A = mlr_dsl_ast_node_alloc_unary("emitp_namelist", MD_AST_NODE_TYPE_EMITP, B);
//}
//EmitpNamelist(A) ::= EmitpNamelist(B) "," RHS(C). {
//	A = mlr_dsl_ast_node_append_arg(B, C);
//}

//// ================================================================
//md_emit(A) ::= md_token_emit(O) Emittable(B). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMIT,
//		mlr_dsl_ast_node_alloc_unary(O->text, MD_AST_NODE_TYPE_EMIT, B),
//		mlr_dsl_ast_node_alloc_zary("stream", MD_AST_NODE_TYPE_STREAM));
//}

//md_emit(A) ::= md_token_emit(O) Emittable(B) "," EmitNamelist(C). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMIT,
//		mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMIT, B, C),
//		mlr_dsl_ast_node_alloc_zary("stream", MD_AST_NODE_TYPE_STREAM));
//}


//EmitWrite(A) ::= md_token_emit(O) md_token_gt OutputFile(F) ","
//	Emittable(B).
//{
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMIT,
//		mlr_dsl_ast_node_alloc_unary(O->text, MD_AST_NODE_TYPE_EMIT, B),
//		mlr_dsl_ast_node_alloc_unary(">", MD_AST_NODE_TYPE_FILE_WRITE,
//		F));
//}
//EmitWrite(A) ::= md_token_emit(O) md_token_gt OutputFile(F) ","
//	Emittable(B) "," EmitNamelist(C).
//{
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMIT,
//		mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMIT, B, C),
//		mlr_dsl_ast_node_alloc_unary(">", MD_AST_NODE_TYPE_FILE_WRITE,
//		F));
//}

//EmitAppend(A) ::= md_token_emit(O) md_token_bitwise_rsh OutputFile(F) ","
//	Emittable(B).
//{
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMIT,
//		mlr_dsl_ast_node_alloc_unary(O->text, MD_AST_NODE_TYPE_EMIT, B),
//		mlr_dsl_ast_node_alloc_unary(">>", MD_AST_NODE_TYPE_FILE_APPEND,
//		F));
//}
//EmitAppend(A) ::= md_token_emit(O) md_token_bitwise_rsh OutputFile(F) ","
//	Emittable(B) "," EmitNamelist(C).
//{
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMIT,
//		mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMIT, B, C),
//		mlr_dsl_ast_node_alloc_unary(">>", MD_AST_NODE_TYPE_FILE_APPEND,
//		F));
//}

//EmitPipe(A) ::= md_token_emit(O) md_token_bitwise_or RHS(P) ","
//	Emittable(B).
//{
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMIT,
//		mlr_dsl_ast_node_alloc_unary(O->text, MD_AST_NODE_TYPE_EMIT, B),
//		mlr_dsl_ast_node_alloc_unary("|", MD_AST_NODE_TYPE_PIPE,
//		P));
//}
//EmitPipe(A) ::= md_token_emit(O) md_token_bitwise_or RHS(P) ","
//	Emittable(B) "," EmitNamelist(C).
//{
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMIT,
//		mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMIT, B, C),
//		mlr_dsl_ast_node_alloc_unary("|", MD_AST_NODE_TYPE_PIPE,
//		P));
//}

//// ----------------------------------------------------------------
//Emittable(A) ::= md_token_all(B). {
//	A = B;
//}
//Emittable(A) ::= md_token_full_oosvar(B). {
//	A = B;
//}
//Emittable(A) ::= OosvarKeylist(B). {
//	A = B;
//}
//Emittable(A) ::= NonindexedLocalVariable(B). {
//	A = B;
//}
//Emittable(A) ::= IndexedLocalVariable(B). {
//	A = B;
//}
//Emittable(A) ::= md_token_full_srec(B). {
//	A = B;
//}
//Emittable(A) ::= MapLiteral(B). {
//	A = B;
//}
//Emittable(A) ::= FcnOrSubrCall(B). {
//	A = B;
//}

//// ----------------------------------------------------------------
//EmitNamelist(A) ::= RHS(B). {
//	A = mlr_dsl_ast_node_alloc_unary("emit_namelist", MD_AST_NODE_TYPE_EMIT, B);
//}
//EmitNamelist(A) ::= EmitNamelist(B) "," RHS(C). {
//	A = mlr_dsl_ast_node_append_arg(B, C);
//}

//// ----------------------------------------------------------------
//EmitpLashed(A) ::= md_token_emitp(O)
//	"(" EmitpLashedKeylists(B) ")".
//{
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMITP_LASHED,
//		mlr_dsl_ast_node_alloc_unary(O->text, MD_AST_NODE_TYPE_EMITP_LASHED, B),
//		mlr_dsl_ast_node_alloc_zary("stream", MD_AST_NODE_TYPE_STREAM));
//}
//EmitpLashed(A) ::= md_token_emitp(O)
//	"(" EmitpLashedKeylists(B) ")"
//	"," EmitpLashedNamelist(C).
//{
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMITP_LASHED,
//		mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMITP_LASHED, B, C),
//		mlr_dsl_ast_node_alloc_zary("stream", MD_AST_NODE_TYPE_STREAM));
//}

//EmitpLashedWrite(A) ::= md_token_emitp(O) md_token_gt OutputFile(F) ","
//	"(" EmitpLashedKeylists(B) ")".
//{
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMITP_LASHED,
//		mlr_dsl_ast_node_alloc_unary(O->text, MD_AST_NODE_TYPE_EMITP_LASHED, B),
//		mlr_dsl_ast_node_alloc_unary(">", MD_AST_NODE_TYPE_FILE_WRITE, F));
//}
//EmitpLashedWrite(A) ::= md_token_emitp(O) md_token_gt OutputFile(F) ","
//	"(" EmitpLashedKeylists(B) ")"
//	"," EmitpLashedNamelist(C).
//{
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMITP_LASHED,
//		mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMITP_LASHED, B, C),
//		mlr_dsl_ast_node_alloc_unary(">", MD_AST_NODE_TYPE_FILE_WRITE, F));
//}

//EmitpLashedAppend(A) ::= md_token_emitp(O) md_token_bitwise_rsh OutputFile(F) ","
//	"(" EmitpLashedKeylists(B) ")".
//{
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMITP_LASHED,
//		mlr_dsl_ast_node_alloc_unary(O->text, MD_AST_NODE_TYPE_EMITP_LASHED, B),
//		mlr_dsl_ast_node_alloc_unary(">>", MD_AST_NODE_TYPE_FILE_APPEND, F));
//}
//EmitpLashedAppend(A) ::= md_token_emitp(O) md_token_bitwise_rsh OutputFile(F) ","
//	"(" EmitpLashedKeylists(B) ")"
//	"," EmitpLashedNamelist(C).
//{
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMITP_LASHED,
//		mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMITP_LASHED, B, C),
//		mlr_dsl_ast_node_alloc_unary(">>", MD_AST_NODE_TYPE_FILE_APPEND, F));
//}

//EmitpLashedPipe(A) ::= md_token_emitp(O) md_token_bitwise_or RHS(P) ","
//	"(" EmitpLashedKeylists(B) ")".
//{
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMITP_LASHED,
//		mlr_dsl_ast_node_alloc_unary(O->text, MD_AST_NODE_TYPE_EMITP_LASHED, B),
//		mlr_dsl_ast_node_alloc_unary("|", MD_AST_NODE_TYPE_PIPE, P));
//}
//EmitpLashedPipe(A) ::= md_token_emitp(O) md_token_bitwise_or RHS(P) ","
//	"(" EmitpLashedKeylists(B) ")"
//	"," EmitpLashedNamelist(C).
//{
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMITP_LASHED,
//		mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMITP_LASHED, B, C),
//		mlr_dsl_ast_node_alloc_unary("|", MD_AST_NODE_TYPE_PIPE, P));
//}

////  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//EmitpLashedKeylists(A) ::= Emittable(B). {
//	A = mlr_dsl_ast_node_alloc_unary("lashed_keylists", MD_AST_NODE_TYPE_EMITP_LASHED, B);
//}
//EmitpLashedKeylists(A) ::= EmitpLashedKeylists(B) "," Emittable(C). {
//	A = mlr_dsl_ast_node_append_arg(B, C);
//}

////  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//EmitpLashedNamelist(A) ::= RHS(B). {
//	A = mlr_dsl_ast_node_alloc_unary("lashed_namelist", MD_AST_NODE_TYPE_EMITP_LASHED, B);
//}
//EmitpLashedNamelist(A) ::= EmitpLashedNamelist(B) "," RHS(C). {
//	A = mlr_dsl_ast_node_append_arg(B, C);
//}

//// ----------------------------------------------------------------
//EmitLashed(A) ::= md_token_emit(O)
//	"(" EmitLashedKeylists(B) ")".
//{
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMIT_LASHED,
//		mlr_dsl_ast_node_alloc_unary(O->text, MD_AST_NODE_TYPE_EMIT_LASHED, B),
//		mlr_dsl_ast_node_alloc_zary("stream", MD_AST_NODE_TYPE_STREAM));
//}
//EmitLashed(A) ::= md_token_emit(O)
//	"(" EmitLashedKeylists(B) ")"
//	"," EmitLashedNamelist(C).
//{
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMIT_LASHED,
//		mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMIT_LASHED, B, C),
//		mlr_dsl_ast_node_alloc_zary("stream", MD_AST_NODE_TYPE_STREAM));
//}

//EmitLashedWrite(A) ::= md_token_emit(O) md_token_gt OutputFile(F) ","
//	"(" EmitLashedKeylists(B) ")".
//{
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMIT_LASHED,
//		mlr_dsl_ast_node_alloc_unary(O->text, MD_AST_NODE_TYPE_EMIT_LASHED, B),
//		mlr_dsl_ast_node_alloc_unary(">", MD_AST_NODE_TYPE_FILE_WRITE, F));
//}
//EmitLashedWrite(A) ::= md_token_emit(O) md_token_gt OutputFile(F) ","
//	"(" EmitLashedKeylists(B) ")"
//	"," EmitLashedNamelist(C).
//{
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMIT_LASHED,
//		mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMIT_LASHED, B, C),
//		mlr_dsl_ast_node_alloc_unary(">", MD_AST_NODE_TYPE_FILE_WRITE, F));
//}

//EmitLashedAppend(A) ::= md_token_emit(O) md_token_bitwise_rsh OutputFile(F) ","
//	"(" EmitLashedKeylists(B) ")".
//{
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMIT_LASHED,
//		mlr_dsl_ast_node_alloc_unary(O->text, MD_AST_NODE_TYPE_EMIT_LASHED, B),
//		mlr_dsl_ast_node_alloc_unary(">>", MD_AST_NODE_TYPE_FILE_APPEND, F));
//}
//EmitLashedAppend(A) ::= md_token_emit(O) md_token_bitwise_rsh OutputFile(F) ","
//	"(" EmitLashedKeylists(B) ")"
//	"," EmitLashedNamelist(C).
//{
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMIT_LASHED,
//		mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMIT_LASHED, B, C),
//		mlr_dsl_ast_node_alloc_unary(">>", MD_AST_NODE_TYPE_FILE_APPEND, F));
//}

//EmitLashedPipe(A) ::= md_token_emit(O) md_token_bitwise_or RHS(P) ","
//	"(" EmitLashedKeylists(B) ")".
//{
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMIT_LASHED,
//		mlr_dsl_ast_node_alloc_unary(O->text, MD_AST_NODE_TYPE_EMIT_LASHED, B),
//		mlr_dsl_ast_node_alloc_unary("|", MD_AST_NODE_TYPE_PIPE, P));
//}
//EmitLashedPipe(A) ::= md_token_emit(O) md_token_bitwise_or RHS(P) ","
//	"(" EmitLashedKeylists(B) ")"
//	"," EmitLashedNamelist(C).
//{
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMIT_LASHED,
//		mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_EMIT_LASHED, B, C),
//		mlr_dsl_ast_node_alloc_unary("|", MD_AST_NODE_TYPE_PIPE, P));
//}

////  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//EmitLashedKeylists(A) ::= Emittable(B). {
//	A = mlr_dsl_ast_node_alloc_unary("lashed_keylists", MD_AST_NODE_TYPE_EMIT_LASHED, B);
//}
//EmitLashedKeylists(A) ::= EmitLashedKeylists(B) "," Emittable(C). {
//	A = mlr_dsl_ast_node_append_arg(B, C);
//}

////  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//EmitLashedNamelist(A) ::= RHS(B). {
//	A = mlr_dsl_ast_node_alloc_unary("lashed_namelist", MD_AST_NODE_TYPE_EMIT_LASHED, B);
//}
//EmitLashedNamelist(A) ::= EmitLashedNamelist(B) "," RHS(C). {
//	A = mlr_dsl_ast_node_append_arg(B, C);
//}

//// ----------------------------------------------------------------
//md_dump(A) ::= md_token_dump(O). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_DUMP,
//		mlr_dsl_ast_node_alloc_unary(">", MD_AST_NODE_TYPE_FILE_WRITE,
//			mlr_dsl_ast_node_alloc_zary("stdout", MD_AST_NODE_TYPE_STDOUT)),
//		mlr_dsl_ast_node_alloc("all", MD_AST_NODE_TYPE_FULL_OOSVAR));
//}
//md_edump(A) ::= md_token_edump(O). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_DUMP,
//		mlr_dsl_ast_node_alloc_unary(">", MD_AST_NODE_TYPE_FILE_WRITE,
//			mlr_dsl_ast_node_alloc_zary("stdout", MD_AST_NODE_TYPE_STDERR)),
//		mlr_dsl_ast_node_alloc("all", MD_AST_NODE_TYPE_FULL_OOSVAR));
//}
//DumpWrite(A) ::= md_token_dump(O) md_token_gt OutputFile(F). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_DUMP,
//		mlr_dsl_ast_node_alloc_unary(">", MD_AST_NODE_TYPE_FILE_WRITE,
//			F),
//		mlr_dsl_ast_node_alloc("all", MD_AST_NODE_TYPE_FULL_OOSVAR));
//}
//DumpAppend(A) ::= md_token_dump(O) md_token_bitwise_rsh OutputFile(F). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_DUMP,
//		mlr_dsl_ast_node_alloc_unary(">>", MD_AST_NODE_TYPE_FILE_APPEND,
//			F),
//		mlr_dsl_ast_node_alloc("all", MD_AST_NODE_TYPE_FULL_OOSVAR));
//}
//DumpPipe(A) ::= md_token_dump(O) md_token_bitwise_or RHS(P). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_DUMP,
//		mlr_dsl_ast_node_alloc_unary("|", MD_AST_NODE_TYPE_PIPE,
//			P),
//		mlr_dsl_ast_node_alloc("all", MD_AST_NODE_TYPE_FULL_OOSVAR));
//}

//md_dump(A) ::= md_token_dump(O) Dumpable(B). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_DUMP,
//		mlr_dsl_ast_node_alloc_unary(">", MD_AST_NODE_TYPE_FILE_WRITE,
//			mlr_dsl_ast_node_alloc_zary("stdout", MD_AST_NODE_TYPE_STDOUT)),
//		B);
//}
//md_edump(A) ::= md_token_edump(O) Dumpable(B). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_DUMP,
//		mlr_dsl_ast_node_alloc_unary(">", MD_AST_NODE_TYPE_FILE_WRITE,
//			mlr_dsl_ast_node_alloc_zary("stdout", MD_AST_NODE_TYPE_STDERR)),
//		B);
//}
//DumpWrite(A) ::= md_token_dump(O) md_token_gt OutputFile(F) Dumpable(B). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_DUMP,
//		mlr_dsl_ast_node_alloc_unary(">", MD_AST_NODE_TYPE_FILE_WRITE,
//			F),
//		B);
//}
//DumpAppend(A) ::= md_token_dump(O) md_token_bitwise_rsh OutputFile(F) Dumpable(B). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_DUMP,
//		mlr_dsl_ast_node_alloc_unary(">>", MD_AST_NODE_TYPE_FILE_APPEND,
//			F),
//		B);
//}
//DumpPipe(A) ::= md_token_dump(O) md_token_bitwise_or Dumpable(P) RHS(B). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_DUMP,
//		mlr_dsl_ast_node_alloc_unary("|", MD_AST_NODE_TYPE_PIPE,
//			P),
//		B);
//}

//// ----------------------------------------------------------------
//Dumpable(A) ::= md_token_all(B). {
//	A = B;
//}
//Dumpable(A) ::= md_token_full_oosvar(B). {
//	A = B;
//}
//Dumpable(A) ::= md_token_full_srec(B). {
//	A = B;
//}
//Dumpable(A) ::= MapLiteral(B). {
//	A = B;
//}
//Dumpable(A) ::= RHS(B). {
//	A = B;
//}

//// ----------------------------------------------------------------
//// Print string
//md_print(A) ::= md_token_print(O) Dumpable(B). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_PRINT, B,
//		mlr_dsl_ast_node_alloc_unary(">", MD_AST_NODE_TYPE_FILE_WRITE,
//			mlr_dsl_ast_node_alloc_zary("stdout", MD_AST_NODE_TYPE_STDOUT)));
//}
//md_eprint(A) ::= md_token_eprint(O) Dumpable(B). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_PRINT, B,
//		mlr_dsl_ast_node_alloc_unary(">", MD_AST_NODE_TYPE_FILE_WRITE,
//			mlr_dsl_ast_node_alloc_zary("stdout", MD_AST_NODE_TYPE_STDERR)));
//}
//PrintWrite(A) ::= md_token_print(O) md_token_gt OutputFile(F) "," Dumpable(C). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_PRINT, C,
//		mlr_dsl_ast_node_alloc_unary(">", MD_AST_NODE_TYPE_FILE_WRITE,
//			F));
//}
//PrintAppend(A) ::= md_token_print(O) md_token_bitwise_rsh OutputFile(F) "," Dumpable(C). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_PRINT, C,
//		mlr_dsl_ast_node_alloc_unary(">>", MD_AST_NODE_TYPE_FILE_APPEND,
//			F));
//}
//PrintPipe(A) ::= md_token_print(O) md_token_bitwise_or RHS(P) "," Dumpable(C). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_PRINT, C,
//		mlr_dsl_ast_node_alloc_unary("|", MD_AST_NODE_TYPE_PIPE,
//			P));
//}

//// Print with no string (newline only)
//md_print(A) ::= md_token_print(O). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_PRINT,
//		mlr_dsl_ast_node_alloc("", MD_AST_NODE_TYPE_NUMERIC_LITERAL),
//		mlr_dsl_ast_node_alloc_unary(">", MD_AST_NODE_TYPE_FILE_WRITE,
//			mlr_dsl_ast_node_alloc_zary("stdout", MD_AST_NODE_TYPE_STDOUT)));
//}
//md_eprint(A) ::= md_token_eprint(O). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_PRINT,
//		mlr_dsl_ast_node_alloc("", MD_AST_NODE_TYPE_NUMERIC_LITERAL),
//		mlr_dsl_ast_node_alloc_unary(">", MD_AST_NODE_TYPE_FILE_WRITE,
//			mlr_dsl_ast_node_alloc_zary("stdout", MD_AST_NODE_TYPE_STDERR)));
//}
//PrintWrite(A) ::= md_token_print(O) md_token_gt OutputFile(F). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_PRINT,
//		mlr_dsl_ast_node_alloc("", MD_AST_NODE_TYPE_NUMERIC_LITERAL),
//		mlr_dsl_ast_node_alloc_unary(">", MD_AST_NODE_TYPE_FILE_WRITE, F));
//}
//PrintAppend(A) ::= md_token_print(O) md_token_bitwise_rsh OutputFile(F). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_PRINT,
//		mlr_dsl_ast_node_alloc("", MD_AST_NODE_TYPE_NUMERIC_LITERAL),
//		mlr_dsl_ast_node_alloc_unary(">>", MD_AST_NODE_TYPE_FILE_APPEND, F));
//}
//PrintPipe(A) ::= md_token_print(O) md_token_bitwise_or RHS(P). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_PRINT,
//		mlr_dsl_ast_node_alloc("", MD_AST_NODE_TYPE_NUMERIC_LITERAL),
//		mlr_dsl_ast_node_alloc_unary("|", MD_AST_NODE_TYPE_PIPE, P));
//}

//// Printn string
//md_printn(A) ::= md_token_printn(O) Dumpable(B). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_PRINTN, B,
//		mlr_dsl_ast_node_alloc_unary(">", MD_AST_NODE_TYPE_FILE_WRITE,
//			mlr_dsl_ast_node_alloc_zary("stdout", MD_AST_NODE_TYPE_STDOUT)));
//}
//md_eprintn(A) ::= md_token_eprintn(O) Dumpable(B). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_PRINTN, B,
//		mlr_dsl_ast_node_alloc_unary(">", MD_AST_NODE_TYPE_FILE_WRITE,
//			mlr_dsl_ast_node_alloc_zary("stdout", MD_AST_NODE_TYPE_STDERR)));
//}
//PrintnWrite(A) ::= md_token_printn(O) md_token_gt OutputFile(F) "," Dumpable(C). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_PRINTN, C,
//		mlr_dsl_ast_node_alloc_unary(">", MD_AST_NODE_TYPE_FILE_WRITE,
//			F));
//}
//PrintnAppend(A) ::= md_token_printn(O) md_token_bitwise_rsh OutputFile(F) "," Dumpable(C). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_PRINTN, C,
//		mlr_dsl_ast_node_alloc_unary(">>", MD_AST_NODE_TYPE_FILE_APPEND,
//			F));
//}
//PrintnPipe(A) ::= md_token_printn(O) md_token_bitwise_or RHS(P) "," Dumpable(C). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_PRINTN, C,
//		mlr_dsl_ast_node_alloc_unary("|", MD_AST_NODE_TYPE_PIPE,
//			P));
//}

//// Printn with no string: produces no output but will create a zero-length
//// output file, so not quite a no-op.
//md_printn(A) ::= md_token_printn(O). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_PRINTN,
//		mlr_dsl_ast_node_alloc("", MD_AST_NODE_TYPE_NUMERIC_LITERAL),
//		mlr_dsl_ast_node_alloc_unary(">", MD_AST_NODE_TYPE_FILE_WRITE,
//			mlr_dsl_ast_node_alloc_zary("stdout", MD_AST_NODE_TYPE_STDOUT)));
//}
//md_eprintn(A) ::= md_token_eprintn(O). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_PRINTN,
//		mlr_dsl_ast_node_alloc("", MD_AST_NODE_TYPE_NUMERIC_LITERAL),
//		mlr_dsl_ast_node_alloc_unary(">", MD_AST_NODE_TYPE_FILE_WRITE,
//			mlr_dsl_ast_node_alloc_zary("stdout", MD_AST_NODE_TYPE_STDERR)));
//}
//PrintnWrite(A) ::= md_token_printn(O) md_token_gt OutputFile(F). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_PRINTN,
//		mlr_dsl_ast_node_alloc("", MD_AST_NODE_TYPE_NUMERIC_LITERAL),
//		mlr_dsl_ast_node_alloc_unary(">", MD_AST_NODE_TYPE_FILE_WRITE, F));
//}
//PrintnAppend(A) ::= md_token_printn(O) md_token_bitwise_rsh OutputFile(F). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_PRINTN,
//		mlr_dsl_ast_node_alloc("", MD_AST_NODE_TYPE_NUMERIC_LITERAL),
//		mlr_dsl_ast_node_alloc_unary(">>", MD_AST_NODE_TYPE_FILE_APPEND, F));
//}
//PrintnPipe(A) ::= md_token_printn(O) md_token_bitwise_or Dumpable(P). {
//	A = mlr_dsl_ast_node_alloc_binary(O->text, MD_AST_NODE_TYPE_PRINTN,
//		mlr_dsl_ast_node_alloc("", MD_AST_NODE_TYPE_NUMERIC_LITERAL),
//		mlr_dsl_ast_node_alloc_unary("|", MD_AST_NODE_TYPE_PIPE, P));
//}

//// ----------------------------------------------------------------
//OutputFile(A) ::= RHS(F).          { A = F; }
//OutputFile(A) ::= md_token_stdout(F). { A = F; }
//OutputFile(A) ::= md_token_stderr(F). { A = F; }

// ================================================================
// Begin RHS operator-precedence chain
// ================================================================

RHS : TernaryTerm ;

// to do: how to pass a "?:" token ...
TernaryTerm
  : LogicalOrTerm "?" TernaryTerm ":" TernaryTerm
    << dsl.NewASTNodeTernary($1, $0, $2, $4, dsl.NodeTypeOperator) >>
  | LogicalOrTerm
;

LogicalOrTerm
  : LogicalOrTerm "||" LogicalXORTerm
    << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | LogicalXORTerm
;

LogicalXORTerm
  : LogicalXORTerm "^^" LogicalAndTerm
    << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | LogicalAndTerm
;

LogicalAndTerm
  : LogicalAndTerm "&&" EqneTerm
    << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | EqneTerm
;

EqneTerm
  : EqneTerm "=~"  CmpTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | EqneTerm "!=~" CmpTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | EqneTerm "=="  CmpTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | EqneTerm "!="  CmpTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | CmpTerm
;

CmpTerm
  : CmpTerm ">"  BitwiseORTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | CmpTerm ">=" BitwiseORTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | CmpTerm "<"  BitwiseORTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | CmpTerm "<=" BitwiseORTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | BitwiseORTerm
;

BitwiseORTerm
  : BitwiseORTerm "|" BitwiseXORTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | BitwiseXORTerm
;

BitwiseXORTerm
  : BitwiseXORTerm "^" BitwiseANDTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | BitwiseANDTerm
;

BitwiseANDTerm
  : BitwiseANDTerm "&" BitwiseShiftTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | BitwiseShiftTerm
;

BitwiseShiftTerm
  : BitwiseShiftTerm "<<" AddsubdotTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | BitwiseShiftTerm ">>" AddsubdotTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | AddsubdotTerm
;

AddsubdotTerm
  : AddsubdotTerm "+"  MuldivTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | AddsubdotTerm "-"  MuldivTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | AddsubdotTerm ".+" MuldivTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | AddsubdotTerm ".-" MuldivTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | AddsubdotTerm "."  MuldivTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | MuldivTerm
;

MuldivTerm
  : MuldivTerm "*"   UnaryBitwiseOpTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | MuldivTerm "/"   UnaryBitwiseOpTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | MuldivTerm "//"  UnaryBitwiseOpTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | MuldivTerm "%"   UnaryBitwiseOpTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | MuldivTerm ".*"  UnaryBitwiseOpTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | MuldivTerm "./"  UnaryBitwiseOpTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | MuldivTerm ".//" UnaryBitwiseOpTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | UnaryBitwiseOpTerm
;

UnaryBitwiseOpTerm
  : "+"  PowTerm << dsl.NewASTNodeUnary($0, $1, dsl.NodeTypeOperator) >>
  | "-"  PowTerm << dsl.NewASTNodeUnary($0, $1, dsl.NodeTypeOperator) >>
  | ".+" PowTerm << dsl.NewASTNodeUnary($0, $1, dsl.NodeTypeOperator) >>
  | ".-" PowTerm << dsl.NewASTNodeUnary($0, $1, dsl.NodeTypeOperator) >>
  | "!"  PowTerm << dsl.NewASTNodeUnary($0, $1, dsl.NodeTypeOperator) >>
  | "~"  PowTerm << dsl.NewASTNodeUnary($0, $1, dsl.NodeTypeOperator) >>
  | PowTerm
;

PowTerm
  : AtomOrFunction "**" PowTerm << dsl.NewASTNodeBinary($1, $0, $2, dsl.NodeTypeOperator) >>
  | AtomOrFunction
;

AtomOrFunction
  : "(" RHS ")"
  << dsl.Nestable($1) >>
;

// ================================================================
// End RHS operator-precedence chain
// ================================================================

// ----------------------------------------------------------------
// xxx to do

// In the grammar provided to the user, field names are of the form "$x".  But
// within Miller internally, field names are of the form "x".  We coded the
// lexer to give us field names with leading "$" so we can confidently strip it
// off here.

AtomOrFunction
  : FieldName
;

FieldName
  : DirectFieldName
  | IndirectFieldName
  //| BracedFieldName
  //| PositionalFieldName
  // ...
;

DirectFieldName
  : md_token_field_name
    << dsl.NewASTNode($0, dsl.NodeTypeDirectFieldName) >>
;

IndirectFieldName
  : "$[" RHS "]"
    << dsl.NewASTNodeUnary($0, $1, dsl.NodeTypeIndirectFieldName) >>
;

//// xxx make a token-wrap constructor in the API
//BracedFieldName
//  : "${" md_token_id "}"
//    << dsl.NewASTNodeUnary(
//      $0,
//      dsl.NewASTNodeNestable($1, dsl.NodeTypeFieldName),
//      dsl.NodeTypeToken,
//    ) >>
//;

//AtomOrFunction(A) ::= PositionalSrecName(B). {
//	A = B;
//}
//PositionalSrecName(A) ::= "$[[" RHS "]]"
//	A = mlr_dsl_ast_node_alloc_unary(
//		"positional_srec_field_name",
//		MD_AST_NODE_TYPE_POSITIONAL_SREC_NAME,
//		B
//	);

//// '$value = $[[[3]]]' is shorthand for '$value = $[ $[[3]] ]'.
//// Note that '$[[3]]' is key at srec position 3 and '$[[[3]]]' is value at srec position 3.
//AtomOrFunction(A) ::= PositionalSrecValue(B). {
//	A = B;
//}
//PositionalSrecValue(A) ::= "$"
//	"[[["
//		RHS(B)
//	"]]].  {
//	A = mlr_dsl_ast_node_alloc_unary(
//		"indirect_field_name",
//		MD_AST_NODE_TYPE_INDIRECT_FIELD_NAME,
//		mlr_dsl_ast_node_alloc_unary(
//			"positional_srec_field_name",
//			MD_AST_NODE_TYPE_POSITIONAL_SREC_NAME,
//			B
//		)
//	);
//}

//// ----------------------------------------------------------------
//AtomOrFunction(A) ::= OosvarKeylist(B). {
//	A = B;
//}

//OosvarKeylist(A) ::= OosvarBasename(B). {
//	A = B;
//}
//OosvarKeylist(A) ::= OosvarKeylist(B) "[" RHS(C) "]". {
//	A = mlr_dsl_ast_node_append_arg(B, C);
//}

//// E.g. @name
//OosvarBasename(A) ::= md_token_unbraced_oosvar_name(B). {
//	char* at_name = B->text;
//	char* no_at_name = &at_name[1];
//	A = mlr_dsl_ast_node_alloc_unary("oosvar_keylist", MD_AST_NODE_TYPE_OOSVAR_KEYLIST,
//		mlr_dsl_ast_node_alloc(no_at_name, B->type));
//}

//// E.g. @{name}
//OosvarBasename(A) ::= md_token_braced_oosvar_name(B). {
//	// Replace "@%{field.name}" with just "field.name"
//	char* at_name = B->text;
//	char* no_at_name = &at_name[2];
//	int len = strlen(no_at_name);
//	if (len > 0)
//		no_at_name[len-1] = 0;
//	A = mlr_dsl_ast_node_alloc_unary("oosvar_keylist", MD_AST_NODE_TYPE_OOSVAR_KEYLIST,
//		mlr_dsl_ast_node_alloc(no_at_name, B->type));
//}

//// E.g. @["name"]
//OosvarBasename(A) ::= md_token_at_sign "[" RHS(B) "]". {
//	A = mlr_dsl_ast_node_alloc_unary("oosvar_keylist", MD_AST_NODE_TYPE_OOSVAR_KEYLIST, B);
//}

//LocalMapKeylist(A) ::= NonindexedLocalVariable(B). {
//	A = B;
//}
//LocalMapKeylist(A) ::= LocalMapKeylist(B) "[" RHS(C) "]". {
//	A = mlr_dsl_ast_node_append_arg(B, C);
//}

// ----------------------------------------------------------------
// xxx split out node-type string vs number so we can track parsed-type through
// to the lrecs, with mlrvals there! :)

AtomOrFunction
  : md_token_string_literal  << dsl.NewASTNode($0, dsl.NodeTypeStringLiteral) >>
  | md_token_int_literal     << dsl.NewASTNode($0, dsl.NodeTypeIntLiteral) >>
  | md_token_float_literal   << dsl.NewASTNode($0, dsl.NodeTypeFloatLiteral) >>
  | md_token_boolean_literal << dsl.NewASTNode($0, dsl.NodeTypeBoolLiteral) >>
;

//AtomOrFunction(A) ::= md_regexi(B). {
//	A = B;
//}

//AtomOrFunction(A) ::= NonindexedLocalVariable(B). {
//	A = B;
//}

//AtomOrFunction(A) ::= IndexedLocalVariable(B). {
//	A = B;
//}

//NonindexedLocalVariable(A) ::= md_token_non_sigil_name(B). {
//	A = mlr_dsl_ast_node_alloc(B->text, MD_AST_NODE_TYPE_NONINDEXED_LOCAL_VARIABLE);
//}

//IndexedLocalVariable(A) ::= NonindexedLocalVariable(B) "[" RHS(C) "]". {
//	A = mlr_dsl_ast_node_alloc_unary(B->text, MD_AST_NODE_TYPE_INDEXED_LOCAL_VARIABLE, C);
//	mlr_dsl_ast_node_free(B);
//}
//IndexedLocalVariable(A) ::= IndexedLocalVariable(B) "[" RHS(C) "]". {
//	A = mlr_dsl_ast_node_append_arg(B, C);
//}

//AtomOrFunction(A) ::= IndexedFunctionCall(B). {
//	A = B;
//}

//// Indexed function calls:
//// * First child node is function call with argument list.
//// * Second child node is list of indexing expressions.
////
//// Example: 'foo(1,2,3)[4][5]' parses to AST
////
//// text="foo", type=INDEXED_FUNCTION_CALLSITE:
////     text="foo", type=FUNCTION_CALLSITE:
////         text="1", type=NUMERIC_LITERAL.
////         text="2", type=NUMERIC_LITERAL.
////         text="3", type=NUMERIC_LITERAL.
////     text="indexing", type=MD_AST_NODE_TYPE_INDEXED_FUNCTION_INDEX_LIST:
////         text="4", type=NUMERIC_LITERAL.
////         text="5", type=NUMERIC_LITERAL.
//IndexedFunctionCall(A) ::= FcnOrSubrCall(B) "[" RHS(C) "]". {
//	A = mlr_dsl_ast_node_alloc_binary(
//		B->text,
//		MD_AST_NODE_TYPE_INDEXED_FUNCTION_CALLSITE,
//		B,
//		mlr_dsl_ast_node_alloc_unary(
//			"indexing",
//			MD_AST_NODE_TYPE_INDEXED_FUNCTION_INDEX_LIST,
//			C
//		)
//	);
//}
//IndexedFunctionCall(A) ::= IndexedFunctionCall(B) "[" RHS(C) "]". {
//	// Append to second child node which is list of indexing expressions.
//	A = mlr_dsl_ast_node_append_arg_to_second_child(B, C);
//}

//md_string(A) ::= md_token_string_literal(B). {
//	char* input = B->text;
//	char* stripped = &input[1];
//	int len = strlen(input);
//	stripped[len-2] = 0;
//	A = mlr_dsl_ast_node_alloc(mlr_alloc_unbackslash(stripped), B->type);
//}
//md_regexi(A) ::= md_token_regexi(B). {
//	char* input = B->text;
//	char* stripped = &input[1];
//	int len = strlen(input);
//	stripped[len-3] = 0;
//	A = mlr_dsl_ast_node_alloc(mlr_alloc_unbackslash(stripped), B->type);
//}

AtomOrFunction : ContextVariable ;

ContextVariable
  : md_token_IPS << dsl.NewASTNode($0, dsl.NodeTypeContextVariable) >>
  | md_token_IFS << dsl.NewASTNode($0, dsl.NodeTypeContextVariable) >>
  | md_token_IRS << dsl.NewASTNode($0, dsl.NodeTypeContextVariable) >>

  | md_token_OPS << dsl.NewASTNode($0, dsl.NodeTypeContextVariable) >>
  | md_token_OFS << dsl.NewASTNode($0, dsl.NodeTypeContextVariable) >>
  | md_token_ORS << dsl.NewASTNode($0, dsl.NodeTypeContextVariable) >>

  | md_token_NF  << dsl.NewASTNode($0, dsl.NodeTypeContextVariable) >>
  | md_token_NR  << dsl.NewASTNode($0, dsl.NodeTypeContextVariable) >>
  | md_token_FNR << dsl.NewASTNode($0, dsl.NodeTypeContextVariable) >>

  | md_token_FILENAME << dsl.NewASTNode($0, dsl.NodeTypeContextVariable) >>
  | md_token_FILENUM  << dsl.NewASTNode($0, dsl.NodeTypeContextVariable) >>
;

//AtomOrFunction(A) ::= EnvIndex(B). {
//	A = B;
//}

//EnvIndex(A) ::= md_token_env(B) "[" RHS(C) "]". {
//	A = mlr_dsl_ast_node_alloc_binary("env", MD_AST_NODE_TYPE_ENV, B, C);
//}

//AtomOrFunction(A) ::= FcnOrSubrCall(B). {
//	A = B;
//}

//// Given "f(a,b,c)": since this is a bottom-up parser, we get first the "a",
//// then "a,b", then "a,b,c", then finally "f(a,b,c)". So:
//// * On the "a" we make a function sub-AST called "anon(a)".
//// * On the "b" we append the next argument to get "anon(a,b)".
//// * On the "c" we append the next argument to get "anon(a,b,c)".
//// * On the "f" we change the function name to get "f(a,b,c)".

//FcnOrSubrCall(A) ::= md_token_non_sigil_name(O) "(" FcnArgList(B) ")". {
//	A = mlr_dsl_ast_node_set_function_name(B, O->text);
//	A->type = MD_AST_NODE_TYPE_FUNCTION_CALLSITE;
//}
//// For most functions it suffices to use the md_token_non_sigil_name pattern. But
//// int and float are keywords in the lexer so we need to spell those out explicitly.
//// (They're type-decl keywords but they're also the names of type-conversion functions.)
//FcnOrSubrCall(A) ::= md_token_int(O) "(" FcnArgList(B) ")". {
//	A = mlr_dsl_ast_node_set_function_name(B, O->text);
//	A->type = MD_AST_NODE_TYPE_FUNCTION_CALLSITE;
//}
//FcnOrSubrCall(A) ::= md_token_float(O) "(" FcnArgList(B) ")". {
//	A = mlr_dsl_ast_node_set_function_name(B, O->text);
//	A->type = MD_AST_NODE_TYPE_FUNCTION_CALLSITE;
//}

//FcnArgList(A) ::= . {
//	A = mlr_dsl_ast_node_alloc_zary("anon", MD_AST_NODE_TYPE_NON_SIGIL_NAME);
//}
//FcnArgList(A) ::= FcnNonEmptyArgList(B). {
//	A = B;
//}

//FcnNonEmptyArgList(A) ::= md_fcn_arg(B). {
//	A = mlr_dsl_ast_node_alloc_unary("anon", MD_AST_NODE_TYPE_NON_SIGIL_NAME, B);
//}
//FcnNonEmptyArgList(A) ::= md_fcn_arg(B) ",". {
//	A = mlr_dsl_ast_node_alloc_unary("anon", MD_AST_NODE_TYPE_NON_SIGIL_NAME, B);
//}
//FcnNonEmptyArgList(A) ::= md_fcn_arg(B) "," FcnNonEmptyArgList(C). {
//	A = mlr_dsl_ast_node_prepend_arg(C, B);
//}

//md_fcn_arg(A) ::= RHS(B). {
//	A = B;
//}
//md_fcn_arg(A) ::= md_token_full_srec(B). {
//	A = B;
//}
//md_fcn_arg(A) ::= md_token_full_oosvar(B). {
//	A = B;
//}
//md_fcn_arg(A) ::= MapLiteral(B). {
//	A = B;
//}

//// ----------------------------------------------------------------
//// Map-literals in Miller are JSON-ish.

//MapLiteral(A) ::= "{" "}". {
//	A = mlr_dsl_ast_node_alloc_zary("map_literal", MD_AST_NODE_TYPE_MAP_LITERAL);
//}
//MapLiteral(A) ::= "{" MapLiteralKeyValuePairs(B) "}". {
//	A = B;
//}
//MapLiteralKeyValuePairs(A) ::= MapLiteralKeyValuePair(B). {
//	A = mlr_dsl_ast_node_alloc_unary("map_literal", MD_AST_NODE_TYPE_MAP_LITERAL, B);
//}
//// Allow trailing final comma, especially for multiline map literals
//MapLiteralKeyValuePairs(A) ::= MapLiteralKeyValuePair(B) ",". {
//	A = mlr_dsl_ast_node_alloc_unary("map_literal", MD_AST_NODE_TYPE_MAP_LITERAL, B);
//}
//MapLiteralKeyValuePairs(A) ::= MapLiteralKeyValuePair(B) "," MapLiteralKeyValuePairs(C). {
//	A = mlr_dsl_ast_node_prepend_arg(C, B);
//}

//MapLiteralKeyValuePair(A) ::= MapLiteralKey(B) ":" MapLiteralValue(C). {
//	A = mlr_dsl_ast_node_alloc_binary("mappair", MD_AST_NODE_TYPE_MAP_LITERAL_PAIR, B, C);
//}
//MapLiteralKey(A) ::= RHS(B). {
//	A = mlr_dsl_ast_node_alloc_unary("mapkey", MD_AST_NODE_TYPE_MAP_LITERAL_KEY, B);
//}
//MapLiteralValue(A) ::= RHS(B). {
//	A = mlr_dsl_ast_node_alloc_unary("mapval", MD_AST_NODE_TYPE_MAP_LITERAL_VALUE, B);
//}
//MapLiteralValue(A) ::= MapLiteral(B). {
//	A = mlr_dsl_ast_node_alloc_unary("mapval", MD_AST_NODE_TYPE_MAP_LITERAL_VALUE, B);
//}
//MapLiteralValue(A) ::= md_token_full_srec(B). {
//	A = mlr_dsl_ast_node_alloc_unary("mapval", MD_AST_NODE_TYPE_MAP_LITERAL_VALUE, B);
//}
//MapLiteralValue(A) ::= md_token_full_oosvar(B). {
//	A = mlr_dsl_ast_node_alloc_unary("mapval", MD_AST_NODE_TYPE_MAP_LITERAL_VALUE, B);
//}
