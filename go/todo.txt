* lots of trivial things are just a matter of keystroking
* defer them while focusing on what's hard (and maybe most worthwhile about the Go port)

harder / more worthy:
~ streaming JSON reader
  -> w/ and w/o enclosing [...] !
~ streaming RFC-compliant CSV reader
! srec with mlrval values
  ! solve the JIT issue for formatting of numeric values
* sort
* stats1
* calendar/DST/TZ
~ DSL

easier:
* most of the verbs
* most of the file formats
* then-chaining

bonuses:
* non-lite dkvp as easy extension of golib CSV reader :D

also:
* type up a why-go part:
  o 100% vs 240% CPU
  o solve the streaming-json-reader problem, and some timezone/DST issues
  o it'll make it easier for others to contribute (IMHO mappers easy to read; mlhmmv impenetrable)
  o fun :)

long-term:
* srecs as string -> mlrvals, then mlrval | mlhmmv
* support full json read/write
  o only requirement is that top-level be sequence of string-valued objects ...
  o json-to-json cat-mapping should be identical
  o json-like accessor syntax in the grammar: $field.foo[3].bar{"bar"}

gocc upstreams:
* support "..." in the lexer part
* research customization of error-handling ... line numbers in particular ...

----------------------------------------------------------------
nits:
* AST post-processing: strip '$' and '"' ... '"'; etc
* "...\"..." into string-literal parsing ...
* all manner of xxx
* support whitespace-only DSL strings (as NOPs), either in the parser or outside ...
* AST insertions: make a simple NodeFromToken & have all interface{} be *ASTNode, not *token.Token
* go through and make various class attributes private (not Lrec/LrecEntry but others ... ?)
