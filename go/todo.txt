* lots of trivial things are just a matter of keystroking
* defer them while focusing on what's hard (and maybe most worthwhile about the Go port)

harder / more worthy:
~ streaming JSON reader
  -> w/ and w/o enclosing [...] !
~ streaming RFC-compliant CSV reader
k srec with mlrval values
  k solve the JIT issue for formatting of numeric values
* sort
* stats1
* calendar/DST/TZ
~ DSL

easier:
* most of the verbs
* most of the file formats
* then-chaining

bonuses:
* non-lite dkvp as easy extension of golib CSV reader :D

also:
* type up a why-go part:
  o 100% vs 240% CPU
  o incorporate go/README.md notes

long-term:
k srecs as string -> mlrvals
* then srecs as string -> (mlrval | mlhmmv)
* support full json read/write
  o only requirement is that top-level be sequence of string-valued objects ...
  o json-to-json cat-mapping should be identical
  o json-like accessor syntax in the grammar: $field.foo[3].bar{"bar"}

gocc upstreams:
* support "abc" (not just 'a' 'b' 'c') in the lexer part
* research customization of error-handling ... line numbers in particular ...

----------------------------------------------------------------
nits:
* split up mlrcli
* AST post-processing: strip '$' and '"' ... '"'; etc
* "...\"..." into string-literal parsing ...
* all manner of xxx
* support whitespace-only DSL strings (as NOPs), either in the parser or outside ...
* AST insertions: make a simple NodeFromToken & have all interface{} be *ASTNode, not *token.Token
* lrec -> srec everywhere
* comment precisely where context pointers -> copy and why
* mlr --help-for w/ stdout redirect for manpage -- ?
