----------------------------------------------------------------
TOP OF LIST:

* tuesday:
  o oosvars at state -- easy mlrmap now
  o indexed-lvalue assignment ops -- need ints too
  o $[1] is easier now; needn't $[[[1]]]
    - keep or get rid of $[[[ ]]] ... ?
  o functions?!?

* array/map
  o err-return for array/map get/put if incorrect types ... currently go-void ...
  o mlrval Go Copy method and DSL copy function ... or, better, pass by
    reference throughout RHS but always copy on assignment. (don't
    want references to $* trashing the UX.)

* SUMMARY:
  o easy: most verbs
  o easy: full cli
  o easy: readers/writers including TSV/ASV, and CSV heterogeneity
  o medium: sort/stats1/join
  o will take time: array/map mlrval
  o will take time: full DSL including functions, mapvals, etc

* widen verb coverage
  o label
  o rename
  o group-by
  o cut
  o count
  o repeat
  o head/tail
  o sort
  o filter
  o focus on calendar/DST/TZ improvements

* widen CLI coverage
  o --c2x et al.
  o implement mlrrc

* widen reader coverage
  o TSV/ASV
  o XTAB

â€¢ widen writer coverage
  o TSV/ASV
  o markdown

* I/O
  o --allow-ragged-csv-input|--ragged
  o --implicit-csv-header
  o --headerless-csv-output
  o new non-lite DKVP reader/writer
  o comment-filtering compaosed io.Reader

* simplify the DSL
  o Lvalue rule
  o single assignment type with left-child implementing a new Assignable interface

* widen DSL coverage
  o begin/end blocks
  o oosvars
  o indirect field names, at LHS and RHS
  o full indexable at LHS/RHS -- e.g. $*["a"] = $b
  o support the filter verb
  o there should have always been a >>> and >>>=
  o "...\"...\"..." in string literals
  o sigh ... the C DSL didn't have int keys per se, just stringifies of them.
    so auto-extend was not an issue and '@o[1][2][3]=4' worked. :(

! the DSL needs a full, written-down-and-published spell-out of reference/copy semantics
* then careful CST impl
! likewise error-eval semantics

----------------------------------------------------------------
MAYBE:

* string index/slice access
* string/array slices on assignment LHS -- ?
* push/pop/shift/unshift subroutines

----------------------------------------------------------------
GOCC UPSTREAMS:

* support "abc" (not just 'a' 'b' 'c') in the lexer part
* research customization of error-handling ... line numbers in particular ...

----------------------------------------------------------------
DEV NOTES:

* build-dsl
* build
* fmter
* check
* git diff to see what changed
* commit

----------------------------------------------------------------
PARSER/LEXER PLAN:

* grok ch25
* grok pike-lexer slides
* alsu at ... what level ?

----------------------------------------------------------------
NITS/NON-IMMEDIATE:

* address all manner of xxx and TODO comments
* AST insertions: make a simple NodeFromToken & have all interface{} be *ASTNode, not *token.Token
* mlr --help-for w/ stdout redirect for manpage -- ?
* mlr verb -h -> stdout & exit 0
* cst printer with reflect.TypeOf -- ?
* godoc ...
* mlrdoc false && 4, true || 4 because of short-circuiting requirement
* update whyc.html with efficiency notes from go/README.md
? makefile for build-dsl: if $bnf newer than productionstable.go
* I/O perf delta between C & Go is smaller for CSV, middle for DKVP, large for JSON -- debug
* neaten/error-proof:
  o mlrmapEntry -> own keys/mlrvals -- keep the kcopy/vcopy & be very clear,
    or remove. (keeping pointers allows nil-check which is good.)
  o inrec *lib.Mlrmap is good for default no-copy across channels ... needs
    a big red flag though for things like the repeat verb (maybe *only* that one ...)
! clean up the AST API. ish! :^/
* defer reg_test/run until there is quite a bit more verb/dsl/io expansion
* doc: no boolish truthy falsy
* json:
  d thorough UT for json mlrval-parser including various expect-fail error cases
  d doc re no jlistwrap on input if they want get streaming input
  d UT JSON-to-JSON cat-mapping should be identical
  d JSON-like accessor syntax in the grammar: $field[3]["bar"]
  d flatten/unflatten for non-JSON I/O formats -- maybe just double-quoted JSON strings -- ?
    - make a force-single-line writer
    - make a jsonparse DSL function -- ?
  d other formats: use JSON marshaler for collection types, maybe double-quoted
* better error-identification in the lexer / parser
  o research gocc support
  o maybe a case for hand-roll
