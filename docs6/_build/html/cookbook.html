
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cookbook part 1: common patterns &#8212; Miller 5.10.2 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Cookbook part 2: Random things, and some math" href="cookbook2.html" />
    <link rel="prev" title="Data-diving examples" href="data-examples.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="cookbook2.html" title="Cookbook part 2: Random things, and some math"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="data-examples.html" title="Data-diving examples"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Miller 5.10.2 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Cookbook part 1: common patterns</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="cookbook-part-1-common-patterns">
<h1>Cookbook part 1: common patterns<a class="headerlink" href="#cookbook-part-1-common-patterns" title="Permalink to this headline">¶</a></h1>
<div class="section" id="headerless-csv-on-input-or-output">
<h2>Headerless CSV on input or output<a class="headerlink" href="#headerless-csv-on-input-or-output" title="Permalink to this headline">¶</a></h2>
<p>Sometimes we get CSV files which lack a header. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cat data/headerless.csv
John,23,present
Fred,34,present
Alice,56,missing
Carol,45,present
</pre></div>
</div>
<p>You can use Miller to add a header. The <code class="docutils literal notranslate"><span class="pre">--implicit-csv-header</span></code> applies positionally indexed labels:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --csv --implicit-csv-header cat data/headerless.csv
1,2,3
John,23,present
Fred,34,present
Alice,56,missing
Carol,45,present
</pre></div>
</div>
<p>Following that, you can rename the positionally indexed labels to names with meaning for your context.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --csv --implicit-csv-header label name,age,status data/headerless.csv
name,age,status
John,23,present
Fred,34,present
Alice,56,missing
Carol,45,present
</pre></div>
</div>
<p>Likewise, if you need to produce CSV which is lacking its header, you can pipe Miller’s output to the system command <code class="docutils literal notranslate"><span class="pre">sed</span> <span class="pre">1d</span></code>, or you can use Miller’s <code class="docutils literal notranslate"><span class="pre">--headerless-csv-output</span></code> option:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ head -5 data/colored-shapes.dkvp | mlr --ocsv cat
color,shape,flag,i,u,v,w,x
yellow,triangle,1,11,0.6321695890307647,0.9887207810889004,0.4364983936735774,5.7981881667050565
red,square,1,15,0.21966833570651523,0.001257332190235938,0.7927778364718627,2.944117399716207
red,circle,1,16,0.20901671281497636,0.29005231936593445,0.13810280912907674,5.065034003400998
red,square,0,48,0.9562743938458542,0.7467203085342884,0.7755423050923582,7.117831369597269
purple,triangle,0,51,0.4355354501763202,0.8591292672156728,0.8122903963006748,5.753094629505863
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ head -5 data/colored-shapes.dkvp | mlr --ocsv --headerless-csv-output cat
yellow,triangle,1,11,0.6321695890307647,0.9887207810889004,0.4364983936735774,5.7981881667050565
red,square,1,15,0.21966833570651523,0.001257332190235938,0.7927778364718627,2.944117399716207
red,circle,1,16,0.20901671281497636,0.29005231936593445,0.13810280912907674,5.065034003400998
red,square,0,48,0.9562743938458542,0.7467203085342884,0.7755423050923582,7.117831369597269
purple,triangle,0,51,0.4355354501763202,0.8591292672156728,0.8122903963006748,5.753094629505863
</pre></div>
</div>
<p>Lastly, often we say “CSV” or “TSV” when we have positionally indexed data in columns which are separated by commas or tabs, respectively. In this case it’s perhaps simpler to <strong>just use NIDX format</strong> which was designed for this purpose. (See also <a class="reference internal" href="file-formats.html"><span class="doc">File formats</span></a>.) For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --inidx --ifs comma --oxtab cut -f 1,3 data/headerless.csv
1 John
3 present

1 Fred
3 present

1 Alice
3 missing

1 Carol
3 present
</pre></div>
</div>
</div>
<div class="section" id="doing-multiple-joins">
<h2>Doing multiple joins<a class="headerlink" href="#doing-multiple-joins" title="Permalink to this headline">¶</a></h2>
<p>Suppose we have the following data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cat multi-join/input.csv
id,task
10,chop
20,puree
20,wash
30,fold
10,bake
20,mix
10,knead
30,clean
</pre></div>
</div>
<p>And we want to augment the <code class="docutils literal notranslate"><span class="pre">id</span></code> column with lookups from the following data files:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cat multi-join/name-lookup.csv
id,name
30,Alice
10,Bob
20,Carol
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cat multi-join/status-lookup.csv
id,status
30,occupied
10,idle
20,idle
</pre></div>
</div>
<p>We can run the input file through multiple <code class="docutils literal notranslate"><span class="pre">join</span></code> commands in a <code class="docutils literal notranslate"><span class="pre">then</span></code>-chain:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --icsv --opprint join -f multi-join/name-lookup.csv -j id then join -f multi-join/status-lookup.csv -j id multi-join/input.csv
id status   name  task
10 idle     Bob   chop
20 idle     Carol puree
20 idle     Carol wash
30 occupied Alice fold
10 idle     Bob   bake
20 idle     Carol mix
10 idle     Bob   knead
30 occupied Alice clean
</pre></div>
</div>
</div>
<div class="section" id="bulk-rename-of-fields">
<h2>Bulk rename of fields<a class="headerlink" href="#bulk-rename-of-fields" title="Permalink to this headline">¶</a></h2>
<p>Suppose you want to replace spaces with underscores in your column names:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cat data/spaces.csv
a b c,def,g h i
123,4567,890
2468,1357,3579
9987,3312,4543
</pre></div>
</div>
<p>The simplest way is to use <code class="docutils literal notranslate"><span class="pre">mlr</span> <span class="pre">rename</span></code> with <code class="docutils literal notranslate"><span class="pre">-g</span></code> (for global replace, not just first occurrence of space within each field) and <code class="docutils literal notranslate"><span class="pre">-r</span></code> for pattern-matching (rather than explicit single-column renames):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --csv rename -g -r &#39; ,_&#39;  data/spaces.csv
a_b_c,def,g_h_i
123,4567,890
2468,1357,3579
9987,3312,4543
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --csv --opprint rename -g -r &#39; ,_&#39;  data/spaces.csv
a_b_c def  g_h_i
123   4567 890
2468  1357 3579
9987  3312 4543
</pre></div>
</div>
<p>You can also do this with a for-loop:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cat data/bulk-rename-for-loop.mlr
map newrec = {};
for (oldk, v in $*) {
    newrec[gsub(oldk, &quot; &quot;, &quot;_&quot;)] = v;
}
$* = newrec
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --icsv --opprint put -f data/bulk-rename-for-loop.mlr data/spaces.csv
a_b_c def  g_h_i
123   4567 890
2468  1357 3579
9987  3312 4543
</pre></div>
</div>
</div>
<div class="section" id="search-and-replace-over-all-fields">
<h2>Search-and-replace over all fields<a class="headerlink" href="#search-and-replace-over-all-fields" title="Permalink to this headline">¶</a></h2>
<p>How to do <code class="docutils literal notranslate"><span class="pre">$name</span> <span class="pre">=</span> <span class="pre">gsub($name,</span> <span class="pre">&quot;old&quot;,</span> <span class="pre">&quot;new&quot;)</span></code> for all fields?</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cat data/sar.csv
a,b,c
the quick,brown fox,jumped
over,the,lazy dogs
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cat data/sar.mlr
  for (k in $*) {
    $[k] = gsub($[k], &quot;e&quot;, &quot;X&quot;);
  }
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --csv put -f data/sar.mlr data/sar.csv
a,b,c
thX quick,brown fox,jumpXd
ovXr,thX,lazy dogs
</pre></div>
</div>
</div>
<div class="section" id="full-field-renames-and-reassigns">
<h2>Full field renames and reassigns<a class="headerlink" href="#full-field-renames-and-reassigns" title="Permalink to this headline">¶</a></h2>
<p>Using Miller 5.0.0’s map literals and assigning to <code class="docutils literal notranslate"><span class="pre">$*</span></code>, you can fully generalize <a class="reference internal" href="reference-verbs.html#reference-verbs-rename"><span class="std std-ref">mlr rename</span></a>, <a class="reference internal" href="reference-verbs.html#reference-verbs-reorder"><span class="std std-ref">mlr reorder</span></a>, etc.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cat data/small
a=pan,b=pan,i=1,x=0.3467901443380824,y=0.7268028627434533
a=eks,b=pan,i=2,x=0.7586799647899636,y=0.5221511083334797
a=wye,b=wye,i=3,x=0.20460330576630303,y=0.33831852551664776
a=eks,b=wye,i=4,x=0.38139939387114097,y=0.13418874328430463
a=wye,b=pan,i=5,x=0.5732889198020006,y=0.8636244699032729
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr put &#39;
  begin {
    @i_cumu = 0;
  }

  @i_cumu += $i;
  $* = {
    &quot;z&quot;: $x + y,
    &quot;KEYFIELD&quot;: $a,
    &quot;i&quot;: @i_cumu,
    &quot;b&quot;: $b,
    &quot;y&quot;: $x,
    &quot;x&quot;: $y,
  };
&#39; data/small
z=0.346790,KEYFIELD=pan,i=1,b=pan,y=0.346790,x=0.726803
z=0.758680,KEYFIELD=eks,i=3,b=pan,y=0.758680,x=0.522151
z=0.204603,KEYFIELD=wye,i=6,b=wye,y=0.204603,x=0.338319
z=0.381399,KEYFIELD=eks,i=10,b=wye,y=0.381399,x=0.134189
z=0.573289,KEYFIELD=wye,i=15,b=pan,y=0.573289,x=0.863624
</pre></div>
</div>
</div>
<div class="section" id="numbering-and-renumbering-records">
<h2>Numbering and renumbering records<a class="headerlink" href="#numbering-and-renumbering-records" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">awk</span></code>-like built-in variable <code class="docutils literal notranslate"><span class="pre">NR</span></code> is incremented for each input record:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cat data/small
a=pan,b=pan,i=1,x=0.3467901443380824,y=0.7268028627434533
a=eks,b=pan,i=2,x=0.7586799647899636,y=0.5221511083334797
a=wye,b=wye,i=3,x=0.20460330576630303,y=0.33831852551664776
a=eks,b=wye,i=4,x=0.38139939387114097,y=0.13418874328430463
a=wye,b=pan,i=5,x=0.5732889198020006,y=0.8636244699032729
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr put &#39;$nr = NR&#39; data/small
a=pan,b=pan,i=1,x=0.3467901443380824,y=0.7268028627434533,nr=1
a=eks,b=pan,i=2,x=0.7586799647899636,y=0.5221511083334797,nr=2
a=wye,b=wye,i=3,x=0.20460330576630303,y=0.33831852551664776,nr=3
a=eks,b=wye,i=4,x=0.38139939387114097,y=0.13418874328430463,nr=4
a=wye,b=pan,i=5,x=0.5732889198020006,y=0.8636244699032729,nr=5
</pre></div>
</div>
<p>However, this is the record number within the original input stream – not after any filtering you may have done:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr filter &#39;$a == &quot;wye&quot;&#39; then put &#39;$nr = NR&#39; data/small
a=wye,b=wye,i=3,x=0.20460330576630303,y=0.33831852551664776,nr=3
a=wye,b=pan,i=5,x=0.5732889198020006,y=0.8636244699032729,nr=5
</pre></div>
</div>
<p>There are two good options here. One is to use the <code class="docutils literal notranslate"><span class="pre">cat</span></code> verb with <code class="docutils literal notranslate"><span class="pre">-n</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr filter &#39;$a == &quot;wye&quot;&#39; then cat -n data/small
n=1,a=wye,b=wye,i=3,x=0.20460330576630303,y=0.33831852551664776
n=2,a=wye,b=pan,i=5,x=0.5732889198020006,y=0.8636244699032729
</pre></div>
</div>
<p>The other is to keep your own counter within the <code class="docutils literal notranslate"><span class="pre">put</span></code> DSL:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr filter &#39;$a == &quot;wye&quot;&#39; then put &#39;begin {@n = 1} $n = @n; @n += 1&#39; data/small
a=wye,b=wye,i=3,x=0.20460330576630303,y=0.33831852551664776,n=1
a=wye,b=pan,i=5,x=0.5732889198020006,y=0.8636244699032729,n=2
</pre></div>
</div>
<p>The difference is a matter of taste (although <code class="docutils literal notranslate"><span class="pre">mlr</span> <span class="pre">cat</span> <span class="pre">-n</span></code> puts the counter first).</p>
</div>
<div class="section" id="options-for-dealing-with-duplicate-rows">
<h2>Options for dealing with duplicate rows<a class="headerlink" href="#options-for-dealing-with-duplicate-rows" title="Permalink to this headline">¶</a></h2>
<p>If your data has records appearing multiple times, you can use <a class="reference internal" href="reference-verbs.html#reference-verbs-uniq"><span class="std std-ref">mlr uniq</span></a> to show and/or count the unique records.</p>
<p>If you want to look at partial uniqueness – for example, show only the first record for each unique combination of the <code class="docutils literal notranslate"><span class="pre">account_id</span></code> and <code class="docutils literal notranslate"><span class="pre">account_status</span></code> fields – you might use <code class="docutils literal notranslate"><span class="pre">mlr</span> <span class="pre">head</span> <span class="pre">-n</span> <span class="pre">1</span> <span class="pre">-g</span> <span class="pre">account_id,account_status</span></code>. Please also see <a class="reference internal" href="reference-verbs.html#reference-verbs-head"><span class="std std-ref">mlr head</span></a>.</p>
</div>
<div class="section" id="data-cleaning-examples">
<span id="cookbook-data-cleaning-examples"></span><h2>Data-cleaning examples<a class="headerlink" href="#data-cleaning-examples" title="Permalink to this headline">¶</a></h2>
<p>Here are some ways to use the type-checking options as described in <a class="reference internal" href="reference-dsl.html#reference-dsl-type-tests-and-assertions"><span class="std std-ref">Type-test and type-assertion expressions</span></a> Suppose you have the following data file, with inconsistent typing for boolean. (Also imagine that, for the sake of discussion, we have a million-line file rather than a four-line file, so we can’t see it all at once and some automation is called for.)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cat data/het-bool.csv
name,reachable
barney,false
betty,true
fred,true
wilma,1
</pre></div>
</div>
<p>One option is to coerce everything to boolean, or integer:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --icsv --opprint put &#39;$reachable = boolean($reachable)&#39; data/het-bool.csv
name   reachable
barney false
betty  true
fred   true
wilma  true
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --icsv --opprint put &#39;$reachable = int(boolean($reachable))&#39; data/het-bool.csv
name   reachable
barney 0
betty  1
fred   1
wilma  1
</pre></div>
</div>
<p>A second option is to flag badly formatted data within the output stream:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --icsv --opprint put &#39;$format_ok = is_string($reachable)&#39; data/het-bool.csv
name   reachable format_ok
barney false     true
betty  true      true
fred   true      true
wilma  1         false
</pre></div>
</div>
<p>Or perhaps to flag badly formatted data outside the output stream:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --icsv --opprint put &#39;if (!is_string($reachable)) {eprint &quot;Malformed at NR=&quot;.NR} &#39; data/het-bool.csv
Malformed at NR=4
name   reachable
barney false
betty  true
fred   true
wilma  1
</pre></div>
</div>
<p>A third way is to abort the process on first instance of bad data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --csv put &#39;$reachable = asserting_string($reachable)&#39; data/het-bool.csv
mlr: string type-assertion failed at NR=4 FNR=4 FILENAME=data/het-bool.csv
name,reachable
barney,false
betty,true
fred,true
</pre></div>
</div>
</div>
<div class="section" id="splitting-nested-fields">
<h2>Splitting nested fields<a class="headerlink" href="#splitting-nested-fields" title="Permalink to this headline">¶</a></h2>
<p>Suppose you have a TSV file like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span>   <span class="n">b</span>
<span class="n">x</span>   <span class="n">z</span>
<span class="n">s</span>   <span class="n">u</span><span class="p">:</span><span class="n">v</span><span class="p">:</span><span class="n">w</span>
</pre></div>
</div>
<p>The simplest option is to use <a class="reference internal" href="reference-verbs.html#reference-verbs-nest"><span class="std std-ref">mlr nest</span></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --tsv nest --explode --values --across-records -f b --nested-fs : data/nested.tsv
a   b
x   z
s   u
s   v
s   w
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --tsv nest --explode --values --across-fields  -f b --nested-fs : data/nested.tsv
a   b_1
x   z

a   b_1     b_2     b_3
s   u       v       w
</pre></div>
</div>
<p>While <code class="docutils literal notranslate"><span class="pre">mlr</span> <span class="pre">nest</span></code> is simplest, let’s also take a look at a few ways to do this using the <code class="docutils literal notranslate"><span class="pre">put</span></code> DSL.</p>
<p>One option to split out the colon-delimited values in the <code class="docutils literal notranslate"><span class="pre">b</span></code> column is to use <code class="docutils literal notranslate"><span class="pre">splitnv</span></code> to create an integer-indexed map and loop over it, adding new fields to the current record:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --from data/nested.tsv --itsv --oxtab put &#39;o=splitnv($b, &quot;:&quot;); for (k,v in o) {$[&quot;p&quot;.k]=v}&#39;
a  x
b  z
p1 z

a  s
b  u:v:w
p1 u
p2 v
p3 w
</pre></div>
</div>
<p>while another is to loop over the same map from <code class="docutils literal notranslate"><span class="pre">splitnv</span></code> and use it (with <code class="docutils literal notranslate"><span class="pre">put</span> <span class="pre">-q</span></code> to suppress printing the original record) to produce multiple records:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --from data/nested.tsv --itsv --oxtab put -q &#39;o=splitnv($b, &quot;:&quot;); for (k,v in o) {x=mapsum($*, {&quot;b&quot;:v}); emit x}&#39;
a x
b z

a s
b u

a s
b v

a s
b w
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --from data/nested.tsv --tsv put -q &#39;o=splitnv($b, &quot;:&quot;); for (k,v in o) {x=mapsum($*, {&quot;b&quot;:v}); emit x}&#39;
a   b
x   z
s   u
s   v
s   w
</pre></div>
</div>
</div>
<div class="section" id="showing-differences-between-successive-queries">
<h2>Showing differences between successive queries<a class="headerlink" href="#showing-differences-between-successive-queries" title="Permalink to this headline">¶</a></h2>
<p>Suppose you have a database query which you run at one point in time, producing the output on the left, then again later producing the output on the right:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cat data/previous_counters.csv
color,count
red,3472
blue,6838
orange,694
purple,12
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cat data/current_counters.csv
color,count
red,3467
orange,670
yellow,27
blue,6944
</pre></div>
</div>
<p>And, suppose you want to compute the differences in the counters between adjacent keys. Since the color names aren’t all in the same order, nor are they all present on both sides, we can’t just paste the two files side-by-side and do some column-four-minus-column-two arithmetic.</p>
<p>First, rename counter columns to make them distinct:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --csv rename count,previous_count data/previous_counters.csv &gt; data/prevtemp.csv
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cat data/prevtemp.csv
color,previous_count
red,3472
blue,6838
orange,694
purple,12
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --csv rename count,current_count data/current_counters.csv &gt; data/currtemp.csv
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cat data/currtemp.csv
color,current_count
red,3467
orange,670
yellow,27
blue,6944
</pre></div>
</div>
<p>Then, join on the key field(s), and use unsparsify to zero-fill counters absent on one side but present on the other. Use <code class="docutils literal notranslate"><span class="pre">--ul</span></code> and <code class="docutils literal notranslate"><span class="pre">--ur</span></code> to emit unpaired records (namely, purple on the left and yellow on the right):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --icsv --opprint \
  join -j color --ul --ur -f data/prevtemp.csv \
  then unsparsify --fill-with 0 \
  then put &#39;$count_delta = $current_count - $previous_count&#39; \
  data/currtemp.csv
color  previous_count current_count count_delta
red    3472           3467          -5
orange 694            670           -24
yellow 0              27            27
blue   6838           6944          106
purple 12             0             -12
</pre></div>
</div>
</div>
<div class="section" id="finding-missing-dates">
<h2>Finding missing dates<a class="headerlink" href="#finding-missing-dates" title="Permalink to this headline">¶</a></h2>
<p>Suppose you have some date-stamped data which may (or may not) be missing entries for one or more dates:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ head -n 10 data/miss-date.csv
date,qoh
2012-03-05,10055
2012-03-06,10486
2012-03-07,10430
2012-03-08,10674
2012-03-09,10880
2012-03-10,10718
2012-03-11,10795
2012-03-12,11043
2012-03-13,11177
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ wc -l data/miss-date.csv
    1372 data/miss-date.csv
</pre></div>
</div>
<p>Since there are 1372 lines in the data file, some automation is called for. To find the missing dates, you can convert the dates to seconds since the epoch using <code class="docutils literal notranslate"><span class="pre">strptime</span></code>, then compute adjacent differences (the <code class="docutils literal notranslate"><span class="pre">cat</span> <span class="pre">-n</span></code> simply inserts record-counters):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --from data/miss-date.csv --icsv \
  cat -n \
  then put &#39;$datestamp = strptime($date, &quot;%Y-%m-%d&quot;)&#39; \
  then step -a delta -f datestamp \
| head
n=1,date=2012-03-05,qoh=10055,datestamp=1330905600.000000,datestamp_delta=0
n=2,date=2012-03-06,qoh=10486,datestamp=1330992000.000000,datestamp_delta=86400.000000
n=3,date=2012-03-07,qoh=10430,datestamp=1331078400.000000,datestamp_delta=86400.000000
n=4,date=2012-03-08,qoh=10674,datestamp=1331164800.000000,datestamp_delta=86400.000000
n=5,date=2012-03-09,qoh=10880,datestamp=1331251200.000000,datestamp_delta=86400.000000
n=6,date=2012-03-10,qoh=10718,datestamp=1331337600.000000,datestamp_delta=86400.000000
n=7,date=2012-03-11,qoh=10795,datestamp=1331424000.000000,datestamp_delta=86400.000000
n=8,date=2012-03-12,qoh=11043,datestamp=1331510400.000000,datestamp_delta=86400.000000
n=9,date=2012-03-13,qoh=11177,datestamp=1331596800.000000,datestamp_delta=86400.000000
n=10,date=2012-03-14,qoh=11498,datestamp=1331683200.000000,datestamp_delta=86400.000000
</pre></div>
</div>
<p>Then, filter for adjacent difference not being 86400 (the number of seconds in a day):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --from data/miss-date.csv --icsv \
  cat -n \
  then put &#39;$datestamp = strptime($date, &quot;%Y-%m-%d&quot;)&#39; \
  then step -a delta -f datestamp \
  then filter &#39;$datestamp_delta != 86400 &amp;&amp; $n != 1&#39;
n=774,date=2014-04-19,qoh=130140,datestamp=1397865600.000000,datestamp_delta=259200.000000
n=1119,date=2015-03-31,qoh=181625,datestamp=1427760000.000000,datestamp_delta=172800.000000
</pre></div>
</div>
<p>Given this, it’s now easy to see where the gaps are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr cat -n then filter &#39;$n &gt;= 770 &amp;&amp; $n &lt;= 780&#39; data/miss-date.csv
n=770,1=2014-04-12,2=129435
n=771,1=2014-04-13,2=129868
n=772,1=2014-04-14,2=129797
n=773,1=2014-04-15,2=129919
n=774,1=2014-04-16,2=130181
n=775,1=2014-04-19,2=130140
n=776,1=2014-04-20,2=130271
n=777,1=2014-04-21,2=130368
n=778,1=2014-04-22,2=130368
n=779,1=2014-04-23,2=130849
n=780,1=2014-04-24,2=131026
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr cat -n then filter &#39;$n &gt;= 1115 &amp;&amp; $n &lt;= 1125&#39; data/miss-date.csv
n=1115,1=2015-03-25,2=181006
n=1116,1=2015-03-26,2=180995
n=1117,1=2015-03-27,2=181043
n=1118,1=2015-03-28,2=181112
n=1119,1=2015-03-29,2=181306
n=1120,1=2015-03-31,2=181625
n=1121,1=2015-04-01,2=181494
n=1122,1=2015-04-02,2=181718
n=1123,1=2015-04-03,2=181835
n=1124,1=2015-04-04,2=182104
n=1125,1=2015-04-05,2=182528
</pre></div>
</div>
</div>
<div class="section" id="two-pass-algorithms">
<h2>Two-pass algorithms<a class="headerlink" href="#two-pass-algorithms" title="Permalink to this headline">¶</a></h2>
<p>Miller is a streaming record processor; commands are performed once per record. This makes Miller particularly suitable for single-pass algorithms, allowing many of its verbs to process files that are (much) larger than the amount of RAM present in your system. (Of course, Miller verbs such as <code class="docutils literal notranslate"><span class="pre">sort</span></code>, <code class="docutils literal notranslate"><span class="pre">tac</span></code>, etc. all must ingest and retain all input records before emitting any output records.) You can also use out-of-stream variables to perform multi-pass computations, at the price of retaining all input records in memory.</p>
<div class="section" id="two-pass-algorithms-computation-of-percentages">
<h3>Two-pass algorithms: computation of percentages<a class="headerlink" href="#two-pass-algorithms-computation-of-percentages" title="Permalink to this headline">¶</a></h3>
<p>For example, mapping numeric values down a column to the percentage between their min and max values is two-pass: on the first pass you find the min and max values, then on the second, map each record’s value to a percentage.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --from data/small --opprint put -q &#39;
  # These are executed once per record, which is the first pass.
  # The key is to use NR to index an out-of-stream variable to
  # retain all the x-field values.
  @x_min = min($x, @x_min);
  @x_max = max($x, @x_max);
  @x[NR] = $x;

  # The second pass is in a for-loop in an end-block.
  end {
    for (nr, x in @x) {
      @x_pct[nr] = 100 * (x - @x_min) / (@x_max - @x_min);
    }
    emit (@x, @x_pct), &quot;NR&quot;
  }
&#39;
NR x        x_pct
1  0.346790 25.661943
2  0.758680 100.000000
3  0.204603 0.000000
4  0.381399 31.908236
5  0.573289 66.540542
</pre></div>
</div>
</div>
<div class="section" id="two-pass-algorithms-line-number-ratios">
<h3>Two-pass algorithms: line-number ratios<a class="headerlink" href="#two-pass-algorithms-line-number-ratios" title="Permalink to this headline">¶</a></h3>
<p>Similarly, finding the total record count requires first reading through all the data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --opprint --from data/small put -q &#39;
  @records[NR] = $*;
  end {
    for((I,k),v in @records) {
      @records[I][&quot;I&quot;] = I;
      @records[I][&quot;N&quot;] = NR;
      @records[I][&quot;PCT&quot;] = 100*I/NR
    }
    emit @records,&quot;I&quot;
  }
&#39; then reorder -f I,N,PCT
I N PCT a   b   i x                   y
1 5 20  pan pan 1 0.3467901443380824  0.7268028627434533
2 5 40  eks pan 2 0.7586799647899636  0.5221511083334797
3 5 60  wye wye 3 0.20460330576630303 0.33831852551664776
4 5 80  eks wye 4 0.38139939387114097 0.13418874328430463
5 5 100 wye pan 5 0.5732889198020006  0.8636244699032729
</pre></div>
</div>
</div>
<div class="section" id="two-pass-algorithms-records-having-max-value">
<h3>Two-pass algorithms: records having max value<a class="headerlink" href="#two-pass-algorithms-records-having-max-value" title="Permalink to this headline">¶</a></h3>
<p>The idea is to retain records having the largest value of <code class="docutils literal notranslate"><span class="pre">n</span></code> in the following data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --itsv --opprint cat data/maxrows.tsv
a      b      n score
purple red    5 0.743231
blue   purple 2 0.093710
red    purple 2 0.802103
purple red    5 0.389055
red    purple 2 0.880457
orange red    2 0.540349
purple purple 1 0.634451
orange purple 5 0.257223
orange purple 5 0.693499
red    red    4 0.981355
blue   purple 5 0.157052
purple purple 1 0.441784
red    purple 1 0.124912
orange blue   1 0.921944
blue   purple 4 0.490909
purple red    5 0.454779
green  purple 4 0.198278
orange blue   5 0.705700
red    red    3 0.940705
purple red    5 0.072936
orange blue   3 0.389463
orange purple 2 0.664985
blue   purple 1 0.371813
red    purple 4 0.984571
green  purple 5 0.203577
green  purple 3 0.900873
purple purple 0 0.965677
blue   purple 2 0.208785
purple purple 1 0.455077
red    purple 4 0.477187
blue   red    4 0.007487
</pre></div>
</div>
<p>Of course, the largest value of <code class="docutils literal notranslate"><span class="pre">n</span></code> isn’t known until after all data have been read. Using an out-of-stream variable we can retain all records as they are read, then filter them at the end:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cat data/maxrows.mlr
# Retain all records
@records[NR] = $*;
# Track max value of n
@maxn = max(@maxn, $n);

# After all records have been read, loop through retained records
# and print those with the max n value.
end {
  for (nr in @records) {
    map record = @records[nr];
    if (record[&quot;n&quot;] == @maxn) {
      emit record;
    }
  }
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --itsv --opprint put -q -f data/maxrows.mlr data/maxrows.tsv
a      b      n score
purple red    5 0.743231
purple red    5 0.389055
orange purple 5 0.257223
orange purple 5 0.693499
blue   purple 5 0.157052
purple red    5 0.454779
orange blue   5 0.705700
purple red    5 0.072936
green  purple 5 0.203577
</pre></div>
</div>
</div>
</div>
<div class="section" id="rectangularizing-data">
<h2>Rectangularizing data<a class="headerlink" href="#rectangularizing-data" title="Permalink to this headline">¶</a></h2>
<p>Suppose you have a method (in whatever language) which is printing things of the form</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">outer</span><span class="o">=</span><span class="mi">1</span>
<span class="n">outer</span><span class="o">=</span><span class="mi">2</span>
<span class="n">outer</span><span class="o">=</span><span class="mi">3</span>
</pre></div>
</div>
<p>and then calls another method which prints things of the form</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">middle</span><span class="o">=</span><span class="mi">10</span>
<span class="n">middle</span><span class="o">=</span><span class="mi">11</span>
<span class="n">middle</span><span class="o">=</span><span class="mi">12</span>
<span class="n">middle</span><span class="o">=</span><span class="mi">20</span>
<span class="n">middle</span><span class="o">=</span><span class="mi">21</span>
<span class="n">middle</span><span class="o">=</span><span class="mi">30</span>
<span class="n">middle</span><span class="o">=</span><span class="mi">31</span>
</pre></div>
</div>
<p>and then, perhaps, that second method calls a third method which prints things of the form</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">inner1</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span><span class="n">inner2</span><span class="o">=</span><span class="mi">101</span>
<span class="n">inner1</span><span class="o">=</span><span class="mi">120</span><span class="p">,</span><span class="n">inner2</span><span class="o">=</span><span class="mi">121</span>
<span class="n">inner1</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span><span class="n">inner2</span><span class="o">=</span><span class="mi">201</span>
<span class="n">inner1</span><span class="o">=</span><span class="mi">210</span><span class="p">,</span><span class="n">inner2</span><span class="o">=</span><span class="mi">211</span>
<span class="n">inner1</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span><span class="n">inner2</span><span class="o">=</span><span class="mi">301</span>
<span class="n">inner1</span><span class="o">=</span><span class="mi">312</span>
<span class="n">inner1</span><span class="o">=</span><span class="mi">313</span><span class="p">,</span><span class="n">inner2</span><span class="o">=</span><span class="mi">314</span>
</pre></div>
</div>
<p>with the result that your program’s output is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">outer</span><span class="o">=</span><span class="mi">1</span>
<span class="n">middle</span><span class="o">=</span><span class="mi">10</span>
<span class="n">inner1</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span><span class="n">inner2</span><span class="o">=</span><span class="mi">101</span>
<span class="n">middle</span><span class="o">=</span><span class="mi">11</span>
<span class="n">middle</span><span class="o">=</span><span class="mi">12</span>
<span class="n">inner1</span><span class="o">=</span><span class="mi">120</span><span class="p">,</span><span class="n">inner2</span><span class="o">=</span><span class="mi">121</span>
<span class="n">outer</span><span class="o">=</span><span class="mi">2</span>
<span class="n">middle</span><span class="o">=</span><span class="mi">20</span>
<span class="n">inner1</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span><span class="n">inner2</span><span class="o">=</span><span class="mi">201</span>
<span class="n">middle</span><span class="o">=</span><span class="mi">21</span>
<span class="n">inner1</span><span class="o">=</span><span class="mi">210</span><span class="p">,</span><span class="n">inner2</span><span class="o">=</span><span class="mi">211</span>
<span class="n">outer</span><span class="o">=</span><span class="mi">3</span>
<span class="n">middle</span><span class="o">=</span><span class="mi">30</span>
<span class="n">inner1</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span><span class="n">inner2</span><span class="o">=</span><span class="mi">301</span>
<span class="n">middle</span><span class="o">=</span><span class="mi">31</span>
<span class="n">inner1</span><span class="o">=</span><span class="mi">312</span>
<span class="n">inner1</span><span class="o">=</span><span class="mi">313</span><span class="p">,</span><span class="n">inner2</span><span class="o">=</span><span class="mi">314</span>
</pre></div>
</div>
<p>The idea here is that middles starting with a 1 belong to the outer value of 1, and so on.  (For example, the outer values might be account IDs, the middle values might be invoice IDs, and the inner values might be invoice line-items.) If you want all the middle and inner lines to have the context of which outers they belong to, you can modify your software to pass all those through your methods. Alternatively, don’t refactor your code just to handle some ad-hoc log-data formatting – instead, use the following to rectangularize the data.  The idea is to use an out-of-stream variable to accumulate fields across records. Clear that variable when you see an outer ID; accumulate fields; emit output when you see the inner IDs.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --from data/rect.txt put -q &#39;
  is_present($outer) {
    unset @r
  }
  for (k, v in $*) {
    @r[k] = v
  }
  is_present($inner1) {
    emit @r
  }&#39;
outer=1,middle=10,inner1=100,inner2=101
outer=1,middle=12,inner1=120,inner2=121
outer=2,middle=20,inner1=200,inner2=201
outer=2,middle=21,inner1=210,inner2=211
outer=3,middle=30,inner1=300,inner2=301
outer=3,middle=31,inner1=312,inner2=301
outer=3,middle=31,inner1=313,inner2=314
</pre></div>
</div>
</div>
<div class="section" id="regularizing-ragged-csv">
<h2>Regularizing ragged CSV<a class="headerlink" href="#regularizing-ragged-csv" title="Permalink to this headline">¶</a></h2>
<p>Miller handles compliant CSV: in particular, it’s an error if the number of data fields in a given data line don’t match the number of header lines. But in the event that you have a CSV file in which some lines have less than the full number of fields, you can use Miller to pad them out. The trick is to use NIDX format, for which each line stands on its own without respect to a header line.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cat data/ragged.csv
a,b,c
1,2,3
4,5
6,7,8,9
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --from data/ragged.csv --fs comma --nidx put &#39;
  @maxnf = max(@maxnf, NF);
  @nf = NF;
  while(@nf &lt; @maxnf) {
    @nf += 1;
    $[@nf] = &quot;&quot;
  }
&#39;
a,b,c
1,2,3
4,5,
6,7,8,9
</pre></div>
</div>
<p>or, more simply,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --from data/ragged.csv --fs comma --nidx put &#39;
  @maxnf = max(@maxnf, NF);
  while(NF &lt; @maxnf) {
    $[NF+1] = &quot;&quot;;
  }
&#39;
a,b,c
1,2,3
4,5,
6,7,8,9
</pre></div>
</div>
</div>
<div class="section" id="feature-counting">
<h2>Feature-counting<a class="headerlink" href="#feature-counting" title="Permalink to this headline">¶</a></h2>
<p>Suppose you have some heterogeneous data like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="s2">&quot;qoh&quot;</span><span class="p">:</span> <span class="mi">29874</span><span class="p">,</span> <span class="s2">&quot;rate&quot;</span><span class="p">:</span> <span class="mf">1.68</span><span class="p">,</span> <span class="s2">&quot;latency&quot;</span><span class="p">:</span> <span class="mf">0.02</span> <span class="p">}</span>
<span class="p">{</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;alice&quot;</span><span class="p">,</span> <span class="s2">&quot;uid&quot;</span><span class="p">:</span> <span class="mi">572</span> <span class="p">}</span>
<span class="p">{</span> <span class="s2">&quot;qoh&quot;</span><span class="p">:</span> <span class="mi">1227</span><span class="p">,</span> <span class="s2">&quot;rate&quot;</span><span class="p">:</span> <span class="mf">1.01</span><span class="p">,</span> <span class="s2">&quot;latency&quot;</span><span class="p">:</span> <span class="mf">0.07</span> <span class="p">}</span>
<span class="p">{</span> <span class="s2">&quot;qoh&quot;</span><span class="p">:</span> <span class="mi">13458</span><span class="p">,</span> <span class="s2">&quot;rate&quot;</span><span class="p">:</span> <span class="mf">1.72</span><span class="p">,</span> <span class="s2">&quot;latency&quot;</span><span class="p">:</span> <span class="mf">0.04</span> <span class="p">}</span>
<span class="p">{</span> <span class="s2">&quot;qoh&quot;</span><span class="p">:</span> <span class="mi">56782</span><span class="p">,</span> <span class="s2">&quot;rate&quot;</span><span class="p">:</span> <span class="mf">1.64</span> <span class="p">}</span>
<span class="p">{</span> <span class="s2">&quot;qoh&quot;</span><span class="p">:</span> <span class="mi">23512</span><span class="p">,</span> <span class="s2">&quot;rate&quot;</span><span class="p">:</span> <span class="mf">1.71</span><span class="p">,</span> <span class="s2">&quot;latency&quot;</span><span class="p">:</span> <span class="mf">0.03</span> <span class="p">}</span>
<span class="p">{</span> <span class="s2">&quot;qoh&quot;</span><span class="p">:</span> <span class="mi">9876</span><span class="p">,</span> <span class="s2">&quot;rate&quot;</span><span class="p">:</span> <span class="mf">1.89</span><span class="p">,</span> <span class="s2">&quot;latency&quot;</span><span class="p">:</span> <span class="mf">0.08</span> <span class="p">}</span>
<span class="p">{</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;bill&quot;</span><span class="p">,</span> <span class="s2">&quot;uid&quot;</span><span class="p">:</span> <span class="mi">684</span> <span class="p">}</span>
<span class="p">{</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;chuck&quot;</span><span class="p">,</span> <span class="s2">&quot;uid2&quot;</span><span class="p">:</span> <span class="mi">908</span> <span class="p">}</span>
<span class="p">{</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;dottie&quot;</span><span class="p">,</span> <span class="s2">&quot;uid&quot;</span><span class="p">:</span> <span class="mi">440</span> <span class="p">}</span>
<span class="p">{</span> <span class="s2">&quot;qoh&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;rate&quot;</span><span class="p">:</span> <span class="mf">0.40</span><span class="p">,</span> <span class="s2">&quot;latency&quot;</span><span class="p">:</span> <span class="mf">0.01</span> <span class="p">}</span>
<span class="p">{</span> <span class="s2">&quot;qoh&quot;</span><span class="p">:</span> <span class="mi">5438</span><span class="p">,</span> <span class="s2">&quot;rate&quot;</span><span class="p">:</span> <span class="mf">1.56</span><span class="p">,</span> <span class="s2">&quot;latency&quot;</span><span class="p">:</span> <span class="mf">0.17</span> <span class="p">}</span>
</pre></div>
</div>
<p>A reasonable question to ask is, how many occurrences of each field are there? And, what percentage of total row count has each of them? Since the denominator of the percentage is not known until the end, this is a two-pass algorithm:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>for (key in $*) {
  @key_counts[key] += 1;
}
@record_count += 1;

end {
  for (key in @key_counts) {
      @key_fraction[key] = @key_counts[key] / @record_count
  }
  emit @record_count;
  emit @key_counts, &quot;key&quot;;
  emit @key_fraction,&quot;key&quot;
}
</pre></div>
</div>
<p>Then</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --json put -q -f data/feature-count.mlr data/features.json
{ &quot;record_count&quot;: 12 }
{ &quot;key&quot;: &quot;qoh&quot;, &quot;key_counts&quot;: 8 }
{ &quot;key&quot;: &quot;rate&quot;, &quot;key_counts&quot;: 8 }
{ &quot;key&quot;: &quot;latency&quot;, &quot;key_counts&quot;: 7 }
{ &quot;key&quot;: &quot;name&quot;, &quot;key_counts&quot;: 4 }
{ &quot;key&quot;: &quot;uid&quot;, &quot;key_counts&quot;: 3 }
{ &quot;key&quot;: &quot;uid2&quot;, &quot;key_counts&quot;: 1 }
{ &quot;key&quot;: &quot;qoh&quot;, &quot;key_fraction&quot;: 0.666667 }
{ &quot;key&quot;: &quot;rate&quot;, &quot;key_fraction&quot;: 0.666667 }
{ &quot;key&quot;: &quot;latency&quot;, &quot;key_fraction&quot;: 0.583333 }
{ &quot;key&quot;: &quot;name&quot;, &quot;key_fraction&quot;: 0.333333 }
{ &quot;key&quot;: &quot;uid&quot;, &quot;key_fraction&quot;: 0.250000 }
{ &quot;key&quot;: &quot;uid2&quot;, &quot;key_fraction&quot;: 0.083333 }
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --ijson --opprint put -q -f data/feature-count.mlr data/features.json
record_count
12

key     key_counts
qoh     8
rate    8
latency 7
name    4
uid     3
uid2    1

key     key_fraction
qoh     0.666667
rate    0.666667
latency 0.583333
name    0.333333
uid     0.250000
uid2    0.083333
</pre></div>
</div>
</div>
<div class="section" id="unsparsing">
<h2>Unsparsing<a class="headerlink" href="#unsparsing" title="Permalink to this headline">¶</a></h2>
<p>The previous section discussed how to fill out missing data fields within CSV with full header line – so the list of all field names is present within the header line. Next, let’s look at a related problem: we have data where each record has various key names but we want to produce rectangular output having the union of all key names.</p>
<p>For example, suppose you have JSON input like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cat data/sparse.json
{&quot;a&quot;:1,&quot;b&quot;:2,&quot;v&quot;:3}
{&quot;u&quot;:1,&quot;b&quot;:2}
{&quot;a&quot;:1,&quot;v&quot;:2,&quot;x&quot;:3}
{&quot;v&quot;:1,&quot;w&quot;:2}
</pre></div>
</div>
<p>There are field names <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, <code class="docutils literal notranslate"><span class="pre">v</span></code>, <code class="docutils literal notranslate"><span class="pre">u</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">w</span></code> in the data – but not all in every record.  Since we don’t know the names of all the keys until we’ve read them all, this needs to be a two-pass algorithm. On the first pass, remember all the unique key names and all the records; on the second pass, loop through the records filling in absent values, then producing output. Use <code class="docutils literal notranslate"><span class="pre">put</span> <span class="pre">-q</span></code> since we don’t want to produce per-record output, only emitting output in the <code class="docutils literal notranslate"><span class="pre">end</span></code> block:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cat data/unsparsify.mlr
# First pass:
# Remember all unique key names:
for (k in $*) {
  @all_keys[k] = 1;
}
# Remember all input records:
@records[NR] = $*;

# Second pass:
end {
  for (nr in @records) {
    # Get the sparsely keyed input record:
    irecord = @records[nr];
    # Fill in missing keys with empty string:
    map orecord = {};
    for (k in @all_keys) {
      if (haskey(irecord, k)) {
        orecord[k] = irecord[k];
      } else {
        orecord[k] = &quot;&quot;;
      }
    }
    # Produce the output:
    emit orecord;
  }
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --json put -q -f data/unsparsify.mlr data/sparse.json
{ &quot;a&quot;: 1, &quot;b&quot;: 2, &quot;v&quot;: 3, &quot;u&quot;: &quot;&quot;, &quot;x&quot;: &quot;&quot;, &quot;w&quot;: &quot;&quot; }
{ &quot;a&quot;: &quot;&quot;, &quot;b&quot;: 2, &quot;v&quot;: &quot;&quot;, &quot;u&quot;: 1, &quot;x&quot;: &quot;&quot;, &quot;w&quot;: &quot;&quot; }
{ &quot;a&quot;: 1, &quot;b&quot;: &quot;&quot;, &quot;v&quot;: 2, &quot;u&quot;: &quot;&quot;, &quot;x&quot;: 3, &quot;w&quot;: &quot;&quot; }
{ &quot;a&quot;: &quot;&quot;, &quot;b&quot;: &quot;&quot;, &quot;v&quot;: 1, &quot;u&quot;: &quot;&quot;, &quot;x&quot;: &quot;&quot;, &quot;w&quot;: 2 }
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --ijson --ocsv put -q -f data/unsparsify.mlr data/sparse.json
a,b,v,u,x,w
1,2,3,,,
,2,,1,,
1,,2,,3,
,,1,,,2
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mlr --ijson --opprint put -q -f data/unsparsify.mlr data/sparse.json
a b v u x w
1 2 3 - - -
- 2 - 1 - -
1 - 2 - 3 -
- - 1 - - 2
</pre></div>
</div>
<p>There is a keystroke-saving verb for this: <a class="reference internal" href="reference-verbs.html#reference-verbs-unsparsify"><span class="std std-ref">mlr unsparsify</span></a>.</p>
</div>
<div class="section" id="parsing-log-file-output">
<h2>Parsing log-file output<a class="headerlink" href="#parsing-log-file-output" title="Permalink to this headline">¶</a></h2>
<p>This, of course, depends highly on what’s in your log files. But, as an example, suppose you have log-file lines such as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">2015</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">08</span> <span class="mi">08</span><span class="p">:</span><span class="mi">29</span><span class="p">:</span><span class="mi">09</span><span class="p">,</span><span class="mi">445</span> <span class="n">INFO</span> <span class="n">com</span><span class="o">.</span><span class="n">company</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">to</span><span class="o">.</span><span class="n">ClassName</span> <span class="o">@</span> <span class="p">[</span><span class="n">sometext</span><span class="p">]</span> <span class="n">various</span><span class="o">/</span><span class="n">sorts</span><span class="o">/</span><span class="n">of</span> <span class="n">data</span> <span class="p">{</span><span class="o">&amp;</span> <span class="n">punctuation</span><span class="p">}</span> <span class="n">hits</span><span class="o">=</span><span class="mi">1</span> <span class="n">status</span><span class="o">=</span><span class="mi">0</span> <span class="n">time</span><span class="o">=</span><span class="mf">2.378</span>
</pre></div>
</div>
<p>I prefer to pre-filter with <code class="docutils literal notranslate"><span class="pre">grep</span></code> and/or <code class="docutils literal notranslate"><span class="pre">sed</span></code> to extract the structured text, then hand that to Miller. Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">grep</span> <span class="s1">&#39;various sorts&#39;</span> <span class="o">*.</span><span class="n">log</span> <span class="o">|</span> <span class="n">sed</span> <span class="s1">&#39;s/.*} //&#39;</span> <span class="o">|</span> <span class="n">mlr</span> <span class="o">--</span><span class="n">fs</span> <span class="n">space</span> <span class="o">--</span><span class="n">repifs</span> <span class="o">--</span><span class="n">oxtab</span> <span class="n">stats1</span> <span class="o">-</span><span class="n">a</span> <span class="nb">min</span><span class="p">,</span><span class="n">p10</span><span class="p">,</span><span class="n">p50</span><span class="p">,</span><span class="n">p90</span><span class="p">,</span><span class="nb">max</span> <span class="o">-</span><span class="n">f</span> <span class="n">time</span> <span class="o">-</span><span class="n">g</span> <span class="n">status</span>
</pre></div>
</div>
</div>
<div class="section" id="memoization-with-out-of-stream-variables">
<span id="cookbook-memoization-with-oosvars"></span><h2>Memoization with out-of-stream variables<a class="headerlink" href="#memoization-with-out-of-stream-variables" title="Permalink to this headline">¶</a></h2>
<p>The recursive function for the Fibonacci sequence is famous for its computational complexity.  Namely, using <em>f*(0)=1, *f*(1)=1, *f*(*n</em>)=*f*(<em>n</em>-1)+*f*(<em>n</em>-2) for <em>n*&amp;ge;2, the evaluation tree branches left as well as right at each non-trivial level, resulting in millions or more paths to the root 0/1 nodes for larger *n</em>. This program</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>mlr --ofmt &#39;%.9lf&#39; --opprint seqgen --start 1 --stop 28 then put &#39;
  func f(n) {
      @fcount += 1;              # count number of calls to the function
      if (n &lt; 2) {
          return 1
      } else {
          return f(n-1) + f(n-2) # recurse
      }
  }

  @fcount = 0;
  $o = f($i);
  $fcount = @fcount;

&#39; then put &#39;$seconds=systime()&#39; then step -a delta -f seconds then cut -x -f seconds
</pre></div>
</div>
<p>produces output like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">i</span>  <span class="n">o</span>      <span class="n">fcount</span>  <span class="n">seconds_delta</span>
<span class="mi">1</span>  <span class="mi">1</span>      <span class="mi">1</span>       <span class="mi">0</span>
<span class="mi">2</span>  <span class="mi">2</span>      <span class="mi">3</span>       <span class="mf">0.000039101</span>
<span class="mi">3</span>  <span class="mi">3</span>      <span class="mi">5</span>       <span class="mf">0.000015974</span>
<span class="mi">4</span>  <span class="mi">5</span>      <span class="mi">9</span>       <span class="mf">0.000019073</span>
<span class="mi">5</span>  <span class="mi">8</span>      <span class="mi">15</span>      <span class="mf">0.000026941</span>
<span class="mi">6</span>  <span class="mi">13</span>     <span class="mi">25</span>      <span class="mf">0.000036955</span>
<span class="mi">7</span>  <span class="mi">21</span>     <span class="mi">41</span>      <span class="mf">0.000056028</span>
<span class="mi">8</span>  <span class="mi">34</span>     <span class="mi">67</span>      <span class="mf">0.000086069</span>
<span class="mi">9</span>  <span class="mi">55</span>     <span class="mi">109</span>     <span class="mf">0.000134945</span>
<span class="mi">10</span> <span class="mi">89</span>     <span class="mi">177</span>     <span class="mf">0.000217915</span>
<span class="mi">11</span> <span class="mi">144</span>    <span class="mi">287</span>     <span class="mf">0.000355959</span>
<span class="mi">12</span> <span class="mi">233</span>    <span class="mi">465</span>     <span class="mf">0.000506163</span>
<span class="mi">13</span> <span class="mi">377</span>    <span class="mi">753</span>     <span class="mf">0.000811815</span>
<span class="mi">14</span> <span class="mi">610</span>    <span class="mi">1219</span>    <span class="mf">0.001297235</span>
<span class="mi">15</span> <span class="mi">987</span>    <span class="mi">1973</span>    <span class="mf">0.001960993</span>
<span class="mi">16</span> <span class="mi">1597</span>   <span class="mi">3193</span>    <span class="mf">0.003417969</span>
<span class="mi">17</span> <span class="mi">2584</span>   <span class="mi">5167</span>    <span class="mf">0.006215811</span>
<span class="mi">18</span> <span class="mi">4181</span>   <span class="mi">8361</span>    <span class="mf">0.008294106</span>
<span class="mi">19</span> <span class="mi">6765</span>   <span class="mi">13529</span>   <span class="mf">0.012095928</span>
<span class="mi">20</span> <span class="mi">10946</span>  <span class="mi">21891</span>   <span class="mf">0.019592047</span>
<span class="mi">21</span> <span class="mi">17711</span>  <span class="mi">35421</span>   <span class="mf">0.031193972</span>
<span class="mi">22</span> <span class="mi">28657</span>  <span class="mi">57313</span>   <span class="mf">0.057254076</span>
<span class="mi">23</span> <span class="mi">46368</span>  <span class="mi">92735</span>   <span class="mf">0.080307961</span>
<span class="mi">24</span> <span class="mi">75025</span>  <span class="mi">150049</span>  <span class="mf">0.129482031</span>
<span class="mi">25</span> <span class="mi">121393</span> <span class="mi">242785</span>  <span class="mf">0.213325977</span>
<span class="mi">26</span> <span class="mi">196418</span> <span class="mi">392835</span>  <span class="mf">0.334423065</span>
<span class="mi">27</span> <span class="mi">317811</span> <span class="mi">635621</span>  <span class="mf">0.605969906</span>
<span class="mi">28</span> <span class="mi">514229</span> <span class="mi">1028457</span> <span class="mf">0.971235037</span>
</pre></div>
</div>
<p>Note that the time it takes to evaluate the function is blowing up exponentially as the input argument increases. Using <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>-variables, which persist across records, we can cache and reuse the results of previous computations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>mlr --ofmt &#39;%.9lf&#39; --opprint seqgen --start 1 --stop 28 then put &#39;
  func f(n) {
    @fcount += 1;                 # count number of calls to the function
    if (is_present(@fcache[n])) { # cache hit
      return @fcache[n]
    } else {                      # cache miss
      num rv = 1;
      if (n &gt;= 2) {
        rv = f(n-1) + f(n-2)      # recurse
      }
      @fcache[n] = rv;
      return rv
    }
  }
  @fcount = 0;
  $o = f($i);
  $fcount = @fcount;
&#39; then put &#39;$seconds=systime()&#39; then step -a delta -f seconds then cut -x -f seconds
</pre></div>
</div>
<p>with output like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">i</span>  <span class="n">o</span>      <span class="n">fcount</span> <span class="n">seconds_delta</span>
<span class="mi">1</span>  <span class="mi">1</span>      <span class="mi">1</span>      <span class="mi">0</span>
<span class="mi">2</span>  <span class="mi">2</span>      <span class="mi">3</span>      <span class="mf">0.000053883</span>
<span class="mi">3</span>  <span class="mi">3</span>      <span class="mi">3</span>      <span class="mf">0.000035048</span>
<span class="mi">4</span>  <span class="mi">5</span>      <span class="mi">3</span>      <span class="mf">0.000045061</span>
<span class="mi">5</span>  <span class="mi">8</span>      <span class="mi">3</span>      <span class="mf">0.000014067</span>
<span class="mi">6</span>  <span class="mi">13</span>     <span class="mi">3</span>      <span class="mf">0.000028849</span>
<span class="mi">7</span>  <span class="mi">21</span>     <span class="mi">3</span>      <span class="mf">0.000028133</span>
<span class="mi">8</span>  <span class="mi">34</span>     <span class="mi">3</span>      <span class="mf">0.000027895</span>
<span class="mi">9</span>  <span class="mi">55</span>     <span class="mi">3</span>      <span class="mf">0.000014067</span>
<span class="mi">10</span> <span class="mi">89</span>     <span class="mi">3</span>      <span class="mf">0.000015020</span>
<span class="mi">11</span> <span class="mi">144</span>    <span class="mi">3</span>      <span class="mf">0.000012875</span>
<span class="mi">12</span> <span class="mi">233</span>    <span class="mi">3</span>      <span class="mf">0.000033140</span>
<span class="mi">13</span> <span class="mi">377</span>    <span class="mi">3</span>      <span class="mf">0.000014067</span>
<span class="mi">14</span> <span class="mi">610</span>    <span class="mi">3</span>      <span class="mf">0.000012875</span>
<span class="mi">15</span> <span class="mi">987</span>    <span class="mi">3</span>      <span class="mf">0.000029087</span>
<span class="mi">16</span> <span class="mi">1597</span>   <span class="mi">3</span>      <span class="mf">0.000013828</span>
<span class="mi">17</span> <span class="mi">2584</span>   <span class="mi">3</span>      <span class="mf">0.000013113</span>
<span class="mi">18</span> <span class="mi">4181</span>   <span class="mi">3</span>      <span class="mf">0.000012875</span>
<span class="mi">19</span> <span class="mi">6765</span>   <span class="mi">3</span>      <span class="mf">0.000013113</span>
<span class="mi">20</span> <span class="mi">10946</span>  <span class="mi">3</span>      <span class="mf">0.000012875</span>
<span class="mi">21</span> <span class="mi">17711</span>  <span class="mi">3</span>      <span class="mf">0.000013113</span>
<span class="mi">22</span> <span class="mi">28657</span>  <span class="mi">3</span>      <span class="mf">0.000013113</span>
<span class="mi">23</span> <span class="mi">46368</span>  <span class="mi">3</span>      <span class="mf">0.000015974</span>
<span class="mi">24</span> <span class="mi">75025</span>  <span class="mi">3</span>      <span class="mf">0.000012875</span>
<span class="mi">25</span> <span class="mi">121393</span> <span class="mi">3</span>      <span class="mf">0.000013113</span>
<span class="mi">26</span> <span class="mi">196418</span> <span class="mi">3</span>      <span class="mf">0.000012875</span>
<span class="mi">27</span> <span class="mi">317811</span> <span class="mi">3</span>      <span class="mf">0.000013113</span>
<span class="mi">28</span> <span class="mi">514229</span> <span class="mi">3</span>      <span class="mf">0.000012875</span>
</pre></div>
</div>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Cookbook part 1: common patterns</a><ul>
<li><a class="reference internal" href="#headerless-csv-on-input-or-output">Headerless CSV on input or output</a></li>
<li><a class="reference internal" href="#doing-multiple-joins">Doing multiple joins</a></li>
<li><a class="reference internal" href="#bulk-rename-of-fields">Bulk rename of fields</a></li>
<li><a class="reference internal" href="#search-and-replace-over-all-fields">Search-and-replace over all fields</a></li>
<li><a class="reference internal" href="#full-field-renames-and-reassigns">Full field renames and reassigns</a></li>
<li><a class="reference internal" href="#numbering-and-renumbering-records">Numbering and renumbering records</a></li>
<li><a class="reference internal" href="#options-for-dealing-with-duplicate-rows">Options for dealing with duplicate rows</a></li>
<li><a class="reference internal" href="#data-cleaning-examples">Data-cleaning examples</a></li>
<li><a class="reference internal" href="#splitting-nested-fields">Splitting nested fields</a></li>
<li><a class="reference internal" href="#showing-differences-between-successive-queries">Showing differences between successive queries</a></li>
<li><a class="reference internal" href="#finding-missing-dates">Finding missing dates</a></li>
<li><a class="reference internal" href="#two-pass-algorithms">Two-pass algorithms</a><ul>
<li><a class="reference internal" href="#two-pass-algorithms-computation-of-percentages">Two-pass algorithms: computation of percentages</a></li>
<li><a class="reference internal" href="#two-pass-algorithms-line-number-ratios">Two-pass algorithms: line-number ratios</a></li>
<li><a class="reference internal" href="#two-pass-algorithms-records-having-max-value">Two-pass algorithms: records having max value</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rectangularizing-data">Rectangularizing data</a></li>
<li><a class="reference internal" href="#regularizing-ragged-csv">Regularizing ragged CSV</a></li>
<li><a class="reference internal" href="#feature-counting">Feature-counting</a></li>
<li><a class="reference internal" href="#unsparsing">Unsparsing</a></li>
<li><a class="reference internal" href="#parsing-log-file-output">Parsing log-file output</a></li>
<li><a class="reference internal" href="#memoization-with-out-of-stream-variables">Memoization with out-of-stream variables</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="data-examples.html"
                        title="previous chapter">Data-diving examples</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="cookbook2.html"
                        title="next chapter">Cookbook part 2: Random things, and some math</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/cookbook.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="cookbook2.html" title="Cookbook part 2: Random things, and some math"
             >next</a> |</li>
        <li class="right" >
          <a href="data-examples.html" title="Data-diving examples"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Miller 5.10.2 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Cookbook part 1: common patterns</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, John Kerl.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.2.1.
    </div>
  </body>
</html>